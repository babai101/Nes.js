/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./public/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/ringbufferjs/index.js":
/*!********************************************!*\
  !*** ./node_modules/ringbufferjs/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Expose `RingBuffer`.\n */\nmodule.exports = RingBuffer;\n\n/**\n * Initializes a new empty `RingBuffer` with the given `capacity`, when no\n * value is provided uses the default capacity (50).\n *\n * If provided, `evictedCb` gets run with any evicted elements.\n *\n * @param {capacity}\n * @param [evictedCb]\n * @return {RingBuffer}\n * @api public\n */\nfunction RingBuffer(capacity, evictedCb) {\n  this._elements = new Array(capacity || 50);\n  this._first = 0;\n  this._last = 0;\n  this._size = 0;\n  this._evictedCb = evictedCb;\n}\n\n/**\n * Returns the capacity of the ring buffer.\n *\n * @return {Number}\n * @api public\n */\nRingBuffer.prototype.capacity = function() {\n  return this._elements.length;\n};\n\n/**\n * Returns whether the ring buffer is empty or not.\n *\n * @return {Boolean}\n * @api public\n */\nRingBuffer.prototype.isEmpty = function() {\n  return this.size() === 0;\n};\n\n/**\n * Returns whether the ring buffer is full or not.\n *\n * @return {Boolean}\n * @api public\n */\nRingBuffer.prototype.isFull = function() {\n  return this.size() === this.capacity();\n};\n\n/**\n * Peeks at the top element of the queue.\n *\n * @return {Object}\n * @throws {Error} when the ring buffer is empty.\n * @api public\n */\nRingBuffer.prototype.peek = function() {\n  if (this.isEmpty()) throw new Error('RingBuffer is empty');\n\n  return this._elements[this._first];\n};\n\n/**\n * Peeks at multiple elements in the queue.\n *\n * @return {Array}\n * @throws {Error} when there are not enough elements in the buffer.\n * @api public\n */\nRingBuffer.prototype.peekN = function(count) {\n  if (count > this._size) throw new Error('Not enough elements in RingBuffer');\n\n  var end = Math.min(this._first + count, this.capacity());\n  var firstHalf = this._elements.slice(this._first, end);\n  if (end < this.capacity()) {\n    return firstHalf;\n  }\n  var secondHalf = this._elements.slice(0, count - firstHalf.length);\n  return firstHalf.concat(secondHalf);\n};\n\n/**\n * Dequeues the top element of the queue.\n *\n * @return {Object}\n * @throws {Error} when the ring buffer is empty.\n * @api public\n */\nRingBuffer.prototype.deq = function() {\n  var element = this.peek();\n\n  this._size--;\n  this._first = (this._first + 1) % this.capacity();\n\n  return element;\n};\n\n/**\n * Dequeues multiple elements of the queue.\n *\n * @return {Array}\n * @throws {Error} when there are not enough elements in the buffer.\n * @api public\n */\nRingBuffer.prototype.deqN = function(count) {\n  var elements = this.peekN(count);\n\n  this._size -= count;\n  this._first = (this._first + count) % this.capacity();\n\n  return elements;\n};\n\n/**\n * Enqueues the `element` at the end of the ring buffer and returns its new size.\n *\n * @param {Object} element\n * @return {Number}\n * @api public\n */\nRingBuffer.prototype.enq = function(element) {\n  this._end = (this._first + this.size()) % this.capacity();\n  var full = this.isFull()\n  if (full && this._evictedCb) {\n    this._evictedCb(this._elements[this._end]);\n  }\n  this._elements[this._end] = element;\n\n  if (full) {\n    this._first = (this._first + 1) % this.capacity();\n  } else {\n    this._size++;\n  }\n\n  return this.size();\n};\n\n/**\n * Returns the size of the queue.\n *\n * @return {Number}\n * @api public\n */\nRingBuffer.prototype.size = function() {\n  return this._size;\n};\n\n\n//# sourceURL=webpack:///./node_modules/ringbufferjs/index.js?");

/***/ }),

/***/ "./public/js/apu.js":
/*!**************************!*\
  !*** ./public/js/apu.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return apu; });\n/* harmony import */ var _pulse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pulse */ \"./public/js/pulse.js\");\n/* harmony import */ var _triangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triangle */ \"./public/js/triangle.js\");\n/* harmony import */ var ringbufferjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ringbufferjs */ \"./node_modules/ringbufferjs/index.js\");\n/* harmony import */ var ringbufferjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ringbufferjs__WEBPACK_IMPORTED_MODULE_2__);\n/*global performance*/\n//cycles per second 1786830\n\n\n\n\nfunction apu(nes) {\n    this.nes = nes;\n    this.sqe1Enabled = false;\n    this.sq2Enabled = false;\n    this.triangleEnabled = false;\n    this.noiseEnabled = false;\n    this.dmcEnabled = false;\n    this.inhibitInterrupt = true;\n    this.seqMode = 0;\n    this.cycles = 0;\n    this.sampleCycles = 0;\n    this.overSamplingCycles = 0;\n    this.sampleCycleRate = 39;\n    this.step = 0;\n    this.doIrq = false;\n    this.lengthCounterTbl = [10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30];\n    this.volumeLkpTbl = [-40.00, -24.44, -19.17, -15.92, -13.15, -11.06, -9.37, -7.96, -6.74, -5.68, -4.73, -2.38, -1.72, -1.11, -0.54, 0.00];\n    this.pulse1Buffer = [];\n    this.pulse2Buffer = [];\n    // this.outputBuffer = new Array(this.bufferLength);\n    this.bufferLength = 4096;\n    this.outputBuffer = new ringbufferjs__WEBPACK_IMPORTED_MODULE_2___default.a(this.bufferLength * 50);\n    this.bufferIndex = 0;\n    var pulse1 = new _pulse__WEBPACK_IMPORTED_MODULE_0__[\"default\"](nes);\n    var pulse2 = new _pulse__WEBPACK_IMPORTED_MODULE_0__[\"default\"](nes);\n    var triangle1 = new _triangle__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nes);\n    pulse1.channel = 1;\n    pulse2.channel = 2;\n    this.clock = true;\n    var sampleCount = 0;\n    var t1 = 0;\n    var t3 = 0;\n    var enqueCount = 0;\n    var apuExtraClock = 0;\n    this.samplingClock = performance.now();\n    this.sampleTimerMax = 1000.0 / 44100.0;\n    this.cyclesPerFrame = 1786830;\n    this.squareTable = new Array(31);\n    this.init = function() {\n        if (!window.AudioContext) {\n            if (!window.WebkitAudioContext) {\n                console.log(\"Could not initialize audio!\");\n                return;\n            }\n            else {\n                this.audioCtx = new window.WebkitAudioContext();\n            }\n        }\n        else {\n            this.audioCtx = new window.AudioContext();\n        }\n        t1 = performance.now();\n        this.scriptNode = this.audioCtx.createScriptProcessor(this.bufferLength, 0, 1);\n        this.scriptNode.onaudioprocess = this.onaudioprocess;\n        this.scriptNode.connect(this.audioCtx.destination);\n        // Create the filter\n        // var lowPassFilter = this.audioCtx.createBiquadFilter();\n        // var highPassFilter1 = this.audioCtx.createBiquadFilter();\n        // var highPassFilter2 = this.audioCtx.createBiquadFilter();\n        // lowPassFilter.type = 'lowpass';\n        // lowPassFilter.frequency.value = 14000; // Set cutoff to 440 HZ\n        // highPassFilter1.type = 'highpass';\n        // lowPassFilter.frequency.value = 90; // Set cutoff to 440 HZ\n        // highPassFilter2.type = 'highpass';\n        // highPassFilter2.frequency.value = 440; // Set cutoff to 440 HZ\n        // this.scriptNode.connect(highPassFilter1);\n        // highPassFilter1.connect(highPassFilter2);\n        // highPassFilter2.connect(lowPassFilter);\n        // lowPassFilter.connect(this.audioCtx.destination);\n        this.initSqrTable();\n    };\n    \n    this.initSqrTable = function() {\n        this.squareTable[0] = 0;\n        for(var i = 1; i < 31; i++) {\n            this.squareTable[i] = 95.88 / ((8128 / i) + 100);\n        }\n    };\n\n    // 0x4015\n    this.setAPUFlags = function(value) {\n        if (value & 0x01 == 1) {\n            pulse1.enabled = true;\n        }\n        else {\n            pulse1.enabled = false;\n        }\n        if (value & 0x02 == 0x02) {\n            pulse2.enabled = true;\n        }\n        else {\n            pulse2.enabled = false;\n        }\n        if (value & 0x04 == 0x04) {\n            triangle1.enabled = true;\n        }\n        else {\n            triangle1.enabled = false;\n        }\n        if (value & 0x08 == 0x08) {\n            this.noiseEnabled = true;\n        }\n        else {\n            this.noiseEnabled = false;\n        }\n        if (value & 0x10 == 0x10) {\n            this.dmcEnabled = true;\n        }\n        else {\n            this.dmcEnabled = false;\n        }\n    };\n\n    //Square channel 1 methods\n    //0x4000\n    this.setSQ1_ENV = function(value) {\n        pulse1.dividerPeriod = (value & 0x0F) + 1; //Env period\n        pulse1.dividerOriginalPeriod = pulse1.dividerPeriod;\n        if ((value & 0x10) == 0x10) {\n            pulse1.sawEnvDisable = true; //use Volume for volume\n        }\n        else {\n            pulse1.sawEnvDisable = false; //use internal counter for volume\n        }\n        pulse1.volume = value & 0x0F; //Set volume \n        if ((value & 0x20) == 0x20) {\n            pulse1.lenCounterDisable = true; //disable Length Counter\n        }\n        else {\n            pulse1.lenCounterDisable = false; //use Length Counter\n        }\n        pulse1.dutyCycle = value >> 6; //set duty cycle\n    };\n\n    //Set the low 8 bits of the period\n    //0x4002\n    this.setSQ1_LO = function(value) {\n        pulse1.periodLowBits = value;\n        pulse1.period = pulse1.period & 0x700;\n        pulse1.period = pulse1.period | pulse1.periodLowBits;\n    };\n\n    //Set the high 3 bits of the period if lengh counter is enabled, get the\n    //counter value from the look up table\n    //convert the period in to frequency\n    //0x4003\n    this.setSQ1_HI = function(value) {\n        pulse1.periodHighBits = value & 0x07;\n        pulse1.period = pulse1.period & 0xFF;\n        pulse1.period = pulse1.period | (pulse1.periodHighBits << 8);\n        if (pulse1.enabled) {\n            pulse1.lenCounter = this.lengthCounterTbl[value >> 3];\n        }\n        // pulse1.dividerPeriod = pulse1.dividerOriginalPeriod; //Restart envelop\n        pulse1.decayLvlCount = 0x0F;\n        // pulse1.setVol(pulse1.dividerOriginalPeriod - 1);\n        pulse1.currentSequence = 0;\n        pulse1.envStartFlag = true;\n    };\n\n    //0x4001\n    this.setSQ1_SWEEP = function(value) {\n        if ((value >> 7) == 1) {\n            pulse1.sweepEnabled = true;\n        }\n        else {\n            pulse1.sweepEnabled = false;\n        }\n        pulse1.sweepDividerPeriod = ((value & 0x70) >> 4) + 1;\n        pulse1.sweepCount = pulse1.sweepDividerPeriod;\n        pulse1.sweepNegate = (value & 0x08) >> 3;\n        pulse1.sweepShiftCount = value & 0x07;\n        pulse1.sweepReloadFlag = true;\n    };\n\n    //Square Channel 2 methods\n    this.setSQ2_ENV = function(value) {\n        pulse2.dividerPeriod = (value & 0x0F) + 1; //Env period\n        pulse2.dividerOriginalPeriod = pulse2.dividerPeriod;\n        pulse2.volume = value & 0x0F; //Set volume \n        if ((value & 0x10) == 0x10) {\n            pulse2.sawEnvDisable = true; //use Volume for volume\n        }\n        else {\n            pulse2.sawEnvDisable = false; //use internal counter for volume\n        }\n        if ((value & 0x20) == 0x20) {\n            pulse2.lenCounterDisable = true; //disable Length Counter\n        }\n        else {\n            pulse2.lenCounterDisable = false; //use Length Counter\n        }\n        pulse2.dutyCycle = value >> 6; //set duty cycle\n    };\n\n    this.setSQ2_LO = function(value) {\n        pulse2.periodLowBits = value;\n        pulse2.period = pulse2.period & 0x700;\n        pulse2.period = pulse2.period | pulse2.periodLowBits;\n    };\n\n    this.setSQ2_HI = function(value) {\n        pulse2.periodHighBits = value & 0x07;\n        pulse2.period = pulse2.period & 0xFF;\n        pulse2.period = pulse2.period | (pulse2.periodHighBits << 8);\n        if (pulse2.enabled) {\n            pulse2.lenCounter = this.lengthCounterTbl[value >> 3];\n        }\n        // pulse2.dividerPeriod = pulse2.dividerOriginalPeriod; //Restart envelop\n        pulse2.decayLvlCount = 0x0F;\n        // pulse2.setVol(pulse2.dividerOriginalPeriod - 1);\n        pulse1.currentSequence = 0;\n        pulse2.envStartFlag = true;\n    };\n\n    this.setSQ2_SWEEP = function(value) {\n        if ((value >> 7) == 1) {\n            pulse2.sweepEnabled = true;\n        }\n        else {\n            pulse2.sweepEnabled = false;\n        }\n        pulse2.sweepDividerPeriod = ((value & 0x70) >> 4) + 1;\n        pulse2.sweepCount = pulse2.sweepDividerPeriod;\n        pulse2.sweepNegate = (value & 0x08) >> 3;\n        pulse2.sweepShiftCount = value & 0x07;\n        pulse2.sweepReloadFlag = true;\n    };\n\n    this.setTRIControl = function(value) {\n        if ((value >> 7) == 1) {\n            triangle1.controlFlag = true;\n        }\n        else {\n            triangle1.controlFlag = false;\n        }\n        triangle1.counterReload = value & 0x7F;\n    };\n\n    this.setTRI_LO = function(value) {\n        triangle1.timerLowBits = value & 0xFF;\n    };\n\n    this.setTRI_HI = function(value) {\n        triangle1.timerHighBits = value & 0x07;\n        triangle1.lenCounter = value >> 3;\n        triangle1.lenCounterReloadFlag = true;\n    };\n\n    this.setFrameCounter = function(value) {\n        this.seqMode = value >> 7; //Sequencer mode\n        if ((value & 0x40) == 0x40) {\n            this.inhibitInterrupt = true;\n        }\n        else {\n            this.inhibitInterrupt = false;\n        }\n    };\n\n    this.onaudioprocess = (e) => {\n        var channelData = e.outputBuffer.getChannelData(0);\n        var size = channelData.length;\n        // var size = channelData.length;\n        // var samples = this.outputBuffer;\n        // for (var i = 0; i < size; i++) {\n        //     channelData[i] = samples[i];\n        // }\n        // this.outputBuffer = [];\n        // for (var i = 0, il = this.bufferLength; i < il; i++)\n        //     channelData[i] = this.outputBuffer[i];\n\n        // for (var i = this.bufferIndex, il = this.bufferLength; i < il; i++)\n        //     channelData[i] = this.bufferIndex === 0 ? 0.0 : this.outputBuffer[this.bufferIndex - 1];\n        try {\n            var samples = this.outputBuffer.deqN(size);\n        }\n        catch (e) {\n            // onBufferUnderrun failed to fill the buffer, so handle a real buffer\n            // underrun\n            // ignore empty buffers... assume audio has just stopped\n            var bufferSize = this.outputBuffer.size();\n            if (bufferSize > 0) {\n                console.log(`Buffer underrun (needed ${size}, got ${bufferSize})`);\n            }\n            for (var j = 0; j < size; j++) {\n                channelData[j] = 0;\n            }\n            return;\n        }\n        for (var i = 0; i < size; i++) {\n            channelData[i] = samples[i];\n        }\n        // this.bufferIndex = 0;\n    };\n\n    this.sample = function() {\n        sampleCount++;\n        var t2 = performance.now();\n        if (t2 - t1 >= 1000) {\n            t1 = performance.now();\n            console.log(\"sampling rate = \" + sampleCount + \" samples per second\");\n            sampleCount = 0;\n        }\n        // if (sampleCount >= 44100) {\n        //     return;\n        // }\n        var pulse1Output = Math.floor(this.pulse1Buffer.reduce((a, b) => a + b, 0));\n        if (pulse1Output != 0)\n            pulse1Output = pulse1Output / this.pulse1Buffer.length;\n        var pulse2Output = Math.floor(this.pulse2Buffer.reduce((a, b) => a + b, 0));\n        if (pulse2Output != 0)\n            pulse2Output = pulse2Output / this.pulse2Buffer.length;\n        this.pulse1Buffer = [];\n        this.pulse2Buffer = [];\n        var output = 0;\n        if (pulse1Output != 0 || pulse2Output != 0)\n            output = 95.88 / ((8128 / (pulse1Output + pulse2Output)) + 100);\n        // output = this.squareTable[pulse1Output + pulse2Output];\n        this.pushToBuffer(output);\n\n    };\n\n    this.pushToBuffer = function(data) {\n        // if (this.outputBuffer.size() >= this.bufferLength)\n        //     return;\n        this.outputBuffer.enq(data);\n    };\n\n    //Main APU clock at 240Hz perform step functions at 240Hz (~7457 CPU cycles)\n    this.run = function(cycles) {\n        var clocks = Math.floor(cycles / 2) + apuExtraClock;\n        // var clocks = cycles;\n        for (var i = 0; i < clocks; i++) {\n            pulse1.clock();\n            pulse2.clock();\n        }\n        apuExtraClock = cycles % 2;\n        this.cycles += cycles;\n        this.sampleCycles += cycles;\n        this.overSamplingCycles += cycles;\n        if (this.overSamplingCycles >= 2) {\n            this.pulse1Buffer.push(pulse1.output());\n            this.pulse2Buffer.push(pulse2.output());\n            this.overSamplingCycles -= 2;\n        }\n        if (this.sampleCycles >= this.sampleCycleRate) {\n            this.sampleCycles -= this.sampleCycleRate;\n            this.sample();\n            if (this.sampleCycleRate == 39)\n                this.sampleCycleRate = 40;\n            else if (this.sampleCycleRate == 40)\n                this.sampleCycleRate = 39;\n        }\n        if (this.cycles >= 7457) {\n            this.cycles -= 7457;\n            if (this.seqMode == 0) {\n                this.do4StepSeq();\n            }\n            else {\n                this.do5StepSeq();\n            }\n        }\n    };\n\n    this.do4StepSeq = function() {\n        pulse1.updateEnvelope();\n        pulse2.updateEnvelope();\n        // triangle1.updateLinearCounter();\n        if (this.step % 2 === 1) {\n            pulse1.updSweepAndLengthCounter();\n            pulse2.updSweepAndLengthCounter();\n        }\n        this.step++;\n        if (this.step === 4) {\n            if (!this.inhibitInterrupt) {\n                this.doIrq = true;\n            }\n            this.step = 0;\n        }\n    };\n\n    this.do5StepSeq = function() {\n        if (this.step % 2 === 0) {\n            pulse1.updSweepAndLengthCounter();\n            pulse2.updSweepAndLengthCounter();\n        }\n        this.step++;\n        if (this.step === 5) {\n            this.step = 0;\n        }\n        else {\n            pulse1.updateEnvelope();\n            pulse2.updateEnvelope();\n            // triangle1.updateLinearCounter();\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/apu.js?");

/***/ }),

/***/ "./public/js/cpu.js":
/*!**************************!*\
  !*** ./public/js/cpu.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return cpu; });\nfunction cpu(nes) {\n\tthis.nes = nes;\n\tthis.pc; // 16-Bit Program Counter\n\tthis.sp; // 8-Bit Stack Pointer\n\tthis.accumulator; // 8-Bit Accumulator\n\tthis.X; // 8-Bit Index Register X\n\tthis.Y; // 8-Bit Index Register Y\n\tthis.P; // Processor flag \n\tthis.errorFlag = false;\n\tthis.elapsedCycles;\n\tthis.elapsedCPUSyncCycles = 0;\n\tthis.totalElapsedCycles = 0;\n\tthis.totalCPUCyclesThisFrame = 0;\n\tthis.loggingEnabled = false;\n\tthis.excessCpuCycles = 0;\n\t// Bit No.       7   6   5   4   3   2   1   0\n\t//\t\t\t\t S   V       B   D   I   Z   C\t\n\n\n\t//PPU related VARS\n\tthis.renderedScanLine = -1;\n\tthis.ticksPerSecond = 29781;\n\tthis.remainingCPUCycles = 0;\n\tthis.ppuCyclesPerSecond = 89341.5;\n\tthis.ppuCyclesCurrentScanLine = 341;\n\tthis.oddFrame = false;\n\tthis.ppuSyncCycles = 0;\n\tthis.excessPPUCycles = 0;\n\tthis.nmiLoopCounter = 0;\n\tthis.masterCpuCyclesElapsed = 0;\n\tthis.currentOpcode; // Opcode currently processed\n\tthis.operationType; // Current operation type\n\tthis.cpuCyclesGenerated = 0;\n\tthis.cpuCyclesConsumed = 0;\n\tthis.ppuCyclesConsumed = 0;\n\tthis.cpuCyclesThisSecond = 0;\n\tthis.ppuCyclesThisFrame = 0;\n\tthis.frameCount = 0;\n\t//Reset CPU and initialize all registers and flags\n\tthis.reset = function() {\n\t\tthis.sp = 0xFD; //Adjusted for comparing with Nintedulator log\n\t\tthis.accumulator = 0x00;\n\t\tthis.X = 0x00;\n\t\tthis.Y = 0x00;\n\t\tthis.P = 0b00100100;\n\t\tthis.totalCpuCyclesDbg = 0;\n\t\tthis.excessCpuCyclesDbg = 0;\n\t\tthis.currentOpcode = 0x00;\n\t\tthis.elapsedCycles = 0;\n\t\tvar vector1 = this.nes.MMU.getCpuMemVal(this.nes.MMU.startAddress);\n\t\tvar vector2 = this.nes.MMU.getCpuMemVal(this.nes.MMU.startAddress + 1);\n\t\tvector2 = vector2 << 8;\n\t\tthis.pc = vector2 | vector1;\n\t};\n\n\tthis.prepareLogging = function() {\n\t\tthis.PCLog = (\"0000\" + this.pc.toString(16).toUpperCase()).slice(-4);\n\t\tthis.currentOpcodeLog = (\"00\" + this.currentOpcode.toString(16).toUpperCase()).slice(-2);\n\t\tthis.accumulatorLog = (\"00\" + this.accumulator.toString(16).toUpperCase()).slice(-2);\n\t\tthis.XLog = (\"00\" + this.X.toString(16).toUpperCase()).slice(-2);\n\t\tthis.YLog = (\"00\" + this.Y.toString(16).toUpperCase()).slice(-2);\n\t\tthis.SPLog = (\"00\" + this.sp.toString(16).toUpperCase()).slice(-2);\n\t\tthis.PLog = (\"00\" + this.P.toString(16).toUpperCase()).slice(-2);\n\t\tthis.CYCLog = this.totalElapsedCycles;\n\t\tthis.ArgLog = '';\n\t\tthis.opcodeType = '';\n\t\tthis.memLog = '';\n\t};\n\n\tthis.logInConsole = function() {\n\t\t// var temp1 = (this.currentOpcodeLog + ' ' + this.ArgLog + '          ').slice(0, 10);\n\t\tvar temp1 = (this.currentOpcodeLog + ' ' + this.ArgLog + '          ').slice(0, 9);\n\t\tif (this.opcodeType[0] != '*') {\n\t\t\tthis.opcodeType = ' ' + this.opcodeType;\n\t\t}\n\t\tvar temp2 = this.PCLog + '  ' + temp1 + this.opcodeType;\n\t\tvar logLine = temp2 + '  ' + 'A:' + this.accumulatorLog + ' X:' + this.XLog + ' Y:' + this.YLog + ' P:' + this.PLog + ' SP:' + this.SPLog + ' CYC:' + this.CYCLog;\n\t\tconsole.log(logLine);\n\t};\n\t//Fetch opcode from work ram \n\tthis.fetchOpcode = function() {\n\t\tthis.currentOpcode = this.nes.MMU.getCpuMemVal(this.pc); // Fetched opcode only\n\t};\n\n\t//Fetch parameters for opcode\n\tthis.fetchParams = function() {\n\t\tvar param = this.nes.MMU.getCpuMemVal(this.pc);\n\n\t\t// if (this.ArgLog.length > 0) {\n\t\t// \tthis.ArgLog = this.ArgLog.concat(' ', (\"00\" + param.toString(16).toUpperCase()).slice(-2));\n\t\t// }\n\t\t// else\n\t\t// \tthis.ArgLog = (\"00\" + param.toString(16).toUpperCase()).slice(-2);\n\t\tthis.pc++;\n\t\treturn param;\n\t};\n\n\tthis.setFlag = function(flagToSet) {\n\t\tswitch (flagToSet) {\n\t\t\tcase 'carry':\n\t\t\t\tthis.P = this.P & 0b11111110;\n\t\t\t\tthis.P = this.P | 0b00000001;\n\t\t\t\tbreak;\n\n\t\t\tcase 'zero':\n\t\t\t\tthis.P = this.P & 0b11111101;\n\t\t\t\tthis.P = this.P | 0b00000010;\n\t\t\t\tbreak;\n\n\t\t\tcase 'irqDisable':\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tthis.P = this.P | 0b00000100;\n\t\t\t\tbreak;\n\n\t\t\tcase 'decimal':\n\t\t\t\tthis.P = this.P & 0b11110111;\n\t\t\t\tthis.P = this.P | 0b00001000;\n\t\t\t\tbreak;\n\n\t\t\tcase 'overflow':\n\t\t\t\tthis.P = this.P & 0b10111111;\n\t\t\t\tthis.P = this.P | 0b01000000;\n\t\t\t\tbreak;\n\n\t\t\tcase 'negative':\n\t\t\t\tthis.P = this.P & 0b01111111;\n\t\t\t\tthis.P = this.P | 0b10000000;\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tthis.unsetFlag = function(flagToUnset) {\n\t\tswitch (flagToUnset) {\n\t\t\tcase 'carry':\n\t\t\t\tthis.P = this.P & 0b11111110;\n\t\t\t\tbreak;\n\n\t\t\tcase 'zero':\n\t\t\t\tthis.P = this.P & 0b11111101;\n\t\t\t\tbreak;\n\n\t\t\tcase 'irqDisable':\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tbreak;\n\n\t\t\tcase 'decimal':\n\t\t\t\tthis.P = this.P & 0b11110111;\n\t\t\t\tbreak;\n\n\t\t\tcase 'overflow':\n\t\t\t\tthis.P = this.P & 0b10111111;\n\t\t\t\tbreak;\n\n\t\t\tcase 'negative':\n\t\t\t\tthis.P = this.P & 0b01111111;\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tthis.calcFlags = function(arg, checkOverflow, newValue) {\n\n\t\t// var bit7 = registerToCheck >> 7;\n\t\t//check if overflow flag is to be determined\n\t\tif (checkOverflow) {\n\t\t\t// if (bit7 != (newValue >> 7))\n\t\t\t// \tthis.setFlag('overflow');\n\t\t\t// else \n\t\t\t// \tthis.unsetFlag('overflow');\n\t\t\tif (~(this.accumulator ^ arg) & (this.accumulator ^ newValue) & 0x80)\n\t\t\t\tthis.setFlag('overflow');\n\t\t\telse\n\t\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\t//check for zero flag\n\t\t\tif (arg == null)\n\t\t\t\targ = this.accumulator;\n\t\t\tif (arg == 0x00)\n\t\t\t\tthis.setFlag('zero');\n\t\t\telse\n\t\t\t\tthis.unsetFlag('zero');\n\t\t\t//check for negative flag\t\n\t\t\tif ((arg >> 7) == 1)\n\t\t\t\tthis.setFlag('negative');\n\t\t\telse\n\t\t\t\tthis.unsetFlag('negative');\n\t\t}\n\t};\n\n\tthis.writeCarry = function(value) {\n\t\tif (value > 0xFF) {\n\t\t\tthis.setFlag('carry');\n\t\t\tvalue = value & 0xFF;\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t\treturn value;\n\t\t}\n\t};\n\n\tthis.wrap8bit = function(operation, operand, input) {\n\t\tvar output = operand;\n\t\tswitch (operation) {\n\t\t\tcase 'increment':\n\t\t\t\t//Simple one off wrap around \t\n\t\t\t\tif (operand == 0xFF)\n\t\t\t\t\toutput = 0x00;\n\t\t\t\telse output = operand + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'decrement':\n\t\t\t\t//Simple one off wrap around\n\t\t\t\tif (operand == 0x00)\n\t\t\t\t\toutput = 0xFF;\n\t\t\t\telse output = operand - 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'sum':\n\t\t\t\t//Wrap around from zero and go upwards \n\t\t\t\tvar temp = operand + input;\n\t\t\t\tif (temp > 0xFF) {\n\t\t\t\t\toutput = 0x00 + (temp - 0xFF - 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput = temp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'subtract':\n\t\t\t\t//Wrap around from FF and go downwards\n\t\t\t\tif (input > operand) {\n\t\t\t\t\toutput = 0xFF - (input - operand - 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput = operand - input;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn output;\n\t};\n\n\tthis.to2sComplement = function(val) {\n\t\tif (val == 128)\n\t\t\treturn -128;\n\t\telse if (val >= 129 && val <= 255)\n\t\t\treturn val - 256;\n\t\telse return val;\n\t};\n\n\tthis.toSigned8bit = function(val) {\n\t\tif (val == -128)\n\t\t\treturn 128;\n\t\telse if (val >= 0 && val <= 127)\n\t\t\treturn val;\n\t\telse return val + 256;\n\t};\n\n\tthis.pushToStack = function(value) {\n\t\tthis.nes.MMU.setCpuMemVal((0x100 + this.sp), (value));\n\t\tif (this.sp == 0x00)\n\t\t\tthis.sp = 0xFF;\n\t\telse\n\t\t\tthis.sp--;\n\t};\n\n\n\tthis.popFromStack = function() {\n\t\tif (this.sp == 0xFF)\n\t\t\tthis.sp = 0x00;\n\t\telse\n\t\t\tthis.sp++;\n\t\tvar value = this.nes.MMU.getCpuMemVal(0x100 + this.sp);\n\t\treturn value;\n\t};\n\n\tthis.calcOffset = function(param) {\n\t\tif (param > 0x7F) {\n\t\t\tparam = param ^ 0b11111111;\n\t\t\tparam++;\n\t\t\tparam = 0 - param;\n\t\t}\n\t\treturn param;\n\t};\n\n\tthis.compareValsAndSetNegative = function(val1, val2) {\n\t\t// if(val1 >= 0x00 && val1 < 0x80)\t{\n\t\t// \tif(val2 >= 0x00 && val2 < 0x80) {\n\t\t// \t\t//both are +ve numbers\n\t\t// \t\tif(val1 > val2)\n\t\t// \t\t\treturn 1;\n\t\t// \t\telse if(val1 == val2)\n\t\t// \t\t\treturn 0;\n\t\t// \t\telse if(val1 < val2)\n\t\t// \t\t\treturn -1;\n\t\t// \t}\n\t\t// \tif(val2 >= 0x80 && val2 <= 0xFF) {\n\t\t// \t\t//val1 +ve but val2 -ve so val1 is always greater\n\t\t// \t\treturn 1;\n\t\t// \t}\n\t\t// }\n\t\t// else if(val1 >= 0x80 && val1 <= 0xFF) {\n\t\t// \tif(val2 >= 0x00 && val2 < 0x80) {\n\t\t// \t\t//val1 -ve but val2 is +ve, val2 is always greater\n\t\t// \t\treturn -1;\n\t\t// \t}\n\t\t// \telse if(val2 >= 0x80 && val2 <= 0xFF) {\n\t\t// \t\t//both values are -ve\n\t\t// \t\tif(val1 > val2) {\n\t\t// \t\t\t//val1 more -ve therefore is lesser than val2\n\t\t// \t\t\treturn -1;\n\t\t// \t\t}\n\t\t// \t\telse if(val1 == val2) {\n\t\t// \t\t\treturn 0;\n\t\t// \t\t}\n\t\t// \t\telse if(val1 < val2) {\n\t\t// \t\t\t//val1 less -ve therefore is greater than val2\n\t\t// \t\t\treturn 1;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t//Turns out compare instructions do unsigned comparison :(\n\t\tvar temp = val1 - val2;\n\t\tif (((temp >> 7) & 1) == 1)\n\t\t\tthis.setFlag('negative');\n\t\telse\n\t\t\tthis.unsetFlag('negative');\n\n\t\tif (val1 > val2) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (val1 == val2) {\n\t\t\tthis.unsetFlag('negative');\n\t\t\treturn 0;\n\t\t}\n\t\telse if (val1 < val2) {\n\t\t\treturn -1;\n\t\t}\n\t};\n\n\t//Opcode implementaions\n\n\t//ADC instructinos \n\tthis.ADC_I = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\t//increment pc by 1\n\t\tthis.pc++;\n\t\t//fetch single param\n\t\tvar param = this.fetchParams();\n\t\tvar arg = param;\n\t\t// //Add with carry\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// //calculate sign change and set overflow flag accordingly\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// //calculate zero,sign flag status\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.ADC_Z = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(arg, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + arg.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.ADC_Z_X = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar arg = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(arg, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ADC_A = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(arg, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + arg.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ADC_A_X = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(arg, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ADC_A_Y = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(arg, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ADC_I_X = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(arg, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + arg.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ADC_I_Y = function() {\n\t\tthis.opcodeType = 'ADC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += ;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar arg = this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(arg, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 6;\n\t\telse\n\t\t\tthis.elapsedCycles += 5;\n\t};\n\n\t//SBC Instructions\n\tthis.SBC_I = function() {\n\t\tif (this.currentOpcode == 0xEB) {\n\t\t\tthis.opcodeType = '*SBC';\n\t\t}\n\t\telse\n\t\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\t//fetch single param\n\t\tvar arg = this.fetchParams();\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 2;\n\n\t\t// var arg = this.fetchParams();\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// if(this.loggingEnabled)\n\t\t// \tthis.memLog = '#$' + ('00' + arg.toString(16).toUpperCase()).slice(-2);\n\t\t// //instLen = 2;\n\t\t// this.elapsedCycles += 2;\n\t};\n\n\tthis.SBC_Z = function() {\n\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 3;\n\t\t// var param = this.fetchParams();\n\t\t// var arg = this.nes.MMU.getCpuMemVal(param);\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + arg.toString(16).toUpperCase()).slice(-2);\n\t\t// //instLen = 2;\n\t\t// this.elapsedCycles += 3;\n\t};\n\n\tthis.SBC_Z_X = function() {\n\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar arg = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 4;\n\t\t// var param = this.fetchParams();\n\t\t// var arg = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// //instLen = 2;\n\t\t// this.elapsedCycles += 4;\n\t};\n\n\tthis.SBC_A = function() {\n\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 4;\n\t\t// var param1 = this.fetchParams();\n\t\t// var param2 = this.fetchParams();\n\t\t// param2 = param2 << 8;\n\t\t// var param = param2 | param1;\n\t\t// var arg = this.nes.MMU.getCpuMemVal(param);\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + arg.toString(16).toUpperCase()).slice(-2);\n\t\t// //instLen = 3;\n\t\t// this.elapsedCycles += 4;\n\t};\n\n\tthis.SBC_A_X = function() {\n\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t\t// var param1 = this.fetchParams();\n\t\t// var param2 = this.fetchParams();\n\t\t// param2 = param2 << 8;\n\t\t// var param = param2 | param1;\n\t\t// var arg = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// //instLen = 3;\n\t\t// if ((param1 + this.X) > 0xFF)\n\t\t// \tthis.elapsedCycles += 5;\n\t\t// else\n\t\t// \tthis.elapsedCycles += 4;\n\t};\n\n\tthis.SBC_A_Y = function() {\n\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t\t// var param1 = this.fetchParams();\n\t\t// var param2 = this.fetchParams();\n\t\t// param2 = param2 << 8;\n\t\t// var param = param2 | param1;\n\t\t// var arg = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// //instLen = 3;\n\t\t// if ((param1 + this.Y) > 0xFF)\n\t\t// \tthis.elapsedCycles += 5;\n\t\t// else\n\t\t// \tthis.elapsedCycles += 4;\n\t};\n\n\tthis.SBC_I_X = function() {\n\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar arg = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t\t// var param = this.fetchParams();\n\t\t// var index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\t// var index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\t// index2 = index2 << 8;\n\t\t// var arg = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + arg.toString(16).toUpperCase()).slice(-2);\n\t\t// //instLen = 2;\n\t\t// this.elapsedCycles += 6;\n\t};\n\n\tthis.SBC_I_Y = function() {\n\t\tthis.opcodeType = 'SBC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar arg = this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\t// this.F_SIGN = (temp >> 7) & 1;\n\t\t// this.F_ZERO = temp & 0xff;\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag('carry');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('carry');\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 6;\n\t\telse\n\t\t\tthis.elapsedCycles += 5;\n\t\t// var param = this.fetchParams();\n\t\t// var index1 = this.nes.MMU.getCpuMemVal(param);\n\t\t// var index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\t// index2 = index2 << 8;\n\t\t// var arg = this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\t// var temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\t// if ((this.P & 0x01) == 0x00)\n\t\t// \ttemp = temp - 1;\n\t\t// if (temp < -128 || temp > 127) {\n\t\t// \tthis.setFlag('overflow');\n\t\t// }\n\t\t// else this.unsetFlag('overflow');\n\n\t\t// if (this.accumulator >= arg)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\n\t\t// this.accumulator = this.toSigned8bit(temp);\n\t\t// this.calcFlags(null, false, null);\n\t\t// //instLen = 2;\n\t\t// if ((index1 + this.Y) > 0xFF)\n\t\t// \tthis.elapsedCycles += 6;\n\t\t// else\n\t\t// \tthis.elapsedCycles += 5;\n\t};\n\n\t//AND Instructions\n\n\tthis.AND_I = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator & param;\n\t\tthis.calcFlags(null, false, null);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.AND_Z = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.AND_Z_X = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.AND_A = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.AND_A_X = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.AND_A_Y = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.AND_I_X = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.AND_I_Y = function() {\n\t\tthis.opcodeType = 'AND';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.Y;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 6;\n\t\telse\n\t\t\tthis.elapsedCycles += 5;\n\t};\n\n\t//EOR Instructions\n\n\tthis.EOR_I = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator ^ param;\n\t\tthis.calcFlags(null, false, null);\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.EOR_Z = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.EOR_Z_X = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.EOR_A = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.EOR_A_X = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.EOR_A_Y = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.EOR_I_X = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.EOR_I_Y = function() {\n\t\tthis.opcodeType = 'EOR';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.Y;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 6;\n\t\telse\n\t\t\tthis.elapsedCycles += 5;\n\t};\n\n\t//ORA Instructions\n\n\tthis.ORA_I = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator | param;\n\t\tthis.calcFlags(null, false, null);\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.ORA_Z = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.ORA_Z_X = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ORA_A = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ORA_A_X = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ORA_A_Y = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.ORA_I_X = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ORA_I_Y = function() {\n\t\tthis.opcodeType = 'ORA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.Y;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 6;\n\t\telse\n\t\t\tthis.elapsedCycles += 5;\n\t};\n\n\t//ASL Instructions\n\n\tthis.ASL_AC = function() {\n\t\tthis.opcodeType = 'ASL';\n\t\tthis.pc++;\n\t\tif ((this.accumulator >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.accumulator = this.accumulator << 1;\n\t\tthis.accumulator = this.accumulator & 0xFF;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memLog = 'A';\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.ASL_Z = function() {\n\t\tthis.opcodeType = 'ASL';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, this.nes.MMU.getCpuMemVal(param) << 1);\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.ASL_Z_X = function() {\n\t\tthis.opcodeType = 'ASL';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) << 1));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ASL_A = function() {\n\t\tthis.opcodeType = 'ASL';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ASL_A_X = function() {\n\t\tthis.opcodeType = 'ASL';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) << 1));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\t//LDA instructions\n\n\tthis.LDA_I = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = param;\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\n\tthis.LDA_Z = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + this.accumulator.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.LDA_Z_X = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LDA_A = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + this.accumulator.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LDA_A_X = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// this.accumulator = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LDA_A_Y = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// this.accumulator = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.Y));\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LDA_I_X = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + this.accumulator.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.LDA_I_Y = function() {\n\t\tthis.opcodeType = 'LDA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\t// this.accumulator = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', (index2 | index1), this.Y));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 6;\n\t\telse\n\t\t\tthis.elapsedCycles += 5;\n\t};\n\n\n\t//LDX instructions\n\n\tthis.LDX_I = function() {\n\t\tthis.opcodeType = 'LDX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.X = param;\n\t\tthis.calcFlags(this.X, false, null);\n\t\t//instLen = 2;\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.LDX_Z = function() {\n\t\tthis.opcodeType = 'LDX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.X = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(this.X, false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + this.X.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.LDX_Z_Y = function() {\n\t\tthis.opcodeType = 'LDX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.X = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.Y));\n\t\tthis.calcFlags(this.X, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LDX_A = function() {\n\t\tthis.opcodeType = 'LDX';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.X = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(this.X, false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + this.X.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\n\tthis.LDX_A_Y = function() {\n\t\tthis.opcodeType = 'LDX';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// this.X = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.Y));\n\t\tthis.X = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(this.X, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\t//LDY Instructions\n\n\tthis.LDY_I = function() {\n\t\tthis.opcodeType = 'LDY';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.Y = param;\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t//instLen = 2;\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.LDY_Z = function() {\n\t\tthis.opcodeType = 'LDY';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.Y = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + this.Y.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.LDY_Z_X = function() {\n\t\tthis.opcodeType = 'LDY';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.Y = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LDY_A = function() {\n\t\tthis.opcodeType = 'LDY';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.Y = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + this.Y.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LDY_A_X = function() {\n\t\tthis.opcodeType = 'LDY';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// this.Y = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.Y = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\t//LSR Instructions\n\n\tthis.LSR_AC = function() {\n\t\tthis.opcodeType = 'LSR';\n\t\tthis.pc++;\n\t\tif ((this.accumulator & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.accumulator = this.accumulator >> 1;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memLog = 'A';\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.LSR_Z = function() {\n\t\tthis.opcodeType = 'LSR';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.LSR_Z_X = function() {\n\t\tthis.opcodeType = 'LSR';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 1));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.LSR_A = function() {\n\t\tthis.opcodeType = 'LSR';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.LSR_A_X = function() {\n\t\tthis.opcodeType = 'LSR';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) >> 1));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\t//ROL Instructions\n\n\tthis.ROL_AC = function() {\n\t\tthis.opcodeType = 'ROL';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tif ((this.accumulator >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.accumulator = this.accumulator << 1;\n\t\tthis.accumulator = this.accumulator & 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tthis.accumulator = this.accumulator | 0b00000001;\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memLog = 'A';\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.ROL_Z = function() {\n\t\tthis.opcodeType = 'ROL';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b00000001));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.ROL_Z_X = function() {\n\t\tthis.opcodeType = 'ROL';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) | 0b00000001));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ROL_A = function() {\n\t\tthis.opcodeType = 'ROL';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b00000001));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ROL_A_X = function() {\n\t\tthis.opcodeType = 'ROL';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) | 0b00000001));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\t//ROR Instructions\n\n\tthis.ROR_AC = function() {\n\t\tthis.opcodeType = 'ROR';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tif ((this.accumulator & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.accumulator = this.accumulator >> 1;\n\t\tif (currCarry == 1) {\n\t\t\tthis.accumulator = this.accumulator | 0b10000000;\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memLog = 'A';\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.ROR_Z = function() {\n\t\tthis.opcodeType = 'ROR';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tif (this.loggingEnabled) {\n\t\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t\tthis.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t}\n\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b10000000));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.ROR_Z_X = function() {\n\t\tthis.opcodeType = 'ROR';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) | 0b10000000));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ROR_A = function() {\n\t\tthis.opcodeType = 'ROR';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b10000000));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ROR_A_X = function() {\n\t\tthis.opcodeType = 'ROR';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) | 0b10000000));\n\t\t}\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\t//STA Instructions\n\n\tthis.STA_Z = function() {\n\t\tthis.opcodeType = 'STA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// var memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.setCpuMemVal(param, (this.accumulator));\n\t\tif (this.loggingEnabled) {\n\t\t\tthis.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.STA_Z_X = function() {\n\t\tthis.opcodeType = 'STA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.accumulator));\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.STA_A = function() {\n\t\tthis.opcodeType = 'STA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// var memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.setCpuMemVal(param, (this.accumulator));\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.STA_A_X = function() {\n\t\tthis.opcodeType = 'STA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// this.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.accumulator));\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.accumulator));\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.STA_A_Y = function() {\n\t\tthis.opcodeType = 'STA';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// this.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.Y)), (this.accumulator));\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.accumulator));\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.STA_I_X = function() {\n\t\tthis.opcodeType = 'STA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\t// var memLogBeforeVar = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tvar memLogBeforeVar = this.nes.MMU.setCpuMemVal((index2 | index1), (this.accumulator));\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.STA_I_Y = function() {\n\t\tthis.opcodeType = 'STA';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\t// this.nes.MMU.setCpuMemVal((this.wrap8bit('sum', (index2 | index1), this.Y)), (this.accumulator));\n\t\tthis.nes.MMU.setCpuMemVal(((index2 | index1) + this.Y), (this.accumulator));\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\t//Stack Instructions\n\n\tthis.TXS = function() {\n\t\tthis.opcodeType = 'TXS';\n\t\tthis.pc++;\n\t\tthis.sp = this.X;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.TSX = function() {\n\t\tthis.opcodeType = 'TSX';\n\t\tthis.pc++;\n\t\tthis.X = this.sp;\n\t\tthis.calcFlags(this.X, false, null);\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.PHA = function() {\n\t\tthis.opcodeType = 'PHA';\n\t\tthis.pc++;\n\t\tthis.pushToStack(this.accumulator);\n\t\t// this.nes.MMU.setCpuMemVal(0x100 + this.sp) = this.accumulator;\n\t\t// if (this.sp == 0x00)\n\t\t// \tthis.sp = 0xFF;\n\t\t// else\n\t\t// \tthis.sp--;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.PLA = function() {\n\t\tthis.opcodeType = 'PLA';\n\t\tthis.pc++;\n\t\tthis.accumulator = this.popFromStack();\n\t\t// this.accumulator = this.nes.MMU.setCpuMemVal(0x100 + this.sp);\n\t\t// if (this.sp == 0xFF)\n\t\t// \tthis.sp = 0x00;\n\t\t// else\n\t\t// \tthis.sp++;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.PHP = function() {\n\t\tthis.opcodeType = 'PHP';\n\t\tthis.pc++;\n\t\tvar temp = this.P;\n\t\ttemp = temp & 0b11101111;\n\t\ttemp = temp | 0b00110000;\n\t\tthis.pushToStack(temp);\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.PLP = function() {\n\t\tthis.opcodeType = 'PLP';\n\t\tthis.pc++;\n\t\tvar temp = this.popFromStack();\n\t\tif ((temp & 0b00000001) == 0x01)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tif ((temp & 0b00000010) >> 1 == 0x01)\n\t\t\tthis.setFlag('zero');\n\t\telse this.unsetFlag('zero');\n\n\t\tif ((temp & 0b00000100) >> 2 == 0x01)\n\t\t\tthis.setFlag('irqDisable');\n\t\telse this.unsetFlag('irqDisable');\n\n\t\tif ((temp & 0b00001000) >> 3 == 0x01)\n\t\t\tthis.setFlag('decimal');\n\t\telse this.unsetFlag('decimal');\n\n\t\tif ((temp & 0b01000000) >> 6 == 0x01)\n\t\t\tthis.setFlag('overflow');\n\t\telse this.unsetFlag('overflow');\n\n\t\tif ((temp & 0b10000000) >> 7 == 0x01)\n\t\t\tthis.setFlag('negative');\n\t\telse this.unsetFlag('negative');\n\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\n\t//STX Instructions\n\n\tthis.STX_Z = function() {\n\t\tthis.opcodeType = 'STX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// var memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.setCpuMemVal(param, (this.X));\n\t\t//instLen = 2;\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.STX_Z_Y = function() {\n\t\tthis.opcodeType = 'STX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.Y)), (this.X));\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.STX_A = function() {\n\t\tthis.opcodeType = 'STX';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// var memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.setCpuMemVal(param, (this.X));\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\n\t//STY Instructions\n\n\tthis.STY_Z = function() {\n\t\tthis.opcodeType = 'STY';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// var memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.setCpuMemVal(param, (this.Y));\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.STY_Z_X = function() {\n\t\tthis.opcodeType = 'STY';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal(this.wrap8bit('sum', param, this.X), (this.Y));\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.STY_A = function() {\n\t\tthis.opcodeType = 'STY';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// var memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tvar memLogBeforeVar = this.nes.MMU.setCpuMemVal(param, (this.Y));\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\n\t//Register Instructions\n\n\tthis.TAX = function() {\n\t\tthis.opcodeType = 'TAX';\n\t\tthis.pc++;\n\t\tthis.X = this.accumulator;\n\t\tthis.calcFlags(this.X, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.TXA = function() {\n\t\tthis.opcodeType = 'TXA';\n\t\tthis.pc++;\n\t\tthis.accumulator = this.X;\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.DEX = function() {\n\t\tthis.opcodeType = 'DEX';\n\t\tthis.pc++;\n\t\tthis.X = this.wrap8bit('decrement', this.X, null);\n\t\tthis.calcFlags(this.X, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.INX = function() {\n\t\tthis.opcodeType = 'INX';\n\t\tthis.pc++;\n\t\tthis.X = this.wrap8bit('increment', this.X, null);\n\t\tthis.calcFlags(this.X, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.TAY = function() {\n\t\tthis.opcodeType = 'TAY';\n\t\tthis.pc++;\n\t\tthis.Y = this.accumulator;\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.TYA = function() {\n\t\tthis.opcodeType = 'TYA';\n\t\tthis.pc++;\n\t\tthis.accumulator = this.Y;\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.DEY = function() {\n\t\tthis.opcodeType = 'DEY';\n\t\tthis.pc++;\n\t\tthis.Y = this.wrap8bit('decrement', this.Y, null);\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.INY = function() {\n\t\tthis.opcodeType = 'INY';\n\t\tthis.pc++;\n\t\tthis.Y = this.wrap8bit('increment', this.Y, null);\n\t\tthis.calcFlags(this.Y, false, null);\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\t//INC Instructions\n\n\tthis.INC_Z = function() {\n\t\tthis.opcodeType = 'INC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param), null)));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.INC_Z_X = function() {\n\t\tthis.opcodeType = 'INC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar loc = this.wrap8bit('sum', param, this.X);\n\t\tvar valueAtLoc = this.nes.MMU.getCpuMemVal(loc);\n\t\t//increment\n\t\tvalueAtLoc = this.wrap8bit('increment', valueAtLoc, null);\n\t\t// this.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), null)));\n\t\tthis.nes.MMU.setCpuMemVal(loc, valueAtLoc);\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(loc), false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.INC_A = function() {\n\t\tthis.opcodeType = 'INC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param), null)));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.INC_A_X = function() {\n\t\tthis.opcodeType = 'INC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param + this.X), null)));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\tthis.DEC_Z = function() {\n\t\tthis.opcodeType = 'DEC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param), null)));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.DEC_Z_X = function() {\n\t\tthis.opcodeType = 'DEC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), null)));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.DEC_A = function() {\n\t\tthis.opcodeType = 'DEC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param), null)));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.DEC_A_X = function() {\n\t\tthis.opcodeType = 'DEC';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param + this.X), null)));\n\t\tthis.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\t//Flag Instructions\n\n\tthis.CLC = function() {\n\t\tthis.opcodeType = 'CLC';\n\t\tthis.pc++;\n\t\tthis.unsetFlag('carry');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.SEC = function() {\n\t\tthis.opcodeType = 'SEC';\n\t\tthis.pc++;\n\t\tthis.setFlag('carry');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.CLI = function() {\n\t\tthis.opcodeType = 'CLI';\n\t\tthis.pc++;\n\t\tthis.unsetFlag('irqDisable');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.SEI = function() {\n\t\tthis.opcodeType = 'SEI';\n\t\tthis.pc++;\n\t\tthis.setFlag('irqDisable');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.CLV = function() {\n\t\tthis.opcodeType = 'CLV';\n\t\tthis.pc++;\n\t\tthis.unsetFlag('overflow');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.CLD = function() {\n\t\tthis.opcodeType = 'CLD';\n\t\tthis.pc++;\n\t\tthis.unsetFlag('decimal');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.SED = function() {\n\t\tthis.opcodeType = 'SED';\n\t\tthis.pc++;\n\t\tthis.setFlag('decimal');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\t//JMP Instructions\n\n\tthis.JMP_A = function() {\n\t\tthis.opcodeType = 'JMP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.pc = param;\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + param.toString(16).toUpperCase();\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.JMP_I = function() {\n\t\tthis.opcodeType = 'JMP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar lowerByte, higherByte;\n\t\tvar jmpLocation;\n\t\t//var lowNibble = this.nes.MMU.getCpuMemVal(param);\n\t\tif (param1 == 0xFF) {\n\t\t\tlowerByte = param;\n\t\t\thigherByte = param2 | 0x00;\n\t\t}\n\t\telse {\n\t\t\tlowerByte = param;\n\t\t\thigherByte = param2 | (param1 + 1);\n\t\t}\n\t\tjmpLocation = (this.nes.MMU.getCpuMemVal(higherByte) << 8) | this.nes.MMU.getCpuMemVal(lowerByte);\n\t\tthis.pc = jmpLocation;\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\t//JSR Instructions\n\n\tthis.JSR_A = function() {\n\t\tthis.opcodeType = 'JSR';\n\t\tthis.pc++;\n\t\t//get address to jump from params\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t//Transfer next instruction - 1 point to stack\n\t\tthis.pushToStack((this.pc - 1) >> 8);\n\t\tthis.pushToStack((this.pc - 1) & 0x00FF);\n\t\tthis.pc = param;\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + param.toString(16).toUpperCase();\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\t//NOP \n\n\tthis.NOP = function() {\n\t\tif (this.currentOpcode == 0xEA)\n\t\t\tthis.opcodeType = 'NOP';\n\t\telse\n\t\t\tthis.opcodeType = '*NOP';\n\t\tthis.pc++;\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\t//BRK Instructions\n\n\tthis.BRK = function() {\n\t\tthis.opcodeType = 'BRK';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.serveISR('BRK');\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 7;\n\t\t//TODO ??\n\t};\n\n\t//RTI Instructions\n\n\tthis.RTI = function() {\n\t\tthis.opcodeType = 'RTI';\n\t\t// this.P = this.popFromStack();\n\t\tvar temp = this.popFromStack();\n\t\tif ((temp & 0b00000001) == 0x01)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tif ((temp & 0b00000010) >> 1 == 0x01)\n\t\t\tthis.setFlag('zero');\n\t\telse this.unsetFlag('zero');\n\n\t\tif ((temp & 0b00000100) >> 2 == 0x01)\n\t\t\tthis.setFlag('irqDisable');\n\t\telse this.unsetFlag('irqDisable');\n\n\t\tif ((temp & 0b00001000) >> 3 == 0x01)\n\t\t\tthis.setFlag('decimal');\n\t\telse this.unsetFlag('decimal');\n\n\t\tif ((temp & 0b01000000) >> 6 == 0x01)\n\t\t\tthis.setFlag('overflow');\n\t\telse this.unsetFlag('overflow');\n\n\t\tif ((temp & 0b10000000) >> 7 == 0x01)\n\t\t\tthis.setFlag('negative');\n\t\telse this.unsetFlag('negative');\n\n\t\tvar lowByte = this.popFromStack();\n\t\tvar highByte = this.popFromStack();\n\t\tthis.pc = (highByte << 8) | lowByte;\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.RTS = function() {\n\t\tthis.opcodeType = 'RTS';\n\t\tvar lowByte = this.popFromStack();\n\t\tvar highByte = this.popFromStack();\n\t\tthis.pc = ((highByte << 8) | lowByte) + 1;\n\t\t//instLen = 1;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\t//Branch Instructions\n\n\tthis.BPL = function() {\n\t\tthis.opcodeType = 'BPL';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif ((this.P >> 7) == 0) {\n\t\t\t// this.pc--;\n\t\t\t// var offset = this.calcOffset(param);\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++;\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.BMI = function() {\n\t\tthis.opcodeType = 'BMI';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif ((this.P >> 7) == 1) {\n\t\t\t// this.pc--;\n\t\t\t// var offset = this.calcOffset(param);\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++;\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.BVC = function() {\n\t\tthis.opcodeType = 'BVC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif (((this.P >> 6) & 0x01) == 0) {\n\t\t\t// this.pc--;\n\t\t\t// var offset = this.calcOffset(param);\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++;\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.BVS = function() {\n\t\tthis.opcodeType = 'BVS';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif (((this.P >> 6) & 0x01) == 1) {\n\t\t\t// this.pc--;\n\t\t\t// var offset = this.calcOffset(param);\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++;\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.BCC = function() {\n\t\tthis.opcodeType = 'BCC';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif ((this.P & 0x01) == 0) {\n\t\t\t// this.pc--;\n\t\t\t// var offset = this.calcOffset(param);\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++;\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.BCS = function() {\n\t\tthis.opcodeType = 'BCS';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif ((this.P & 0x01) == 1) {\n\t\t\t// this.pc--;\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++; //Incrementing as branch is taken\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.BNE = function() {\n\t\tthis.opcodeType = 'BNE';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif (((this.P >> 1) & 0x01) == 0) {\n\t\t\t// this.pc--;\n\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++;\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.BEQ = function() {\n\t\tthis.opcodeType = 'BEQ';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar offset = this.calcOffset(param);\n\t\tif (this.loggingEnabled)\n\t\t\tthis.memLog = '$' + (this.pc + offset).toString(16).toUpperCase();\n\t\tif (((this.P >> 1) & 0x01) == 1) {\n\t\t\t// this.pc--;\n\t\t\t// var offset = this.calcOffset(param);\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.elapsedCycles++; //Incrementing as page boundary crossing occured\n\t\t\tthis.pc += offset;\n\t\t\tthis.elapsedCycles++;\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\t//CPX Instructions\n\n\tthis.CPX_I = function() {\n\t\tthis.opcodeType = 'CPX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar result = this.compareValsAndSetNegative(this.X, param);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.CPX_Z = function() {\n\t\tthis.opcodeType = 'CPX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar result = this.compareValsAndSetNegative(this.X, this.nes.MMU.getCpuMemVal(param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t//instLen = 2;\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.CPX_A = function() {\n\t\tthis.opcodeType = 'CPX';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.X, this.nes.MMU.getCpuMemVal(param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\t//CPY Instructions\n\n\tthis.CPY_I = function() {\n\t\tthis.opcodeType = 'CPY';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar result = this.compareValsAndSetNegative(this.Y, param);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t//instLen = 2;\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.CPY_Z = function() {\n\t\tthis.opcodeType = 'CPY';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar result = this.compareValsAndSetNegative(this.Y, this.nes.MMU.getCpuMemVal(param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.CPY_A = function() {\n\t\tthis.opcodeType = 'CPY';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.Y, this.nes.MMU.getCpuMemVal(param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\t//CMP Instructions\n\n\tthis.CMP_I = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, param);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.CMP_Z = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.getCpuMemVal(param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.CMP_Z_X = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.CMP_A = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.getCpuMemVal(param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(param);\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.CMP_A_X = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.getCpuMemVal(param + this.X));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t//instLen = 2;\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.CMP_A_Y = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.getCpuMemVal(param + this.Y));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t//instLen = 2;\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.CMP_I_X = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\t// param = index2 | index1;\n\t\tvar memLogBeforeVar = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, memLogBeforeVar);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// this.memLog = '($' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ',X) @ ' + ('00' + (this.wrap8bit('sum', param, this.X)).toString(16).toUpperCase()).slice(-2) + ' = ' + ('0000' + (index2 | index1).toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + memLogBeforeVar.toString(16).toUpperCase()).slice(-2);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.CMP_I_Y = function() {\n\t\tthis.opcodeType = 'CMP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.getCpuMemVal(param + this.Y));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t//instLen = 2;\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\t//BIT Instructions\n\n\tthis.BIT_Z = function() {\n\t\tthis.opcodeType = 'BIT';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param);\n\t\tvar result = this.accumulator & temp;\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('zero');\n\t\t}\n\t\telse\n\t\t\tthis.unsetFlag('zero');\n\n\t\tif ((0b10000000 & temp) == 128) {\n\t\t\tthis.setFlag('negative');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('negative');\n\t\t}\n\t\tif ((0b01000000 & temp) == 64) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\t// this.memLog = '$' + ('00' + param.toString(16).toUpperCase()).slice(-2) + ' = ' + ('00' + temp.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\n\tthis.BIT_A = function() {\n\t\tthis.opcodeType = 'BIT';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param);\n\t\tvar result = this.accumulator & temp;\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('zero');\n\t\t}\n\t\telse\n\t\t\tthis.unsetFlag('zero');\n\n\t\tif ((0b10000000 & temp) == 128) {\n\t\t\tthis.setFlag('negative');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('negative');\n\t\t}\n\t\tif ((0b01000000 & temp) == 64) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag('overflow');\n\t\t}\n\t\t// this.memLog = '$' + ('0000' + param.toString(16).toUpperCase()).slice(-4) + ' = ' + ('00' + temp.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\n\t//Unofficial OPcodes\n\tthis.DOP_Z = function() {\n\t\tthis.opcodeType = '*NOP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.DOP_Z_X = function() {\n\t\tthis.opcodeType = '*NOP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.DOP_I = function() {\n\t\tthis.opcodeType = '*NOP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// this.memLog = '#$' + ('00' + param.toString(16).toUpperCase()).slice(-2);\n\t\tthis.elapsedCycles += 2;\n\t};\n\n\tthis.TOP_A = function() {\n\t\tthis.opcodeType = '*NOP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tthis.elapsedCycles = 4;\n\n\t};\n\n\tthis.TOP_A_X = function() {\n\t\tthis.opcodeType = '*NOP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tif ((param1 + this.X) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LAX_Z = function() {\n\t\tthis.opcodeType = '*LAX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.X = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\n\tthis.LAX_Z_Y = function() {\n\t\tthis.opcodeType = '*LAX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.Y));\n\t\tthis.X = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.Y));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LAX_A = function() {\n\t\tthis.opcodeType = '*LAX';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.X = this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.LAX_A_Y = function() {\n\t\tthis.opcodeType = '*LAX';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// this.X = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.Y));\n\t\tthis.X = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tif ((param1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 5;\n\t\telse\n\t\t\tthis.elapsedCycles += 4;\n\n\t};\n\tthis.LAX_I_X = function() {\n\t\tthis.opcodeType = '*LAX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tthis.X = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.LAX_I_Y = function() {\n\t\tthis.opcodeType = '*LAX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\tthis.X = this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\t// this.accumulator = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', (index2 | index1), this.Y));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tif ((index1 + this.Y) > 0xFF)\n\t\t\tthis.elapsedCycles += 6;\n\t\telse\n\t\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.SAX_Z = function() {\n\t\tthis.opcodeType = '*SAX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.accumulator & this.X));\n\t\t// this.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 3;\n\t};\n\tthis.SAX_Z_Y = function() {\n\t\tthis.opcodeType = '*SAX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal(this.wrap8bit('sum', param, this.Y), (this.accumulator & this.X));\n\t\t// this.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.SAX_I_X = function() {\n\t\tthis.opcodeType = '*SAX';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.nes.MMU.setCpuMemVal((index2 | index1), (this.accumulator & this.X));\n\t\t// this.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\tthis.SAX_A = function() {\n\t\tthis.opcodeType = '*SAX';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.accumulator & this.X));\n\t\t// this.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 4;\n\t};\n\n\tthis.DCP_Z = function() {\n\t\tthis.opcodeType = '*DCP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param), null)));\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, temp);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// if (temp == 0)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\t\t// if (temp == 0x00)\n\t\t// \tthis.setFlag('zero');\n\t\t// else\n\t\t// \tthis.unsetFlag('zero');\n\t\t// if ((temp >> 7) == 1)\n\t\t// \tthis.setFlag('negative');\n\t\t// else\n\t\t// \tthis.unsetFlag('negative');\n\t\t// temp = this.wrap8bit('decrement', temp, null);\n\t\t// this.nes.MMU.setCpuMemVal(param, temp);\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.DCP_Z_X = function() {\n\t\tthis.opcodeType = '*DCP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams(param);\n\t\tthis.nes.MMU.setCpuMemVal(this.wrap8bit('sum', param, this.X), (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), null)));\n\t\tvar temp = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, temp);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// var temp = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\t// if (temp == 0)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\t\t// if (temp == 0x00)\n\t\t// \tthis.setFlag('zero');\n\t\t// else\n\t\t// \tthis.unsetFlag('zero');\n\t\t// if ((temp >> 7) == 1)\n\t\t// \tthis.setFlag('negative');\n\t\t// else\n\t\t// \tthis.unsetFlag('negative');\n\t\t// temp = this.wrap8bit('decrement', temp, null);\n\t\t// this.nes.MMU.setCpuMemVal(this.wrap8bit('sum', param, this.X), temp);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.DCP_A = function() {\n\t\tthis.opcodeType = '*DCP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param), null)));\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, temp);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// if (temp == 0)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\t\t// if (temp == 0x00)\n\t\t// \tthis.setFlag('zero');\n\t\t// else\n\t\t// \tthis.unsetFlag('zero');\n\t\t// if ((temp >> 7) == 1)\n\t\t// \tthis.setFlag('negative');\n\t\t// else\n\t\t// \tthis.unsetFlag('negative');\n\t\t// temp = this.wrap8bit('decrement', temp, null);\n\t\t// this.nes.MMU.setCpuMemVal(param, temp);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.DCP_A_X = function() {\n\t\tthis.opcodeType = '*DCP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// var temp = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.nes.MMU.setCpuMemVal(param + this.X, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param + this.X), null)));\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, temp);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// if (temp == 0)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\t\t// if (temp == 0x00)\n\t\t// \tthis.setFlag('zero');\n\t\t// else\n\t\t// \tthis.unsetFlag('zero');\n\t\t// if ((temp >> 7) == 1)\n\t\t// \tthis.setFlag('negative');\n\t\t// else\n\t\t// \tthis.unsetFlag('negative');\n\t\t// temp = this.wrap8bit('decrement', temp, null);\n\t\t// this.nes.MMU.setCpuMemVal(param + this.X, temp);\n\t\tthis.elapsedCycles += 7;\n\t};\n\tthis.DCP_A_Y = function() {\n\t\tthis.opcodeType = '*DCP';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t// var temp = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.nes.MMU.setCpuMemVal(param + this.Y, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param + this.Y), null)));\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, temp);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// if (temp == 0)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\t\t// if (temp == 0x00)\n\t\t// \tthis.setFlag('zero');\n\t\t// else\n\t\t// \tthis.unsetFlag('zero');\n\t\t// if ((temp >> 7) == 1)\n\t\t// \tthis.setFlag('negative');\n\t\t// else\n\t\t// \tthis.unsetFlag('negative');\n\t\t// temp = this.wrap8bit('decrement', temp, null);\n\t\t// this.nes.MMU.setCpuMemVal(param + this.Y, temp);\n\t\tthis.elapsedCycles += 7;\n\t};\n\tthis.DCP_I_X = function() {\n\t\tthis.opcodeType = '*DCP';\n\t\tthis.pc++;\n\t\t// var param = this.fetchParams();\n\t\t// var index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\t// var index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\t// index2 = index2 << 8;\n\t\t// var temp = this.nes.MMU.getCpuMemVal(index2 | index1);\n\t\t// if (temp == 0)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\t\t// if (temp == 0x00)\n\t\t// \tthis.setFlag('zero');\n\t\t// else\n\t\t// \tthis.unsetFlag('zero');\n\t\t// if ((temp >> 7) == 1)\n\t\t// \tthis.setFlag('negative');\n\t\t// else\n\t\t// \tthis.unsetFlag('negative');\n\t\t// temp = this.wrap8bit('decrement', temp, null);\n\t\t// this.nes.MMU.setCpuMemVal(index2 | index1, temp);\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param), null)));\n\t\t// this.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, temp);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tthis.elapsedCycles += 8;\n\t};\n\tthis.DCP_I_Y = function() {\n\t\tthis.opcodeType = '*DCP';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\t// var temp = this.nes.MMU.getCpuMemVal((index2 | index1) + this.Y);\n\t\tthis.nes.MMU.setCpuMemVal(param + this.Y, (this.wrap8bit('decrement', this.nes.MMU.getCpuMemVal(param + this.Y), null)));\n\t\tvar temp = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, temp);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\t// this.unsetFlag('negative');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag('carry');\n\t\t\tthis.setFlag('zero');\n\t\t\t// this.unsetFlag('negative');\n\t\t}\n\t\tif (result < 0) {\n\t\t\t// this.setFlag('negative');\n\t\t\tthis.unsetFlag('carry');\n\t\t\tthis.unsetFlag('zero');\n\t\t}\n\t\t// if (temp == 0)\n\t\t// \tthis.setFlag('carry');\n\t\t// else this.unsetFlag('carry');\n\t\t// if (temp == 0x00)\n\t\t// \tthis.setFlag('zero');\n\t\t// else\n\t\t// \tthis.unsetFlag('zero');\n\t\t// if ((temp >> 7) == 1)\n\t\t// \tthis.setFlag('negative');\n\t\t// else\n\t\t// \tthis.unsetFlag('negative');\n\t\t// temp = this.wrap8bit('decrement', temp, null);\n\t\t// this.nes.MMU.setCpuMemVal((index2 | index1) + this.Y, temp);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.ISB_Z = function() {\n\t\tthis.opcodeType = '*ISB';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param), null)));\n\t\t// this.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\t// arg = ~arg;\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\tif ((this.P & 0x01) == 0x00)\n\t\t\ttemp = temp - 1;\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\n\t\tif (this.accumulator >= arg)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tthis.accumulator = this.toSigned8bit(temp);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.ISB_Z_X = function() {\n\t\tthis.opcodeType = '*ISB';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)), null)));\n\t\t// this.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\tvar arg = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\tif ((this.P & 0x01) == 0x00)\n\t\t\ttemp = temp - 1;\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\n\t\tif (this.accumulator >= arg)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tthis.accumulator = this.toSigned8bit(temp);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ISB_A = function() {\n\t\tthis.opcodeType = '*ISB';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param), null)));\n\t\t// this.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\t// arg = ~arg;\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\tif ((this.P & 0x01) == 0x00)\n\t\t\ttemp = temp - 1;\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\n\t\tif (this.accumulator >= arg)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tthis.accumulator = this.toSigned8bit(temp);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.ISB_A_X = function() {\n\t\tthis.opcodeType = '*ISB';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param + this.X), null)));\n\t\t// this.calcFlags(this.nes.MMU.getCpuMemVal(param + this.X), false, null);\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\t// arg = ~arg;\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\tif ((this.P & 0x01) == 0x00)\n\t\t\ttemp = temp - 1;\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\n\t\tif (this.accumulator >= arg)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tthis.accumulator = this.toSigned8bit(temp);\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 3;\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\tthis.ISB_A_Y = function() {\n\t\tthis.opcodeType = '*ISB';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param + this.Y), null)));\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\t// arg = ~arg;\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\tif ((this.P & 0x01) == 0x00)\n\t\t\ttemp = temp - 1;\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\n\t\tif (this.accumulator >= arg)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tthis.accumulator = this.toSigned8bit(temp);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\tthis.ISB_I_X = function() {\n\t\tthis.opcodeType = '*ISB';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tthis.nes.MMU.setCpuMemVal((param), (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param), null)));\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\t// arg = ~arg;\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\tif ((this.P & 0x01) == 0x00)\n\t\t\ttemp = temp - 1;\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\n\t\tif (this.accumulator >= arg)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tthis.accumulator = this.toSigned8bit(temp);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\tthis.ISB_I_Y = function() {\n\t\tthis.opcodeType = '*ISB';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.Y;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.wrap8bit('increment', this.nes.MMU.getCpuMemVal(param + this.Y), null)));\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\t// arg = ~arg;\n\t\t// var temp = this.accumulator + arg + (this.P & 0x01);\n\t\t// temp = this.writeCarry(temp);\n\t\t// this.calcFlags(arg, true, temp);\n\t\t// this.accumulator = temp;\n\t\t// this.calcFlags(null, false, null);\n\t\tvar temp = this.to2sComplement(this.accumulator) - this.to2sComplement(arg);\n\t\tif ((this.P & 0x01) == 0x00)\n\t\t\ttemp = temp - 1;\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\n\t\tif (this.accumulator >= arg)\n\t\t\tthis.setFlag('carry');\n\t\telse this.unsetFlag('carry');\n\n\t\tthis.accumulator = this.toSigned8bit(temp);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.SLO_Z = function() {\n\t\tthis.opcodeType = '*SLO';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, this.nes.MMU.getCpuMemVal(param) << 1);\n\t\t// this.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.SLO_Z_X = function() {\n\t\tthis.opcodeType = '*SLO';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) << 1));\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\tthis.SLO_A = function() {\n\t\tthis.opcodeType = '*SLO';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\tthis.SLO_A_X = function() {\n\t\tthis.opcodeType = '*SLO';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) << 1));\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\tthis.SLO_A_Y = function() {\n\t\tthis.opcodeType = '*SLO';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) << 1));\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\tthis.SLO_I_X = function() {\n\t\tthis.opcodeType = '*SLO';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param), (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\tthis.SLO_I_Y = function() {\n\t\tthis.opcodeType = '*SLO';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.Y;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) << 1));\n\t\tthis.accumulator = this.accumulator | this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.RLA_Z = function() {\n\t\tthis.opcodeType = '*RLA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b00000001));\n\t\t}\n\t\t// this.calcFlags(this.nes.MMU.getCpuMemVal(param), false, null);\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.RLA_Z_X = function() {\n\t\tthis.opcodeType = '*RLA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) | 0b00000001));\n\t\t}\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.RLA_A = function() {\n\t\tthis.opcodeType = '*RLA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b00000001));\n\t\t}\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.RLA_A_X = function() {\n\t\tthis.opcodeType = '*RLA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) | 0b00000001));\n\t\t}\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\tthis.RLA_A_Y = function() {\n\t\tthis.opcodeType = '*RLA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) | 0b00000001));\n\t\t}\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\tthis.RLA_I_X = function() {\n\t\tthis.opcodeType = '*RLA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param), (this.nes.MMU.getCpuMemVal(param) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param), (this.nes.MMU.getCpuMemVal(param) | 0b00000001));\n\t\t}\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.RLA_I_Y = function() {\n\t\tthis.opcodeType = '*RLA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) >> 7) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) << 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) | 0b00000001));\n\t\t}\n\t\tthis.accumulator = this.accumulator & this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.SRE_Z = function() {\n\t\tthis.opcodeType = '*SRE';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.SRE_Z_X = function() {\n\t\tthis.opcodeType = '*SRE';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 1));\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.SRE_A = function() {\n\t\tthis.opcodeType = '*SRE';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.SRE_A_X = function() {\n\t\tthis.opcodeType = '*SRE';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) >> 1));\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\tthis.SRE_A_Y = function() {\n\t\tthis.opcodeType = '*SRE';\n\t\tthis.pc++;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) >> 1));\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\tthis.SRE_I_X = function() {\n\t\tthis.opcodeType = '*SRE';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param), (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.SRE_I_Y = function() {\n\t\tthis.opcodeType = '*SRE';\n\t\tthis.pc++;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) >> 1));\n\t\tthis.accumulator = this.accumulator ^ this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.RRA_Z = function() {\n\t\tthis.opcodeType = '*RRA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b10000000));\n\t\t}\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 5;\n\t};\n\n\tthis.RRA_Z_X = function() {\n\t\tthis.opcodeType = '*RRA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tif ((this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((this.wrap8bit('sum', param, this.X)), (this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X)) | 0b10000000));\n\t\t}\n\t\tvar arg = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.RRA_A = function() {\n\t\tthis.opcodeType = '*RRA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal(param, (this.nes.MMU.getCpuMemVal(param) | 0b10000000));\n\t\t}\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 6;\n\t};\n\n\tthis.RRA_A_X = function() {\n\t\tthis.opcodeType = '*RRA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.X) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.X), (this.nes.MMU.getCpuMemVal(param + this.X) | 0b10000000));\n\t\t}\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.X);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\tthis.RRA_A_Y = function() {\n\t\tthis.opcodeType = '*RRA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.fetchParams();\n\t\tvar param2 = this.fetchParams();\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) | 0b10000000));\n\t\t}\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 7;\n\t};\n\n\tthis.RRA_I_X = function() {\n\t\tthis.opcodeType = '*RRA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\t// param += this.X;\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param), (this.nes.MMU.getCpuMemVal(param) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param), (this.nes.MMU.getCpuMemVal(param) | 0b10000000));\n\t\t}\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\t//instLen = 2;\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\tthis.RRA_I_Y = function() {\n\t\tthis.opcodeType = '*RRA';\n\t\tthis.pc++;\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.fetchParams();\n\t\tvar index1 = this.nes.MMU.getCpuMemVal(param);\n\t\tvar index2 = this.nes.MMU.getCpuMemVal(this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tif ((this.nes.MMU.getCpuMemVal(param + this.Y) & 0x01) == 1)\n\t\t\tthis.setFlag('carry');\n\t\telse\n\t\t\tthis.unsetFlag('carry');\n\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) >> 1));\n\t\tif (currCarry == 1) {\n\t\t\tthis.nes.MMU.setCpuMemVal((param + this.Y), (this.nes.MMU.getCpuMemVal(param + this.Y) | 0b10000000));\n\t\t}\n\t\tvar arg = this.nes.MMU.getCpuMemVal(param + this.Y);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag('overflow');\n\t\t}\n\t\telse this.unsetFlag('overflow');\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.elapsedCycles += 8;\n\t};\n\n\t//Decode fetched instructions \n\tthis.decodeInstruction = function() {\n\t\t// this.prepareLogging();\n\t\tswitch (this.currentOpcode) {\n\t\t\t//ADC Instructions\n\t\t\tcase 0x69:\n\t\t\t\tthis.ADC_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x65:\n\t\t\t\tthis.ADC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x75:\n\t\t\t\tthis.ADC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x6D:\n\t\t\t\tthis.ADC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x7D:\n\t\t\t\tthis.ADC_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x79:\n\t\t\t\tthis.ADC_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x61:\n\t\t\t\tthis.ADC_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x71:\n\t\t\t\tthis.ADC_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//AND Instructions\n\t\t\tcase 0x29:\n\t\t\t\tthis.AND_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x25:\n\t\t\t\tthis.AND_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x35:\n\t\t\t\tthis.AND_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x2D:\n\t\t\t\tthis.AND_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x3D:\n\t\t\t\tthis.AND_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x39:\n\t\t\t\tthis.AND_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x21:\n\t\t\t\tthis.AND_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x31:\n\t\t\t\tthis.AND_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//ASL Instructions\n\t\t\tcase 0x0A:\n\t\t\t\tthis.ASL_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tthis.ASL_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x16:\n\t\t\t\tthis.ASL_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0E:\n\t\t\t\tthis.ASL_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1E:\n\t\t\t\tthis.ASL_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//BIT Instructions\n\t\t\tcase 0x24:\n\t\t\t\tthis.BIT_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x2C:\n\t\t\t\tthis.BIT_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//Branch Instructions\n\t\t\tcase 0x10:\n\t\t\t\tthis.BPL();\n\t\t\t\tbreak;\n\t\t\tcase 0x30:\n\t\t\t\tthis.BMI();\n\t\t\t\tbreak;\n\t\t\tcase 0x50:\n\t\t\t\tthis.BVC();\n\t\t\t\tbreak;\n\t\t\tcase 0x70:\n\t\t\t\tthis.BVS();\n\t\t\t\tbreak;\n\t\t\tcase 0x90:\n\t\t\t\tthis.BCC();\n\t\t\t\tbreak;\n\t\t\tcase 0xB0:\n\t\t\t\tthis.BCS();\n\t\t\t\tbreak;\n\t\t\tcase 0xD0:\n\t\t\t\tthis.BNE();\n\t\t\t\tbreak;\n\t\t\tcase 0xF0:\n\t\t\t\tthis.BEQ();\n\t\t\t\tbreak;\n\n\t\t\t\t//BRK Instructions\n\t\t\tcase 0x00:\n\t\t\t\tthis.BRK();\n\t\t\t\tbreak;\n\n\t\t\t\t//CMP Instructions\n\t\t\tcase 0xC9:\n\t\t\t\tthis.CMP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC5:\n\t\t\t\tthis.CMP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xD5:\n\t\t\t\tthis.CMP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xCD:\n\t\t\t\tthis.CMP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xDD:\n\t\t\t\tthis.CMP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xD9:\n\t\t\t\tthis.CMP_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xC1:\n\t\t\t\tthis.CMP_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xD1:\n\t\t\t\tthis.CMP_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//CPX Instructions\n\t\t\tcase 0xE0:\n\t\t\t\tthis.CPX_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xE4:\n\t\t\t\tthis.CPX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xEC:\n\t\t\t\tthis.CPX_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//CPY Instructions\n\t\t\tcase 0xC0:\n\t\t\t\tthis.CPY_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC4:\n\t\t\t\tthis.CPY_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xCC:\n\t\t\t\tthis.CPY_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//DEC Instructions\n\t\t\tcase 0xC6:\n\t\t\t\tthis.DEC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xD6:\n\t\t\t\tthis.DEC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xCE:\n\t\t\t\tthis.DEC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xDE:\n\t\t\t\tthis.DEC_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//EOR Instructions\n\t\t\tcase 0x49:\n\t\t\t\tthis.EOR_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x45:\n\t\t\t\tthis.EOR_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x55:\n\t\t\t\tthis.EOR_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x4D:\n\t\t\t\tthis.EOR_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x5D:\n\t\t\t\tthis.EOR_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x59:\n\t\t\t\tthis.EOR_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x41:\n\t\t\t\tthis.EOR_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x51:\n\t\t\t\tthis.EOR_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//Flag Instructions\n\t\t\tcase 0x18:\n\t\t\t\tthis.CLC();\n\t\t\t\tbreak;\n\t\t\tcase 0x38:\n\t\t\t\tthis.SEC();\n\t\t\t\tbreak;\n\t\t\tcase 0x58:\n\t\t\t\tthis.CLI();\n\t\t\t\tbreak;\n\t\t\tcase 0x78:\n\t\t\t\tthis.SEI();\n\t\t\t\tbreak;\n\t\t\tcase 0xB8:\n\t\t\t\tthis.CLV();\n\t\t\t\tbreak;\n\t\t\tcase 0xD8:\n\t\t\t\tthis.CLD();\n\t\t\t\tbreak;\n\t\t\tcase 0xF8:\n\t\t\t\tthis.SED();\n\t\t\t\tbreak;\n\n\t\t\t\t//INC Instructions\n\t\t\tcase 0xE6:\n\t\t\t\tthis.INC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xF6:\n\t\t\t\tthis.INC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xEE:\n\t\t\t\tthis.INC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xFE:\n\t\t\t\tthis.INC_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//JMP Instructions\n\t\t\tcase 0x4C:\n\t\t\t\tthis.JMP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x6C:\n\t\t\t\tthis.JMP_I();\n\t\t\t\tbreak;\n\n\t\t\t\t//JSR Instructions\n\t\t\tcase 0x20:\n\t\t\t\tthis.JSR_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//LDA Instuctions\n\t\t\tcase 0xA9:\n\t\t\t\tthis.LDA_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xA5:\n\t\t\t\tthis.LDA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB5:\n\t\t\t\tthis.LDA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xAD:\n\t\t\t\tthis.LDA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBD:\n\t\t\t\tthis.LDA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xB9:\n\t\t\t\tthis.LDA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xA1:\n\t\t\t\tthis.LDA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xB1:\n\t\t\t\tthis.LDA_I_Y();\n\t\t\t\tbreak;\n\n\n\t\t\t\t//LDX Instructions\n\t\t\tcase 0xA2:\n\t\t\t\tthis.LDX_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xA6:\n\t\t\t\tthis.LDX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB6:\n\t\t\t\tthis.LDX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xAE:\n\t\t\t\tthis.LDX_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBE:\n\t\t\t\tthis.LDX_A_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//LDY Instructions\n\t\t\tcase 0xA0:\n\t\t\t\tthis.LDY_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xA4:\n\t\t\t\tthis.LDY_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB4:\n\t\t\t\tthis.LDY_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xAC:\n\t\t\t\tthis.LDY_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBC:\n\t\t\t\tthis.LDY_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//LSR Instructions\n\t\t\tcase 0x4A:\n\t\t\t\tthis.LSR_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\n\t\t\t\tthis.LSR_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x56:\n\t\t\t\tthis.LSR_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x4E:\n\t\t\t\tthis.LSR_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x5E:\n\t\t\t\tthis.LSR_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//NOP\n\t\t\tcase 0xEA:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\n\t\t\t\t//ORA Instructions\n\t\t\tcase 0x09:\n\t\t\t\tthis.ORA_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tthis.ORA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x15:\n\t\t\t\tthis.ORA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0D:\n\t\t\t\tthis.ORA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1D:\n\t\t\t\tthis.ORA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x19:\n\t\t\t\tthis.ORA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tthis.ORA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x11:\n\t\t\t\tthis.ORA_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//Register Instructions\n\t\t\tcase 0xAA:\n\t\t\t\tthis.TAX();\n\t\t\t\tbreak;\n\t\t\tcase 0x8A:\n\t\t\t\tthis.TXA();\n\t\t\t\tbreak;\n\t\t\tcase 0xCA:\n\t\t\t\tthis.DEX();\n\t\t\t\tbreak;\n\t\t\tcase 0xE8:\n\t\t\t\tthis.INX();\n\t\t\t\tbreak;\n\t\t\tcase 0xA8:\n\t\t\t\tthis.TAY();\n\t\t\t\tbreak;\n\t\t\tcase 0x98:\n\t\t\t\tthis.TYA();\n\t\t\t\tbreak;\n\t\t\tcase 0x88:\n\t\t\t\tthis.DEY();\n\t\t\t\tbreak;\n\t\t\tcase 0xC8:\n\t\t\t\tthis.INY();\n\t\t\t\tbreak;\n\n\t\t\t\t//ROL Instructions\n\t\t\tcase 0x2A:\n\t\t\t\tthis.ROL_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x26:\n\t\t\t\tthis.ROL_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x36:\n\t\t\t\tthis.ROL_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x2E:\n\t\t\t\tthis.ROL_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x3E:\n\t\t\t\tthis.ROL_A_X();\n\t\t\t\tbreak;\n\n\n\t\t\t\t//ROR Instructions\n\t\t\tcase 0x6A:\n\t\t\t\tthis.ROR_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x66:\n\t\t\t\tthis.ROR_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x76:\n\t\t\t\tthis.ROR_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x6E:\n\t\t\t\tthis.ROR_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x7E:\n\t\t\t\tthis.ROR_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//RTI Instructions\n\t\t\tcase 0x40:\n\t\t\t\tthis.RTI();\n\t\t\t\tbreak;\n\n\t\t\t\t//RTS Instructions\n\t\t\tcase 0x60:\n\t\t\t\tthis.RTS();\n\t\t\t\tbreak;\n\n\t\t\t\t//SBC Instructions\n\t\t\tcase 0xE9:\n\t\t\t\tthis.SBC_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xE5:\n\t\t\t\tthis.SBC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xF5:\n\t\t\t\tthis.SBC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xED:\n\t\t\t\tthis.SBC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xFD:\n\t\t\t\tthis.SBC_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xF9:\n\t\t\t\tthis.SBC_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xE1:\n\t\t\t\tthis.SBC_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xF1:\n\t\t\t\tthis.SBC_I_Y();\n\t\t\t\tbreak;\n\n\n\t\t\t\t//STA Instructions\n\t\t\tcase 0x85:\n\t\t\t\tthis.STA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x95:\n\t\t\t\tthis.STA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x8D:\n\t\t\t\tthis.STA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x9D:\n\t\t\t\tthis.STA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x99:\n\t\t\t\tthis.STA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x81:\n\t\t\t\tthis.STA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x91:\n\t\t\t\tthis.STA_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//Stack Instructions\n\t\t\tcase 0x9A:\n\t\t\t\tthis.TXS();\n\t\t\t\tbreak;\n\t\t\tcase 0xBA:\n\t\t\t\tthis.TSX();\n\t\t\t\tbreak;\n\t\t\tcase 0x48:\n\t\t\t\tthis.PHA();\n\t\t\t\tbreak;\n\t\t\tcase 0x68:\n\t\t\t\tthis.PLA();\n\t\t\t\tbreak;\n\t\t\tcase 0x08:\n\t\t\t\tthis.PHP();\n\t\t\t\tbreak;\n\t\t\tcase 0x28:\n\t\t\t\tthis.PLP();\n\t\t\t\tbreak;\n\n\t\t\t\t//STX Instructions\n\t\t\tcase 0x86:\n\t\t\t\tthis.STX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x96:\n\t\t\t\tthis.STX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x8E:\n\t\t\t\tthis.STX_A();\n\t\t\t\tbreak;\n\n\n\t\t\t\t//STY Instructions\n\t\t\tcase 0x84:\n\t\t\t\tthis.STY_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x94:\n\t\t\t\tthis.STY_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x8C:\n\t\t\t\tthis.STY_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//Unofficial opcodes\n\t\t\t\t//http://www.oxyron.de/html/opcodes02.html\n\t\t\tcase 0x04:\n\t\t\t\tthis.DOP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x14:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x34:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x44:\n\t\t\t\tthis.DOP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x54:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x64:\n\t\t\t\tthis.DOP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x74:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x80:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x82:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x89:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC2:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xD4:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xE2:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xF4:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0C:\n\t\t\t\tthis.TOP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x3C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x5C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x7C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xDC:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xFC:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x1A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x3A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x5A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x7A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0xDA:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0xFA:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x0A7:\n\t\t\t\tthis.LAX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB7:\n\t\t\t\tthis.LAX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xAF:\n\t\t\t\tthis.LAX_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBF:\n\t\t\t\tthis.LAX_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xA3:\n\t\t\t\tthis.LAX_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xB3:\n\t\t\t\tthis.LAX_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x87:\n\t\t\t\tthis.SAX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x97:\n\t\t\t\tthis.SAX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x83:\n\t\t\t\tthis.SAX_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x8F:\n\t\t\t\tthis.SAX_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xEB:\n\t\t\t\tthis.SBC_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC7:\n\t\t\t\tthis.DCP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xD7:\n\t\t\t\tthis.DCP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xCF:\n\t\t\t\tthis.DCP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xDF:\n\t\t\t\tthis.DCP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xDB:\n\t\t\t\tthis.DCP_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xC3:\n\t\t\t\tthis.DCP_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xD3:\n\t\t\t\tthis.DCP_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xE7:\n\t\t\t\tthis.ISB_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xF7:\n\t\t\t\tthis.ISB_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xEF:\n\t\t\t\tthis.ISB_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tthis.ISB_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xFB:\n\t\t\t\tthis.ISB_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xE3:\n\t\t\t\tthis.ISB_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xF3:\n\t\t\t\tthis.ISB_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x07:\n\t\t\t\tthis.SLO_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x17:\n\t\t\t\tthis.SLO_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0F:\n\t\t\t\tthis.SLO_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1F:\n\t\t\t\tthis.SLO_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x1B:\n\t\t\t\tthis.SLO_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tthis.SLO_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x13:\n\t\t\t\tthis.SLO_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x27:\n\t\t\t\tthis.RLA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x37:\n\t\t\t\tthis.RLA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x2F:\n\t\t\t\tthis.RLA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x3F:\n\t\t\t\tthis.RLA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x3B:\n\t\t\t\tthis.RLA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x23:\n\t\t\t\tthis.RLA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x33:\n\t\t\t\tthis.RLA_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x47:\n\t\t\t\tthis.SRE_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x57:\n\t\t\t\tthis.SRE_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x4F:\n\t\t\t\tthis.SRE_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x5F:\n\t\t\t\tthis.SRE_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x5B:\n\t\t\t\tthis.SRE_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x43:\n\t\t\t\tthis.SRE_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x53:\n\t\t\t\tthis.SRE_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x67:\n\t\t\t\tthis.RRA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x77:\n\t\t\t\tthis.RRA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x6F:\n\t\t\t\tthis.RRA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x7F:\n\t\t\t\tthis.RRA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x7B:\n\t\t\t\tthis.RRA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x63:\n\t\t\t\tthis.RRA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x73:\n\t\t\t\tthis.RRA_I_Y();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.log(\"Unknown opcode: \" + this.currentOpcode.toString('16'));\n\t\t\t\tthis.errorFlag = true;\n\t\t\t\tthis.pc++;\n\t\t\t\tbreak;\n\t\t}\n\t\t// return this.opcodeLog;\n\t};\n\n\tthis.serveISR = function(interrupt) {\n\t\tswitch (interrupt) {\n\t\t\tcase 'NMI':\n\t\t\t\tvar vector1 = this.nes.MMU.getCpuMemVal(0xFFFA);\n\t\t\t\tvar vector2 = this.nes.MMU.getCpuMemVal(0xFFFA + 1);\n\t\t\t\tvector2 = vector2 << 8;\n\t\t\t\t//push pc to stack\n\t\t\t\t// this.pushToStack(this.pc);\n\t\t\t\tthis.pushToStack((this.pc & 0xFF00) >> 8); //push high byte\n\t\t\t\tthis.pushToStack(this.pc & 0x00FF); //push low byte\n\t\t\t\t//push processor status to stack\n\t\t\t\tthis.pushToStack(this.P);\n\t\t\t\tthis.pc = vector2 | vector1;\n\t\t\t\tthis.elapsedCycles += 7;\n\t\t\t\tbreak;\n\t\t\tcase 'BRK':\n\t\t\t\tvar vector1 = this.nes.MMU.getCpuMemVal(0xFFFE);\n\t\t\t\tvar vector2 = this.nes.MMU.getCpuMemVal(0xFFFE + 1);\n\t\t\t\tvector2 = vector2 << 8;\n\t\t\t\t//push pc to stack\n\t\t\t\tthis.pushToStack((this.pc & 0xFF00) >> 8); //push high byte\n\t\t\t\tthis.pushToStack(this.pc & 0x00FF); //push low byte\n\n\t\t\t\t//Set the Break flag \n\t\t\t\tthis.P = this.P & 0b11101111;\n\t\t\t\tthis.P = this.P | 0b00010000;\n\t\t\t\tthis.P = this.P & 0b11011111;\n\t\t\t\tthis.P = this.P | 0b00100000;\n\t\t\t\t//set unused flag\n\t\t\t\t//push processor status to stack\n\t\t\t\tthis.pushToStack(this.P);\n\t\t\t\t//Set the I flag\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tthis.P = this.P | 0b00000100;\n\t\t\t\tthis.pc = vector2 | vector1;\n\t\t\t\tbreak;\n\t\t\tcase 'IRQ':\n\t\t\t\tvar vector1 = this.nes.MMU.getCpuMemVal(0xFFFE);\n\t\t\t\tvar vector2 = this.nes.MMU.getCpuMemVal(0xFFFE + 1);\n\t\t\t\tvector2 = vector2 << 8;\n\t\t\t\t//Clear the BRK flag\n\t\t\t\tthis.P = this.P & 0b11101111;\n\t\t\t\t//push pc to stack\n\t\t\t\tthis.pushToStack((this.pc & 0xFF00) >> 8); //push high byte\n\t\t\t\tthis.pushToStack(this.pc & 0x00FF); //push low byte\n\t\t\t\t//set unused flag\n\t\t\t\tthis.P = this.P & 0b11011111;\n\t\t\t\tthis.P = this.P | 0b00100000;\n\t\t\t\t//push processor status to stack\n\t\t\t\tthis.pushToStack(this.P);\n\t\t\t\t// //Set the Break flag \n\t\t\t\t//Set the I flag\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tthis.P = this.P | 0b00000100;\n\t\t\t\tthis.pc = vector2 | vector1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\t};\n\n\n\tthis.debugCPU = function() {\n\t\tthis.fetchOpcode();\n\t\tthis.decodeInstruction();\n\t\tvar cpuCyclesElapsed = this.elapsedCycles;\n\t\tthis.totalCpuCyclesDbg += cpuCyclesElapsed; //store cpu cycles elapsed for kicking off ppu scanline rendering\n\t\tthis.totalCpuCyclesDbg -= this.excessCpuCyclesDbg; //adjust excess cpu cycles left from last ppu scanline rendering \n\t\tthis.excessCpuCyclesDbg = 0; //resetting the excess cycles as already adjusted\n\t\t//If enough CPU cycles have been consumed for 1 scanline of ppu cycles (340-341), render sprites and backgroud\n\t\tif ((this.totalCpuCyclesDbg * 3) >= this.ppuCyclesCurrentScanLine) {\n\t\t\tthis.renderedScanLine = this.nes.PPU.RenderNextScanline();\n\t\t\t//Check we are on the verge of vBlank\n\t\t\tif (this.renderedScanLine == 241) {\n\t\t\t\t//Generet NMI Interrupt\n\t\t\t\tif (this.nes.MMU.enableNMIGen)\n\t\t\t\t\tthis.serveISR('NMI');\n\t\t\t}\n\t\t\t//Calculating extra cpu cycles run for this scanline\n\t\t\tthis.excessCpuCyclesDbg =this.totalCpuCyclesDbg - this.ppuCyclesCurrentScanLine / 3;\n\t\t\tthis.totalCpuCyclesDbg = 0;\n\t\t\tthis.elapsedCycles = 0;\n\t\t}\n\t\treturn cpuCyclesElapsed;\n\t};\n\n\tthis.runFrame = function() {\n\t\tthis.frameCompleted = false;\n\t\tthis.renderedScanline = -1;\n\t\t//Need to re render CHR for games using CHR RAM\n\t\tif (this.nes.MMU.chrRamWritten) {\n\t\t\tthis.nes.Mapper.reRenderCHR();\n\t\t}\n\t\tthis.totalCPUCyclesThisFrame = 0;\n\t\twhile (!this.frameCompleted) {\n\t\t\tif ((this.P >> 2) & 0x01 == 0x01) { //IRQ is enabled\n\t\t\t\tif (this.nes.APU.doIrq) {\n\t\t\t\t\tthis.serveISR('IRQ');\n\t\t\t\t\tthis.nes.APU.doIrq = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cpuCyclesConsumed = this.elapsedCycles;\n\t\t\tthis.fetchOpcode();\n\t\t\tthis.decodeInstruction();\n\t\t\tthis.cpuCyclesGenerated = this.elapsedCycles - this.cpuCyclesConsumed;\n\t\t\tthis.elapsedCycles += this.excessCpuCycles;\n\t\t\tthis.excessCpuCycles = 0;\n\t\t\tif (this.oddFrame) {\n\t\t\t\tthis.ppuCyclesCurrentScanLine = 340;\n\t\t\t\tif (this.nes.MMU.OAMDMAwritten) {\n\t\t\t\t\tthis.elapsedCycles += 514;\n\t\t\t\t\tthis.nes.MMU.OAMDMAwritten = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.ppuCyclesCurrentScanLine = 341;\n\t\t\t\tif (this.nes.MMU.OAMDMAwritten) {\n\t\t\t\t\tthis.elapsedCycles += 513;\n\t\t\t\t\tthis.nes.MMU.OAMDMAwritten = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cpuCyclesConsumed = this.elapsedCycles - this.cpuCyclesConsumed;\n\t\t\tthis.clockPPU(this.cpuCyclesConsumed);\n\t\t\tthis.clockAPU(this.cpuCyclesGenerated);\n\t\t\tthis.totalCPUCyclesThisFrame += this.cpuCyclesGenerated;\n\t\t}\n\t\t// console.log(\"PPU cycles per frame = \" + this.ppuCyclesThisFrame);\n\t\t// this.ppuCyclesThisFrame = 0;\n\t\t// this.frameCount++;\n\t\t// this.cpuCyclesThisSecond += this.totalCPUCyclesThisFrame;\n\t\t// if (this.frameCount >= 60) {\n\t\t// \tconsole.log(\"Cycles per second: \" + this.cpuCyclesThisSecond);\n\t\t// \tthis.cpuCyclesThisSecond = 0;\n\t\t// \tthis.frameCount = 0;\n\t\t// }\n\t\t// console.log(\"Cpu cycles this frame = \" + this.totalCPUCyclesThisFrame);\n\t\t// this.totalCPUCyclesThisFrame = 0;\n\t\tthis.oddFrame = !this.oddFrame;\n\t};\n\n\tthis.clockPPU = function(cycles) {\n\t\tthis.ppuCyclesConsumed += cycles;\n\t\tif(this.oddFrame && (this.renderedScanline == -1)) {\n\t\t\tthis.ppuCyclesCurrentScanLine = 340;\n\t\t}\n\t\telse {\n\t\t\tthis.ppuCyclesCurrentScanLine = 341;\n\t\t}\n\t\tif ((this.ppuCyclesConsumed * 3) >= this.ppuCyclesCurrentScanLine) {\n\t\t\tthis.renderedScanline = this.nes.PPU.RenderNextScanline(this.nes.MMU.getOAM(), this.nes.MMU.getNameTable(), this.nes.MMU.getAttrTable());\n\t\t\t//Reset OAMADDR, TODO: move this to this.nes.MMU after refactoring\n\t\t\tif (this.renderedScanline == 261 || (this.renderedScanline >= 0 && this.renderedScanline < 240)) {\n\t\t\t\tthis.nes.MMU.setOAMADDR(0);\n\t\t\t}\n\t\t\t//Check we are on the verge of vBlank\n\t\t\tif (this.renderedScanline == 241) {\n\t\t\t\tthis.nmiLoopCounter++;\n\t\t\t\tif (this.nes.MMU.enableNMIGen && this.nes.PPU.NMIOccured) { //Generet NMI Interrupt\n\t\t\t\t\tthis.serveISR('NMI');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.renderedScanline == 261) {\n\t\t\t\tthis.frameCompleted = true;\n\t\t\t}\n\t\t\t//Calculating extra cpu cycles run for this scanline\n\t\t\tthis.excessCpuCycles =this.ppuCyclesConsumed - this.ppuCyclesCurrentScanLine / 3;\n\t\t\t// this.ppuCyclesThisFrame += this.ppuCyclesConsumed;\n\t\t\tthis.ppuCyclesConsumed = 0;\n\t\t}\n\t};\n\t\n\tthis.clockAPU = function(cycles) {\n\t\tthis.nes.APU.run(cycles);\n\t};\n}\n\n\n//# sourceURL=webpack:///./public/js/cpu.js?");

/***/ }),

/***/ "./public/js/display.js":
/*!******************************!*\
  !*** ./public/js/display.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return display; });\nfunction display(canvas) {\n    this.ctx = canvas.getContext('2d');\n    this.canvasImageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);\n    this.data = this.canvasImageData.data;\n\n    //Update the data for the cavases\n    this.updateBuffer = function(screenPixel, pixelColor) {\n        this.data[screenPixel * 4] = 0xFF; //alpha\n        this.data[screenPixel * 4] = (pixelColor >> 16) & 0xFF; //red\n        this.data[screenPixel * 4 + 1] = (pixelColor >> 8) & 0xFF; //green\n        this.data[screenPixel * 4 + 2] = pixelColor & 0xFF; //blue\n    };\n\n    //Update the cavases themselves\n    this.updateCanvas = function() {\n        this.ctx.putImageData(this.canvasImageData, 0, 0);\n    };\n\n    //Reset the cavases\n    this.screenReset = function() {\n        this.ctx.fillStyle = 'Black';\n        this.ctx.fillRect(0, 0, canvas.width, canvas.height);\n    };\n\n    //Initilize the screen buffers for various canvases\n    this.initScreenBuffer = function() {\n        for (var i = 0; i < canvas.width * canvas.height; i++) {\n            var j = i * 4;\n            this.data[j + 3] = 0xFF;\n            this.data[j + 2] = 0x00;\n            this.data[j + 1] = 0x00;\n            this.data[j] = 0x00;\n        }\n        this.ctx.putImageData(this.canvasImageData, 0, 0);\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/display.js?");

/***/ }),

/***/ "./public/js/iNES.js":
/*!***************************!*\
  !*** ./public/js/iNES.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return iNES; });\nfunction iNES(nes) {\n    this.nes = nes;\n    this.headers = []; //hold 16 byte iNES headers\n    this.prgRomUnits;\n    this.chrRomUnits = 1;\n    this.prgRamUnits = 1;\n    this.mirroring;\n    this.batBackedPrg = false;\n    this.trainer = false;\n    this.ignoreMirrorin = false;\n    this.mapperLowBits;\n    this.mapperHighBits;\n    this.vsUnisystem = false;\n    this.nes20format = false;\n    this.tvSystem = 'NTSC';\n    this.cyclesPerScanLine = 341;\n\n    this.parseHeaders = function() {\n        if (this.headers[0] == 0x4E)\n            if (this.headers[1] == 0x45)\n                if (this.headers[2] == 0x53)\n                    if (this.headers[3] == 0x1A)\n                        console.log(\"proper iNES header found\");\n\n        this.prgRomUnits = this.headers[4];\n        this.chrRomUnits = this.headers[5];\n        this.flag6 = this.headers[6];\n        this.flag7 = this.headers[7];\n        if (this.headers[8] != 0)\n            this.prgRamUnits = this.headers[8];\n        this.flag9 = this.headers[9];\n        this.flag10 = this.headers[10];\n\n        //flag 6 bit map\n        // 76543210\n        // ||||||||\n        // |||||||+- Mirroring: 0: horizontal (vertical arrangement) (CIRAM A10 = PPU A11)\n        // |||||||              1: vertical (horizontal arrangement) (CIRAM A10 = PPU A10)\n        // ||||||+-- 1: Cartridge contains battery-backed PRG RAM ($6000-7FFF) or other persistent memory\n        // |||||+--- 1: 512-byte trainer at $7000-$71FF (stored before PRG data)\n        // ||||+---- 1: Ignore mirroring control or above mirroring bit; instead provide four-screen VRAM\n        // ++++----- Lower nybble of mapper number\n        if ((this.flag6 & 0x01) == 1) {\n            this.mirroring = 'vertical';\n        }\n        else\n            this.mirroring = 'horizontal';\n\n        if (((this.flag6 >> 1) & 0x01) == 1) {\n            this.batBackedPrg = true;\n        }\n\n        if (((this.flag6 >> 2) & 0x01) == 1) {\n            this.trainer = true;\n        }\n\n        if (((this.flag6 >> 3) & 0x01) == 1) {\n            this.ignoreMirroring = true;\n        }\n\n        this.mapperLowBits = this.flag6 >> 4;\n\n        //Flag 7 bit map\n        // 76543210\n        // ||||||||\n        // |||||||+- VS Unisystem\n        // ||||||+-- PlayChoice-10 (8KB of Hint Screen data stored after CHR data)\n        // ||||++--- If equal to 2, flags 8-15 are in NES 2.0 format\n        // ++++----- Upper nybble of mapper number\n\n        if ((this.flag7 & 0x01) == 1) {\n            this.vsUnisystem = true;\n        }\n\n        if (((this.flag7 >> 1) & 0x01) == 1) {\n            this.playChoice10 = true;\n        }\n\n        if (((this.flag7 >> 2) & 0x03) == 2) {\n            this.nes20format = true;\n        }\n\n        this.mapperHighBits = this.flag7 >> 4;\n        this.mapperNum = (this.mapperHighBits << 4) | this.mapperLowBits;\n        //Flag 9 bit map\n        // 76543210\n        // ||||||||\n        // |||||||+- TV system (0: NTSC; 1: PAL)\n        // +++++++-- Reserved, set to zero\n        if ((this.flag9 & 0x01) == 1) {\n            this.tvSystem = 'PAL';\n        }\n        else\n            this.tvSystem = 'NTSC';\n\n    };\n\n    this.setFlags = function() {\n\n    };\n\n    this.parseRom = function(romBytes) {\n        for (var i = 0; i < 16; i++) {\n            this.headers.push(romBytes[i]);\n        }\n        this.parseHeaders();\n        this.nes.Mapper.loadRom(romBytes);\n        this.setFlags();\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/iNES.js?");

/***/ }),

/***/ "./public/js/index.js":
/*!****************************!*\
  !*** ./public/js/index.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _iNES__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iNES */ \"./public/js/iNES.js\");\n/* harmony import */ var _mapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapper */ \"./public/js/mapper.js\");\n/* harmony import */ var _ppu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ppu */ \"./public/js/ppu.js\");\n/* harmony import */ var _cpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cpu */ \"./public/js/cpu.js\");\n/* harmony import */ var _mmu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mmu */ \"./public/js/mmu.js\");\n/* harmony import */ var _apu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./apu */ \"./public/js/apu.js\");\n/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./display */ \"./public/js/display.js\");\n\n\n\n\n\n\n\n\nfunction NES() {\n    \n}\nNES.iNES = _iNES__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nNES.mapper = _mapper__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\nNES.ppu = _ppu__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\nNES.cpu = _cpu__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\nNES.mmu = _mmu__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\nNES.apu = _apu__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\nNES.display = _display__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n\nif(window !== undefined)\nwindow.NES = NES;\n\n//# sourceURL=webpack:///./public/js/index.js?");

/***/ }),

/***/ "./public/js/mapper.js":
/*!*****************************!*\
  !*** ./public/js/mapper.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return mapper; });\nfunction mapper(nes) {\n    this.nes = nes;\n    this.chrGrids = [];\n    this.prgRomBanks = [];\n    this.chrRomBanks = [];\n    this.currentPRGBank = 0;\n    this.currentCHRBank = 0;\n    this.chrRam = false;\n\n    this.loadRom = function(romBytes) {\n        this.currentMapperNum = this.nes.ines.mapperNum;\n        this.initMem();\n\n        //Load PRG & CHR Rom banks\n        this.loadPRGBanks(romBytes);\n        this.loadCHRBanks(romBytes);\n        //Render the CHR aata into grids\n        this.renderCHRGrids();\n\n        switch (this.currentMapperNum) {\n            //NROM\n            case 0:\n                //assign banks to cpu & ppu\n                break;\n\n                //UNROM\n            case 2:\n                break;\n        }\n    };\n\n    //Initialize memory\n    this.initMem = function() {\n        // 2kb Internal RAM\n        for (var i = 0; i < 0x2000; i++) {\n            this.nes.MMU.cpuMem[i] = 0xFF;\n        }\n\n        // All others set to 0.\n        for (var i = 0x2000; i < 0x8000; i++) {\n            this.nes.MMU.cpuMem[i] = 0;\n        }\n    };\n\n    this.initCHRRam = function() {\n        var temp = [];\n        for (var i = 0; i < 8192; i++) {\n            temp.push(0);\n        }\n        this.chrRomBanks.push(temp);\n    };\n\n    this.loadPRGBanks = function(romBytes) {\n        var prgBank;\n        this.prgRomBanks = [];\n        for (var i = 0; i < this.nes.ines.prgRomUnits; i++) {\n            prgBank = [];\n            for (var j = 0; j < 16384; j++) {\n                // this.nes.MMU.setCpuMemVal((0xC000 + i), romBytes[i + 16]);\n                prgBank[j] = romBytes[i * 16384 + 16 + j];\n                // this.nes.MMU.cpuMem[0xC000 + i] = romBytes[i + 16];\n            }\n            this.prgRomBanks[i] = prgBank;\n        }\n        //if prg rom is only 16k, copy to next bank also\n        if (this.nes.ines.prgRomUnits == 1) {\n            this.prgRomBanks[1] = prgBank;\n        }\n    };\n\n    this.loadCHRBanks = function(romBytes) {\n        var chrBank;\n        this.chrRomBanks = [];\n        for (var i = 0; i < this.nes.ines.chrRomUnits; i++) {\n            chrBank = [];\n            for (var j = 0; j < 8192; j++) {\n                chrBank[j] = romBytes[i * 8192 + 16 + j + this.nes.ines.prgRomUnits * 16384];\n            }\n            this.chrRomBanks[i] = chrBank;\n        }\n        //TODO refactor CHR ram loading\n        if (this.nes.ines.chrRomUnits == 0) {\n            this.initCHRRam();\n            this.chrRam = true;\n        }\n    };\n\n    this.renderCHRGrids = function() {\n        var leftCHRGrid, rightCHRGrid;\n        for (var i = 0; i < this.chrRomBanks.length; i++) {\n            //get the chr rendered\n            leftCHRGrid = this.copyCHRToGrid(this.chrRomBanks[i], 0);\n            rightCHRGrid = this.copyCHRToGrid(this.chrRomBanks[i], 4096);\n            //assing the rendered grid as banks\n            this.chrGrids[i] = [leftCHRGrid, rightCHRGrid];\n        }\n    };\n\n    //return PRG rom data \n    this.getPRGRom = function(location) {\n        switch (this.currentMapperNum) {\n            case 0: //NROM\n                if (location >= 0x8000 && location < 0xC000) {\n                    return this.prgRomBanks[0][location - 0x8000];\n                }\n                else if (location >= 0xC000 && location <= 0xFFFF) {\n                    return this.prgRomBanks[1][location - 0xC000];\n                }\n                break;\n            case 2: //UnROM\n                if (location >= 0x8000 && location < 0xC000) {\n                    return this.prgRomBanks[this.currentPRGBank][location - 0x8000];\n                }\n                else if (location >= 0xC000 && location <= 0xFFFF) {\n                    return this.prgRomBanks[this.prgRomBanks.length - 1][location - 0xC000];\n                }\n                break;\n            case 3: //CNROM\n                if (location >= 0x8000 && location < 0xC000) {\n                    return this.prgRomBanks[0][location - 0x8000];\n                }\n                else if (location >= 0xC000 && location <= 0xFFFF) {\n                    return this.prgRomBanks[1][location - 0xC000];\n                }\n                break;\n        }\n    };\n\n    //return CHR rom data\n    this.getCHRRom = function(location) {\n        switch (this.currentMapperNum) {\n            case 0: //NROM\n                return this.chrRomBanks[this.currentCHRBank][location];\n            case 2: //UnROM\n                return this.chrRomBanks[this.currentCHRBank][location];\n            case 3: //CNROM\n                return this.chrRomBanks[this.currentCHRBank][location];\n        }\n    };\n\n    this.getCHRGrid = function(patternTblAddr, index) {\n        switch (this.currentMapperNum) {\n            case 0: //NROM\n                if (patternTblAddr == 'left') {\n                    return this.chrGrids[0][0][index];\n                }\n                else if (patternTblAddr == 'right') {\n                    return this.chrGrids[0][1][index];\n                }\n                break;\n            case 2: //UnROM\n                if (patternTblAddr == 'left') {\n                    return this.chrGrids[0][0][index];\n                }\n                else if (patternTblAddr == 'right') {\n                    return this.chrGrids[0][1][index];\n                }\n                break;\n            case 3: //CNROM\n                if (patternTblAddr == 'left') {\n                    return this.chrGrids[this.currentCHRBank][0][index];\n                }\n                else if (patternTblAddr == 'right') {\n                    return this.chrGrids[this.currentCHRBank][1][index];\n                }\n                break;\n        }\n    };\n\n    this.setCHRRom = function(location, value) {\n        switch (this.currentMapperNum) {\n            //UnROM\n            case 2:\n                this.chrRomBanks[this.currentCHRBank][location] = value;\n                break;\n        }\n    };\n\n    this.setBank = function(bank) {\n        switch (this.currentMapperNum) {\n            case 2: //UnROM\n                this.setPRGBank(bank);\n                break;\n            case 3: //CNROM\n                this.setCHRBank(bank & 0x03);\n                break;\n        }\n    };\n\n    //set the bank selected by rom\n    this.setPRGBank = function(bank) {\n        this.currentPRGBank = bank;\n    };\n\n    //set the bank selected by rom\n    this.setCHRBank = function(bank) {\n        this.currentCHRBank = bank;\n    };\n\n    this.copyCHRToGrid = function(chrRom, startAddress) {\n        var chrGrid = [];\n        var tileLow, tileHigh, mask, lowVal, highVal, compoundVal, compoundTileRow, tile;\n        for (var i = startAddress; i < startAddress + 4096; i += 16) {\n            tileLow = [];\n            tileHigh = [];\n            for (var j = 0; j < 8; j++) {\n                tileLow.push(chrRom[i + j]);\n            }\n            for (var k = 8; k < 16; k++) {\n                tileHigh.push(chrRom[i + k]);\n            }\n            tile = [];\n            for (var l = 0; l < 8; l++) {\n                compoundTileRow = [];\n                for (var k = 0; k < 8; k++) {\n                    mask = 0b00000001 << (7 - k);\n                    lowVal = mask & tileLow[l];\n                    highVal = mask & tileHigh[l];\n                    lowVal = lowVal >> (7 - k);\n                    highVal = highVal >> (7 - k);\n                    compoundVal = (highVal << 1) | lowVal;\n                    compoundTileRow.push(compoundVal);\n                }\n                tile.push(compoundTileRow);\n            }\n            chrGrid.push(tile);\n        }\n        return chrGrid;\n    };\n\n    this.reRenderCHR = function() {\n        this.chrGrids[0][0] = this.copyCHRToGrid(this.chrRomBanks[this.currentCHRBank], 0);\n        this.chrGrids[0][1] = this.copyCHRToGrid(this.chrRomBanks[this.currentCHRBank], 4096);\n        this.nes.MMU.chrRamWritten = false;\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/mapper.js?");

/***/ }),

/***/ "./public/js/mmu.js":
/*!**************************!*\
  !*** ./public/js/mmu.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return mmu; });\n//Memory Management Unit to synchronize memory access between CPU and PPU\n\nfunction mmu(nes) {\n    this.nes = nes;\n    this.cpuMem = new Uint8Array(65536);\n    this.ppuMem = new Uint8Array(16384);\n    this.nameTableMirroring = '';\n    this.startAddress = 0xFFFC;\n    this.ppuRegReadFlag = false;\n    this.ppuRegWriteFlag = false;\n    this.ppuRegObj = {\n        PPUCTRL: 0x00,\n        PPUMASK: 0x00,\n        PPUSTATUS: 0x00,\n        OAMADDR: 0x00,\n        OAMDATA: 0x00,\n        PPUSCROLL: 0x00,\n        PPUADDR: 0x00,\n        PPUDATA: 0x00,\n        OAMDMA: 0x00\n    };\n    this.PPUDATAReadBuffer = 0;\n    this.PPUCTRLwritten = false;\n    this.PPUMASKwritten = false;\n    this.OAMADDRwritten = false;\n    this.OAMDATAwritten = false;\n    this.OAMDMAwritten = false;\n    this.PPUSCROLLwritten = false;\n    this.PPUADDRwritten = false;\n    this.PPUDATAwritten = false;\n    this.PPUSTATUSread = false;\n    this.PPUADDRFirstWrite = true;\n    this.PPUSCROLLFirstWrite == true;\n    this.enableNMIGen = false;\n    this.controllerStrobed = false;\n    this.controllerLatched = false;\n    this.latchCounter = 0;\n    this.lsbLastWritePPU = 0;\n    this.PPUOAM = [];\n    this.CHRGrid = [];\n    this.BGRCHRGrid = [];\n    this.spriteGrid = [];\n    this.spriteTiles = [];\n    this.OAM = [];\n    this.chrRamWritten = false;\n    //button states\n    this.startBtnState = 0;\n    this.selectBtnState = 0;\n    this.upBtnState = 0;\n    this.downBtnState = 0;\n    this.aBtnState = 0;\n    this.bBtnState = 0;\n    this.leftBtnState = 0;\n    this.rightBtnState = 0;\n\n    this.OAMInit = function() {\n        for (var i = 0; i < 64; i++) {\n            this.OAM.push(0xFF);\n            this.OAM.push(0x00);\n            this.OAM.push(0x00);\n            this.OAM.push(0xFF);\n        }\n    };\n\n    this.getCpuMemVal = function(location) {\n        location = location & 0xFFFF;\n        var temp;\n        //RAM\n        if (location >= 0 && location < 0x800) {\n            return this.cpuMem[location];\n        }\n        //RAM mirrors\n        if (location >= 0x800 && location <= 0x1FFF) {\n            temp = location % 0x800;\n            return this.cpuMem[temp];\n        }\n        else if (location >= 0x2000 && location <= 0x2007) {\n            return this.getPPUReg(location);\n        }\n        else if (location >= 0x2008 && location <= 0x3FFF) {\n            temp = location - 0x2000;\n            temp = temp % 8;\n            return this.getPPUReg(0x2000 + temp);\n        }\n        else if (location >= 0x4000 && location <= 0x4013) {\n            return this.getAPUReg(location);\n        }\n        else if (location == 0x4016) {\n            var btnStates = 0;\n            if (this.controllerStrobed) {\n                //While strobed Return button A status here \n                return 0;\n            }\n            else if (this.controllerLatched) {\n                switch (this.latchCounter) {\n                    //button A\n                    case 0:\n                        btnStates = this.aBtnState;\n                        break;\n                        //button B\n                    case 1:\n                        btnStates = this.bBtnState;\n                        break;\n                        //button Select\n                    case 2:\n                        btnStates = this.selectBtnState;\n                        break;\n                        //button Start\n                    case 3:\n                        btnStates = this.startBtnState;\n                        break;\n                        //button Up\n                    case 4:\n                        btnStates = this.upBtnState;\n                        break;\n                        //button Down\n                    case 5:\n                        btnStates = this.downBtnState;\n                        break;\n                        //button Left\n                    case 6:\n                        btnStates = this.leftBtnState;\n                        break;\n                        //button Right\n                    case 7:\n                        btnStates = this.rightBtnState;\n                        break;\n                }\n                this.latchCounter++;\n                if (this.latchCounter >= 8) {\n                    this.latchCounter = 0;\n                    this.controllerLatched = false;\n                }\n                return btnStates | 0x40;\n            }\n            else if (!this.controllerLatched) {\n                return 0x40 | 1;\n            }\n        }\n        else if (location == 0x4017) {\n            return 0;\n        }\n        else if (location >= 0x8000 && location <= 0xFFFF) {\n            return this.nes.Mapper.getPRGRom(location);\n        }\n        else {\n            // alert('incorrect location to get from!');\n            return this.cpuMem[location];\n        }\n\n    };\n\n    this.setCpuMemVal = function(location, value) {\n        var temp;\n        //RAM \n        if (location >= 0 && location < 0x800) {\n            temp = this.cpuMem[location];\n            this.cpuMem[location] = value;\n            return temp;\n        }\n\n        //RAM mirrors\n        if (location >= 0x800 && location <= 0x1FFF) {\n            temp = location % 0x800;\n            var temp2 = this.cpuMem[temp];\n            this.cpuMem[temp] = value;\n            return temp2;\n        }\n        else if ((location >= 0x2000 && location <= 0x2007) || (location == 0x4014)) {\n            return this.setPPUReg(location, value);\n        }\n        else if (location >= 0x2008 && location <= 0x3FFF) {\n            temp = location - 0x2008;\n            temp = temp % 8;\n            return this.setPPUReg((0x2000 + temp), value);\n        }\n        else if (location >= 0x4000 && location <= 0x4015) {\n            return this.setAPUReg(location, value);\n        }\n        else if (location == 0x4016) {\n            if (value == 1) {\n                this.controllerStrobed = true;\n                this.controllerLatched = false;\n            }\n            else if ((value == 0) && this.controllerStrobed) {\n                this.controllerStrobed = false;\n                this.controllerLatched = true;\n            }\n            return 0;\n        }\n        else if (location == 0x4017) {\n            return this.setAPUReg(location, value);\n        }\n        else {\n            if (location >= 0x8000 && location <= 0xFFFF) {\n                this.nes.Mapper.setBank(value);\n                return 0;\n            }\n            // alert(\"incorrect location to put data in!\");\n        }\n    };\n\n    this.getPpuMemVal = function(location) {\n        if (location >= 0 && location < 0x2000) {\n            return this.nes.Mapper.getCHRRom(location);\n        }\n        return this.ppuMem[location];\n    };\n\n    this.setPpuMemVal = function(location, value) {\n        if (location >= 0 && location < 0x2000) {\n            this.ppuMem[location] = value;\n            this.nes.Mapper.setCHRRom(location, value);\n            this.chrRamWritten = true;\n            return;\n        }\n        if (location >= 0x3000 && location <= 0x3EFF) {\n            location = location - 0x1000;\n        }\n        if (location >= 0x3F00 && location <= 0x3F1F) {\n            location = location - 0x3F00;\n            this.setPPUPalette(location, value);\n            return;\n        }\n        else if (location >= 0x3F20 && location <= 0x3FFF) {\n            location = location - 0x3F1F;\n            this.setPPUPalette(location, value);\n            return;\n        }\n        else if (this.nameTableMirroring == 'vertical') { //Vertical mirroring \n            if (location >= 0x2000 && location < 0x2400) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x800] = value;\n            }\n            else if (location >= 0x2400 && location < 0x2800) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x800] = value;\n            }\n            else if (location >= 0x2800 && location < 0x2C00) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x800] = value;\n            }\n            else if (location >= 0x2C00 && location < 0x3000) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x800] = value;\n            }\n        }\n        else if (this.nameTableMirroring == 'horizontal') { //horizontal mirroring\n            if (location >= 0x2000 && location < 0x2400) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x400] = value;\n            }\n            else if (location >= 0x2800 && location < 0x2C00) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x400] = value;\n            }\n            else if (location >= 0x2400 && location < 0x2800) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x400] = value;\n            }\n            else if (location >= 0x2C00 && location < 0x3000) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x400] = value;\n            }\n        }\n        else\n            this.ppuMem[location] = value;\n    };\n\n\n\n    this.setPPUPalette = function(location, value) {\n        this.nes.PPU.setPalette(location, value);\n    };\n\n    this.getPPUReg = function(location) {\n        this.ppuRegReadFlag = true;\n        switch (location) {\n            case 0x2000:\n                return 0;\n            case 0x2001:\n                return 0;\n                //PPUSTATUS\n            case 0x2002:\n                this.PPUSTATUSread = false;\n                this.ppuRegObj.PPUADDR = 0x00;\n                this.ppuRegObj.PPUSCROLL = 0x00;\n                this.PPUADDRFirstWrite = true;\n                this.PPUSCROLLFirstWrite = true;\n                var temp = this.nes.PPU.getPPUSTATUS() & 0xF0;\n                temp = temp | (this.lsbLastWritePPU & 0x0F);\n                return temp;\n            case 0x2003:\n                break;\n                //OAMDATA\n            case 0x2004:\n                if (this.nes.PPU.currentScanline == 261 || (this.nes.PPU.currentScanline >= 0 && this.nes.PPU.currentScanline < 240)) {\n                    return;\n                }\n                else {\n                    return this.OAM[this.ppuRegObj.OAMADDR];\n                }\n            case 0x2005:\n                break;\n            case 0x2006:\n                break;\n                //PPUDATA\n            case 0x2007:\n                var temp = this.getPPUDATA(this.ppuRegObj.PPUADDR);\n                if (this.nes.PPU.vRamAddrInc == 'across') {\n                    this.ppuRegObj.PPUADDR += 1;\n                }\n                else if (this.nes.PPU.vRamAddrInc == 'down') {\n                    this.ppuRegObj.PPUADDR += 32;\n                }\n                return temp;\n        }\n    };\n\n    this.setPPUReg = function(location, value) {\n        this.ppuRegWriteFlag = true;\n        this.lsbLastWritePPU = value;\n        switch (location) {\n            //PPUCTRL\n            case 0x2000:\n                this.ppuRegObj.PPUCTRL = value;\n                this.nes.PPU.setPPUCTRL(this.ppuRegObj.PPUCTRL);\n                var temp = (this.ppuRegObj.PPUCTRL >> 7) & 0x01;\n                if (temp == 0)\n                    this.enableNMIGen = false;\n                else\n                    this.enableNMIGen = true;\n                this.PPUCTRLwritten = true;\n                return 0x2000;\n                //PPUMASK    \n            case 0x2001:\n                this.ppuRegObj.PPUMASK = value;\n                this.nes.PPU.setPPUMASK(this.ppuRegObj.PPUMASK);\n                this.PPUMASKwritten = true;\n                return 0x2001;\n            case 0x2002:\n                break;\n                //OAMADDR\n            case 0x2003:\n                this.setOAMADDR(value);\n                this.OAMADDRwritten = true;\n                return 0x2003;\n                //OAMDATA\n            case 0x2004:\n                this.setOAMDATA(value);\n                return 0x2004;\n                //PPUSCROLL\n            case 0x2005:\n                this.setPPUSCROLL(value);\n                this.PPUSCROLLwritten = true;\n                return 0x2005;\n                //PPUADDR\n            case 0x2006:\n                this.setPPUADDR(value);\n                this.PPUADDRwritten = true;\n                return 0x2006;\n                //PPUDATA\n            case 0x2007:\n                this.setPPUDATA(value);\n                if (this.nes.PPU.vRamAddrInc == 'across') {\n                    this.ppuRegObj.PPUADDR += 1;\n                }\n                else if (this.nes.PPU.vRamAddrInc == 'down') {\n                    this.ppuRegObj.PPUADDR += 32;\n                }\n                this.PPUDATAwritten = true;\n                return 0x2007;\n            case 0x4014:\n                this.ppuRegObj.OAMDMA = value;\n                this.setOAMDMA(this.ppuRegObj.OAMDMA);\n                this.OAMDMAwritten = true;\n                return 0x4014;\n        }\n    };\n\n    this.getAPUReg = function(location) {\n        var temp = 0b00000000;\n        switch (location) {\n            case 0x4015:\n                if (this.nes.APU.doIrq) {\n                    this.nes.APU.doIrq = false;\n                    temp = temp | 0b01000000;\n                }\n                if (this.nes.APU.sq1LenCounter > 0) {\n                    temp = temp | 0b00000001;\n                }\n        }\n        return temp;\n    };\n\n    this.setAPUReg = function(location, value) {\n        switch (location) {\n            case 0x4000: //SQ1_ENV\n                this.nes.APU.setSQ1_ENV(value);\n                break;\n            case 0x4001:\n                this.nes.APU.setSQ1_SWEEP(value); //SQ1_SWEEP\n                break;\n            case 0x4002: //SQ1_LO\n                this.nes.APU.setSQ1_LO(value);\n                break;\n            case 0x4003: //SQ1_HI\n                this.nes.APU.setSQ1_HI(value);\n                break;\n            case 0x4004: //SQ2_ENV\n                this.nes.APU.setSQ2_ENV(value);\n                break;\n            case 0x4005:\n                this.nes.APU.setSQ2_SWEEP(value);\n                break;\n            case 0x4006:\n                this.nes.APU.setSQ2_LO(value);\n                break;\n            case 0x4007:\n                this.nes.APU.setSQ2_HI(value);\n                break;\n            case 0x4008:\n                this.nes.APU.setTRIControl(value);\n                break;\n            case 0x400A:\n                this.nes.APU.setTRI_LO(value);\n                break;\n            case 0x400B:\n                this.nes.APU.setTRI_HI(value);\n                break;\n            case 0x4015: //APUFLAGS\n                this.nes.APU.setAPUFlags(value);\n                break;\n            case 0x4017:\n                this.nes.APU.setFrameCounter(value);\n                break;\n        };\n        return 0\n    };\n\n    this.getPPURegObj = function() {\n        return this.ppuRegObj;\n    };\n\n    this.getOAM = function() {\n        return this.OAM;\n    };\n\n    this.getNameTable = function() {\n        return this.ppuMem;\n    };\n\n    this.getAttrTable = function() {\n        return this.ppuMem;\n    };\n\n    this.setOAMDATA = function(value) {\n        if (this.nes.PPU.currentScanline == 261 || (this.nes.PPU.currentScanline >= 0 && this.nes.PPU.currentScanline < 240)) {\n\n        }\n        else {\n            this.OAM[this.ppuRegObj.OAMADDR] = value;\n            this.setOAMADDR(this.ppuRegObj.OAMADDR + 1);\n        }\n        this.OAMDATAwritten = true;\n    };\n\n    this.setOAMADDR = function(value) {\n        this.ppuRegObj.OAMADDR = value;\n        this.nes.PPU.setOAMADDR(this.ppuRegObj.OAMADDR);\n    };\n\n    //OAM DMA copying\n    this.startOAMDMACopy = function() {\n        if ( /*this.nes.PPU.vBlankStarted*/ true) {\n            for (var i = 0; i < 256; i++) {\n                // this.OAM[i] = this.getCpuMemVal((this.OAMDMA << 8) + i);\n                // this.OAM[i] = this.getCpuMemVal((this.OAMDMA * 0x100) + i);\n                // this.setOAMDATA(this.getCpuMemVal((this.OAMDMA * 0x100) + i));\n                this.setOAMDATA(this.cpuMem[(this.OAMDMA * 0x100) + i]);\n            }\n        }\n    };\n\n    this.setOAMDMA = function(OAMDMA) {\n        this.OAMDMA = OAMDMA;\n        this.startOAMDMACopy();\n    };\n\n    this.setPPUADDR = function(value) {\n        if (this.PPUADDRFirstWrite) {\n            this.ppuRegObj.PPUADDR = value;\n            this.ppuRegObj.PPUADDR = this.ppuRegObj.PPUADDR << 8;\n            this.nes.PPU.fineYScroll = 0; //this.nes.PPU.fineYScroll & 0x04;\n            this.nes.PPU.fineYScroll = this.nes.PPU.fineYScroll | ((value & 0x30) >> 4);\n            this.nes.PPU.baseNameTblAddr = (value & 0x0C) >> 2;\n            this.PPUADDRFirstWrite = false;\n        }\n        else {\n            this.ppuRegObj.PPUADDR = this.ppuRegObj.PPUADDR | value;\n            if (this.ppuRegObj.PPUADDR > 0x3FFF)\n                this.ppuRegObj.PPUADDR = this.ppuRegObj.PPUADDR - 0x3FFF;\n            this.nes.PPU.coarseXScroll = value & 0x1F;\n            this.nes.PPU.coarseYScroll = (this.coarseYScroll & 0x18) | ((value & 0xE0) >> 5);\n            this.PPUADDRFirstWrite = true;\n        }\n    };\n\n    this.setPPUSCROLL = function(value) {\n        this.ppuRegObj.PPUSCROLL = value;\n        if (this.PPUADDRFirstWrite) {\n            this.nes.PPU.xScroll = value;\n            this.nes.PPU.coarseXScroll = (value & 0xF8) >> 3;\n            this.nes.PPU.fineXScroll = value & 0x07;\n            this.PPUADDRFirstWrite = false;\n        }\n        else {\n            this.nes.PPU.yScroll = value;\n            this.nes.PPU.coarseYScroll = (value & 0xF8) >> 3;\n            this.nes.PPU.fineYScroll = value & 0x07;\n            this.PPUADDRFirstWrite = true;\n        }\n    };\n\n    this.getPPUDATA = function(location) {\n        var returnValue = this.PPUDATAReadBuffer;\n        if (location >= 0x0000 && location < 0x3EFF) {\n            this.PPUDATAReadBuffer = this.getPpuMemVal(location);\n        }\n        else {\n            returnValue = this.getPpuMemVal(location);\n        }\n        return returnValue;\n    };\n    this.setPPUDATA = function(value) {\n        this.setPpuMemVal(this.ppuRegObj.PPUADDR, value);\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/mmu.js?");

/***/ }),

/***/ "./public/js/ppu.js":
/*!**************************!*\
  !*** ./public/js/ppu.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ppu; });\nfunction ppu(nes) {\n    this.nes = nes;\n    //Render VARS\n    this.currentScanline = 0;\n    this.nameTableMirroring = '';\n    this.NMIOccured = false;\n    this.CHRGrid = [];\n    this.BGRCHRGrid = [];\n    this.screenBuffer = [\n        []\n    ];\n    this.palette = [];\n\n    this.paletteColors = [0x7C7C7C,\n        0x0000FC,\n        0x0000BC,\n        0x4428BC,\n        0x940084,\n        0xA80020,\n        0xA81000,\n        0x881400,\n        0x503000,\n        0x007800,\n        0x006800,\n        0x005800,\n        0x004058,\n        0x000000,\n        0x000000,\n        0x000000,\n        0xBCBCBC,\n        0x0078F8,\n        0x0058F8,\n        0x6844FC,\n        0xD800CC,\n        0xE40058,\n        0xF83800,\n        0xE45C10,\n        0xAC7C00,\n        0x00B800,\n        0x00A800,\n        0x00A844,\n        0x008888,\n        0x000000,\n        0x000000,\n        0x000000,\n        0xF8F8F8,\n        0x3CBCFC,\n        0x6888FC,\n        0x9878F8,\n        0xF878F8,\n        0xF85898,\n        0xF87858,\n        0xFCA044,\n        0xF8B800,\n        0xB8F818,\n        0x58D854,\n        0x58F898,\n        0x00E8D8,\n        0x787878,\n        0x000000,\n        0x000000,\n        0xFCFCFC,\n        0xA4E4FC,\n        0xB8B8F8,\n        0xD8B8F8,\n        0xF8B8F8,\n        0xF8A4C0,\n        0xF0D0B0,\n        0xFCE0A8,\n        0xF8D878,\n        0xD8F878,\n        0xB8F8B8,\n        0xB8F8D8,\n        0x00FCFC,\n        0xF8D8F8,\n        0x000000,\n        0x000000\n    ];\n\n\n    // this.cyclesToEmulate = 0;\n    // this.curretRenderCycle = 0;\n    //PPUCTRL vars\n    this.baseNameTblAddr = 0x2000;\n    this.vRamAddrInc = 'across';\n    // this.spritePatTblAddr = this.CHRGrid;\n    // this.backgroundPatTblAddr = this.BGRCHRGrid;\n    this.spritePatTblAddr = 'left';\n    this.backgroundPatTblAddr = 'right';\n    this.spriteSize = 8;\n    this.ppuMasterSlave = 'readBackdrop';\n    this.enableNMIGen = false;\n\n    //PPUMASK vars\n    this.renderGreyscale = false;\n    this.renderBGLeftMost = false;\n    this.renderSpritesLeftMost = false;\n    this.renderBackground = false;\n    this.renderSprite = false;\n    this.renderEmphRed = false;\n    this.renderEmphGreen = false;\n    this.renderEmphBlue = false;\n\n    //PPUSTATUS vars\n    this.ppuStatusBits = 0b00000000;\n    this.spriteOverflow = false;\n    //this.spriteHit = false;\n    this.vBlankStarted = false;\n    this.sprite0Hit = false;\n\n    //PPUSCROLL vars\n    this.xScroll = 0;\n    this.yScroll = 0;\n    this.coarseXScroll = 0;\n    this.coarseYScroll = 0;\n    this.fineXScroll = 0;\n    this.fineYScroll = 0;\n    this.OAM = [];\n\n    //OAMADDR \n    this.OAMADDR = 0x00;\n\n    //OAMDATA\n    this.OAMDATA = 0x00;\n\n    //OAMDMA\n    this.OAMDMA = 0x00;\n\n    this.PPUSCROLL;\n\n    //PPUADDR\n    this.PPUADDR;\n\n    //PPUDATA \n    this.PPUDATA;\n    this.spriteGrid = [];\n    this.backGroundGrid = [];\n\n\n    //Update PPUCTRL status\n    this.setPPUCTRL = function(PPUCTRL) {\n        var temp;\n        temp = PPUCTRL & 0x03;\n        this.baseNameTblAddr = temp;\n        temp = (PPUCTRL >> 2) & 0x01;\n        if (temp == 0)\n            this.vRamAddrInc = 'across';\n        else\n            this.vRamAddrInc = 'down';\n        temp = (PPUCTRL >> 3) & 0x01;\n        if (temp == 0)\n            this.spritePatTblAddr = 'left';\n        else\n            this.spritePatTblAddr = 'right';\n        temp = (PPUCTRL >> 4) & 0x01;\n        if (temp == 0)\n            this.backgroundPatTblAddr = 'left';\n        else\n            this.backgroundPatTblAddr = 'right';\n        temp = (PPUCTRL >> 5) & 0x01;\n        if (temp == 0)\n            this.spriteSize = 8;\n        else\n            this.spriteSize = 16;\n        temp = (PPUCTRL >> 6) & 0x01;\n        if (temp == 0)\n            this.ppuMasterSlave = 'readBackdrop';\n        else\n            this.ppuMasterSlave = 'outputColor';\n        temp = (PPUCTRL >> 7) & 0x01;\n        if (temp == 0)\n            this.enableNMIGen = false;\n        else\n            this.enableNMIGen = true;\n    };\n\n    //Update PPUMASK status\n    this.setPPUMASK = function(PPUMASK) {\n        var temp;\n        temp = PPUMASK & 0x01;\n        if (temp == 0)\n            this.renderGreyscale = false;\n        else\n            this.renderGreyscale = true;\n        temp = (PPUMASK >> 1) & 0x01;\n        if (temp == 0)\n            this.renderBGLeftMost = false;\n        else\n            this.renderBGLeftMost = true;\n        temp = (PPUMASK >> 2) & 0x01;\n        if (temp == 0)\n            this.renderSpritesLeftMost = false;\n        else\n            this.renderSpritesLeftMost = true;\n        temp = (PPUMASK >> 3) & 0x01;\n        if (temp == 0)\n            this.renderBackground = false;\n        else\n            this.renderBackground = true;\n        temp = (PPUMASK >> 4) & 0x01;\n        if (temp == 0)\n            this.renderSprite = false;\n        else\n            this.renderSprite = true;\n        temp = (PPUMASK >> 5) & 0x01;\n        if (temp == 0)\n            this.renderEmphRed = false;\n        else\n            this.renderEmphRed = true;\n        temp = (PPUMASK >> 6) & 0x01;\n        if (temp == 0)\n            this.renderEmphGreen = false;\n        else\n            this.renderEmphGreen = true;\n        temp = (PPUMASK >> 7) & 0x01;\n        if (temp == 0)\n            this.renderEmphBlue = false;\n        else\n            this.renderEmphBlue = true;\n    };\n\n\n    //Update OAMADDR\n    this.setOAMADDR = function(OAMADDR) {\n        this.OAMADDR = OAMADDR;\n    };\n\n    //Update OAMDATA\n    // this.setOAMDATA = function(OAMDATA) {\n    //     this.OAMDATA = OAMDATA;\n    // };\n\n    //Update PPUADDR\n    this.setPPUADDR = function(PPUADDR) {\n        this.PPUADDR = PPUADDR;\n    };\n\n    //Update PPU status resigster values into MMU object\n    this.getPPUSTATUS = function() {\n        var prevStatus = this.ppuStatusBits;\n        if (this.NMIOccured) {\n            prevStatus = prevStatus & 0x7F;\n            prevStatus = prevStatus | 0x80;\n        }\n        //clear PPUSTATUS vblank indicators\n        this.ppuStatusBits = this.ppuStatusBits & 0x7F;\n        return prevStatus;\n    };\n\n    // this.getOAMDATA = function() {\n    //     return this.OAMDATA;\n    // };\n\n    //Load PPU Palette values\n    //TODO: mirror palette values\n    this.setPalette = function(index, value) {\n        this.palette[index] = value;\n    };\n\n    this.initScreenBuffer = function() {\n        for (var x = 0; x < 256 * 240; x++) {\n            this.screenBuffer.push(0x000000);\n        }\n        this.nes.mainDisplay.initScreenBuffer();\n        // this.nes.mainDisplay.initNameTableScreenBuffer();\n    };\n\n    this.calcPaletteFromAttr = function(X, Y, attrByte) {\n        var paletteNum = 0;\n        // Top left of 2x2 tile\n        if (((X % 4 == 0) || (X % 4 == 1)) && ((Y % 4 == 0) || (Y % 4 == 1))) {\n            // paletteNum = attrByte >> 6;\n            paletteNum = attrByte & 0x03;\n        }\n        //Top right\n        else if (((X % 4 != 0) && (X % 4 != 1)) && ((Y % 4 == 0) || (Y % 4 == 1))) {\n            // paletteNum = (attrByte >> 4) & 0x03;\n            paletteNum = (attrByte >> 2) & 0x03;\n        }\n        //Bottom left\n        else if (((X % 4 == 0) || (X % 4 == 1)) && ((Y % 4 != 0) && (Y % 4 != 1))) {\n            // paletteNum = (attrByte >> 2) & 0x03;\n            paletteNum = (attrByte >> 4) & 0x03;\n        }\n        //Bottom right\n        else if (((X % 4 != 0) && (X % 4 != 1)) && ((Y % 4 != 0) && (Y % 4 != 1))) {\n            // paletteNum = attrByte & 0x03;\n            paletteNum = attrByte >> 6;\n        }\n        else {\n            alert(\"palette not found!!\");\n        }\n        return paletteNum;\n    };\n    //Evaluate sprites & Draw to screen buffer\n    //TODO: 8x16 tile rendering\n    this.renderSprites = function(oam) {\n        var spritesToDraw = [],\n            tile, paletteNum, spriteX, spriteY, pixelColor, pixelColorIndex, spriteAttr, tileNum, tileRow;\n        if (this.spriteSize == 8) {\n            //Beginning of Sprite Evaluation\n            //Check which sprites in OAM lie in current scanline\n            for (var i = this.OAMADDR; i < 256; i += 4) {\n                if ((oam[i] + 1) > (this.currentScanline - 8) && (oam[i] + 1) <= this.currentScanline) {\n                    // if ((oam[i] + 1) > (this.currentScanline - this.spriteSize) && (oam[i] + 1) <= this.currentScanline) {\n                    //add to list of sprites to draw on current scanline\n                    spritesToDraw.push(i);\n                }\n            }\n            //if more than 8 sprites lie in current scanline set sprite overflow to true\n            if (spritesToDraw.length > 8) {\n                this.spriteOverflow = true;\n                this.ppuStatusBits = this.ppuStatusBits & 0xDF;\n                this.ppuStatusBits = this.ppuStatusBits | 0x20;\n            }\n            else this.spriteOverflow = false;\n\n            //Render the portion of the sprite that falls on the current scanline to offscreen buffer \n            for (i = spritesToDraw.length - 1; i >= 0; i--) { //Reversed looping to maintain sprite priority\n                spriteX = oam[spritesToDraw[i] + 3];\n                spriteY = oam[spritesToDraw[i]] + 1;\n                tileNum = oam[spritesToDraw[i] + 1];\n                spriteAttr = oam[spritesToDraw[i] + 2];\n                //Select tile num from OAM byte 1 and index from CHRGrid already prepared\n                tile = this.nes.Mapper.getCHRGrid(this.spritePatTblAddr, tileNum);\n\n                // tile = this.spritePatTblAddr[tileNum];\n                tileRow = tile[this.currentScanline - spriteY];\n                //Select the palette number from OAM for the tile\n                paletteNum = spriteAttr & 0b00000011;\n\n                //Check for flipping of sprite\n                if (((spriteAttr & 0b01000000) == 0b01000000) && ((spriteAttr & 0b10000000) == 0b10000000)) {\n                    var tempRow = [];\n                    var tempRow2 = [];\n                    for (var x = 0; x < 8; x++) {\n                        tempRow.push(tile[Math.abs((this.currentScanline - spriteY) - 7)][x]);\n                        // tempRow.push(tile[Math.abs((this.currentScanline - spriteY) - this.spriteSize - 1)][x]);\n                    }\n                    for (var x = 7; x >= 0; x--) {\n                        tempRow2.push(tempRow[x]);\n                    }\n                    tileRow = tempRow2;\n                }\n                else if ((spriteAttr & 0b01000000) == 0b01000000) { //horizontally flip sprite\n                    var tempRow = [];\n                    for (var x = 7; x >= 0; x--) {\n                        tempRow.push(tileRow[x]);\n                    }\n                    tileRow = tempRow;\n                }\n                else if ((spriteAttr & 0b10000000) == 0b10000000) { //vertically flip sprite\n                    var tempRow = [];\n                    for (var x = 0; x < 8; x++) {\n                        tempRow.push(tile[Math.abs((this.currentScanline - spriteY) - 7)][x]);\n                        // tempRow.push(tile[Math.abs((this.currentScanline - spriteY) - this.spriteSize - 1)][x]);\n                    }\n                    tileRow = tempRow;\n                }\n\n                //Draw pixels of the tile that lie on current scanline \n                for (var x = 0; x < 8; x++) {\n                    //X coordinate is fetched from OAM, Y is calculated current scanline - OAM Y coordinate + 1\n                    //Color palette is shifted by 16 to ignore the background palettes \n                    //palette number multiplied by 4 to offset the actual tile palette colors \n                    //The actual tile data is added to get the pixel color, tile(x, y) contails value 0-3 \n                    //x is the loop counter, y remains constant as offset from tile Y and current scanline\n\n                    pixelColorIndex = tileRow[x];\n\n                    //for transparent sprite bit show background so don't draw sprite to buffer\n                    if (pixelColorIndex != 0) {\n                        var currentBackgroundPixelColor = this.screenBuffer[spriteX + x + (this.currentScanline * 256)];\n\n                        //non-transparent sprite over transparent background\n                        // if (currentBackgroundPixelColor == this.paletteColors[this.palette[0]]) {\n                        if (currentBackgroundPixelColor == 0) {\n                            pixelColor = this.paletteColors[this.palette[16 + paletteNum * 4 + pixelColorIndex]];\n                            // this.screenBuffer[spriteX + x + (this.currentScanline * 256)] = pixelColor;\n                            this.screenBuffer[spriteX + x + (this.currentScanline * 256)] = pixelColorIndex;\n                            this.nes.mainDisplay.updateBuffer(spriteX + x + (this.currentScanline * 256), pixelColor);\n                        }\n\n                        else if (currentBackgroundPixelColor != 0) {\n                            //non-transparent sprite having foreground priority over non-transparent background\n                            // if (currentBackgroundPixelColor != this.paletteColors[this.palette[0]] && ((spriteAttr & 0b00100000) == 0)) {\n                            if ((currentBackgroundPixelColor != 0) && ((spriteAttr & 0b00100000) == 0)) {\n                                pixelColor = this.paletteColors[this.palette[16 + paletteNum * 4 + pixelColorIndex]];\n                                this.screenBuffer[spriteX + x + (this.currentScanline * 256)] = pixelColorIndex;\n                                // this.screenBuffer[spriteX + x + (this.currentScanline * 256)] = pixelColor;\n                                this.nes.mainDisplay.updateBuffer(spriteX + x + (this.currentScanline * 256), pixelColor);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else if (this.spriteSize == 16) {\n            var drawingTopTile = true,\n                tileUp, tileDown, tileRowIndex = 0;\n            //Check which sprites in OAM lie in current scanline\n            for (var i = this.OAMADDR; i < 256; i += 4) {\n                if ((oam[i] + 1) > (this.currentScanline - 16) && (oam[i] + 1) <= this.currentScanline) {\n                    //add to list of sprites to draw on current scanline\n                    spritesToDraw.push(i);\n                }\n            }\n            //if more than 8 sprites lie in current scanline set sprite overflow to true\n            if (spritesToDraw.length > 8) {\n                this.spriteOverflow = true;\n                this.ppuStatusBits = this.ppuStatusBits & 0xDF;\n                this.ppuStatusBits = this.ppuStatusBits | 0x20;\n            }\n            else this.spriteOverflow = false;\n            //Render the portion of the sprite that falls on the current scanline to offscreen buffer \n            for (i = spritesToDraw.length - 1; i >= 0; i--) { //Reversed looping to maintain sprite priority\n                spriteX = oam[spritesToDraw[i] + 3];\n                spriteY = oam[spritesToDraw[i]] + 1;\n                tileRowIndex = this.currentScanline - spriteY;\n                if (tileRowIndex > 7) { //we are now at bottom portion of 8x16 tile\n                    drawingTopTile = false;\n                    tileRowIndex = tileRowIndex - 8;\n                }\n                else {\n                    drawingTopTile = true;\n                }\n                tileNum = oam[spritesToDraw[i] + 1];\n                spriteAttr = oam[spritesToDraw[i] + 2];\n                //Select tile num from OAM byte 1 and index from CHRGrid already prepared\n                if ((tileNum & 0x01) == 0) {\n                    //for bottom of 8x16 tile, select the next tile from pattern table\n                    tileNum = (tileNum & 0xFE);\n                    // tileUp = this.CHRGrid[tileNum];\n                    tileUp = this.nes.Mapper.getCHRGrid('left', tileNum);\n                    tileDown = this.nes.Mapper.getCHRGrid('left', tileNum + 1);\n                }\n                else if ((tileNum & 0x01) == 1) {\n                    tileNum = (tileNum & 0xFE);\n                    tileUp = this.nes.Mapper.getCHRGrid('right', tileNum);\n                    tileDown = this.nes.Mapper.getCHRGrid('right', tileNum + 1);\n                }\n                // tileRowIndex = tileRowIndex % 8; //we got the specifig tile in tile var already so normalizing\n                if (drawingTopTile) {\n                    tileRow = tileUp[tileRowIndex];\n                }\n                else {\n                    tileRow = tileDown[tileRowIndex];\n                }\n\n                //Select the palette number from OAM for the tile\n                paletteNum = spriteAttr & 0b00000011;\n\n                //Check for flipping of sprite\n                if (((spriteAttr & 0b01000000) == 0b01000000) && ((spriteAttr & 0b10000000) == 0b10000000)) {\n                    var tempRow = [];\n                    var tempRow2 = [];\n                    if (drawingTopTile) {\n                        tile = tileDown;\n                    }\n                    else {\n                        tile = tileUp;\n                    }\n                    for (var x = 0; x < 8; x++) {\n                        tempRow.push(tile[Math.abs((tileRowIndex) - 7)][x]);\n                        // tempRow.push(tile[Math.abs((this.currentScanline - spriteY) - this.spriteSize - 1)][x]);\n                    }\n                    for (var x = 7; x >= 0; x--) {\n                        tempRow2.push(tempRow[x]);\n                    }\n                    tileRow = tempRow2;\n                }\n                else if ((spriteAttr & 0b01000000) == 0b01000000) { //horizontally flip sprite\n                    var tempRow = [];\n                    for (var x = 7; x >= 0; x--) {\n                        tempRow.push(tileRow[x]);\n                    }\n                    tileRow = tempRow;\n                }\n                else if ((spriteAttr & 0b10000000) == 0b10000000) { //vertically flip sprite\n                    var tempRow = [];\n                    if (drawingTopTile) {\n                        tile = tileDown;\n                    }\n                    else {\n                        tile = tileUp;\n                    }\n                    for (var x = 0; x < 8; x++) {\n                        tempRow.push(tile[Math.abs((tileRowIndex) - 7)][x]);\n                    }\n                    tileRow = tempRow;\n                }\n\n                //Draw pixels of the tile that lie on current scanline \n                for (var x = 0; x < 8; x++) {\n                    //X coordinate is fetched from OAM, Y is calculated current scanline - OAM Y coordinate + 1\n                    //Color palette is shifted by 16 to ignore the background palettes \n                    //palette number multiplied by 4 to offset the actual tile palette colors \n                    //The actual tile data is added to get the pixel color, tile(x, y) contails value 0-3 \n                    //x is the loop counter, y remains constant as offset from tile Y and current scanline\n\n                    pixelColorIndex = tileRow[x];\n\n                    //for transparent sprite bit show background so don't draw sprite to buffer\n                    if (pixelColorIndex != 0) {\n                        var currentBackgroundPixelColor = this.screenBuffer[spriteX + x + (this.currentScanline * 256)];\n\n                        //non-transparent sprite over transparent background\n                        if (currentBackgroundPixelColor == 0) {\n                            pixelColor = this.paletteColors[this.palette[16 + paletteNum * 4 + pixelColorIndex]];\n                            this.screenBuffer[spriteX + x + (this.currentScanline * 256)] = pixelColorIndex;\n                            this.nes.mainDisplay.updateBuffer(spriteX + x + (this.currentScanline * 256), pixelColor);\n                        }\n\n                        else if (currentBackgroundPixelColor != 0) {\n                            //non-transparent sprite having foreground priority over non-transparent background\n                            if ((currentBackgroundPixelColor != 0) && ((spriteAttr & 0b00100000) == 0)) {\n                                pixelColor = this.paletteColors[this.palette[16 + paletteNum * 4 + pixelColorIndex]];\n                                this.screenBuffer[spriteX + x + (this.currentScanline * 256)] = pixelColorIndex;\n                                this.nes.mainDisplay.updateBuffer(spriteX + x + (this.currentScanline * 256), pixelColor);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    this.renderBackGrounds = function(nametable, attrtable) {\n        var paletteNum = 0;\n        var pixelColor = 0; //this will hold the final pixel with color calculated \n        var pixelColorArray = []; //array to hold one scanline worth of color pixels\n        var pixelColorIndexArray = [];\n        var screenPixel = 0; //this is the pixel index of 32x30 screen \n        var nametableOffset = this.baseNameTblAddr;\n        var tileXOffset = 0,\n            tileYOffset = 0;\n        var pixelXOffset = 0,\n            pixelYOffset = 0;\n        var tileToDraw = 0;\n        var bgRenderingDone = false;\n        var attrByte = 0;\n        var curTileX = 0;\n        var curTileY = Math.floor(this.currentScanline / 8);\n        var tileCounter = 0;\n        var tilesThisScanline = 32;\n        var curTileYOffsetted = 0;\n        var vReg = 0;\n        var X = 0,\n            Y = 0;\n        //Tile Draw logic: get the tile to start draw from. Check for horizontal offset\n        //offset the tiles using horizontal offset, then calculate pixel offset\n        //Also calculate how many tiles of next nametable need to be drawn\n        //then calculate upto which pixel drawing is needed\n        if (this.yScroll > 239) {\n            this.yScroll = 0;\n        }\n        // tileXOffset = Math.floor(this.xScroll / 8); //offset tile (see above)\n        tileXOffset = this.coarseXScroll;\n        tileYOffset = Math.floor((this.currentScanline + this.yScroll) / 8); //offset tile (see above)\n        // tileYOffset = this.coarseYScroll;\n\n        // pixelXOffset = this.xScroll % 8; //offset pixel\n        pixelXOffset = this.fineXScroll;\n\n        pixelYOffset = (this.currentScanline + this.yScroll) % 8; //offset pixel\n        curTileX = tileXOffset; //start rendering from the offsetted tile\n        curTileYOffsetted = tileYOffset;\n\n        //when there is fine pixel offset, we have to fetch and draw pixels from an extra tile\n        if ((pixelXOffset > 0) && (this.nameTableMirroring == 'vertical')) {\n            tilesThisScanline = 33;\n        }\n        //loop to draw all the tiles on the screen for current scanline\n        while (!bgRenderingDone) {\n            if (curTileYOffsetted >= 30) {\n                if (this.baseNameTblAddr == 2) {\n                    nametableOffset = 0;\n                }\n                else {\n                    nametableOffset = this.baseNameTblAddr + 2;\n                }\n                Y = curTileYOffsetted - 30;\n            }\n            else {\n                nametableOffset = this.baseNameTblAddr;\n                Y = curTileYOffsetted;\n            }\n\n            if (curTileX >= 32) { //check if current tile lies on next nametable\n                if (nametableOffset == 3) {\n                    nametableOffset = 0;\n                }\n                else {\n                    nametableOffset = nametableOffset + 1;\n                }\n                X = curTileX - 32;\n            }\n            else {\n                X = curTileX;\n            }\n            vReg = (nametableOffset << 10) | (Y << 5) | X;\n\n            tileToDraw = nametable[0x2000 | vReg];\n\n            //get the tile bits from pre-calculated grid\n            tileToDraw = this.nes.Mapper.getCHRGrid(this.backgroundPatTblAddr, tileToDraw);\n\n            //Determine color palette\n            //Get the current byte entries in 8x8 (32x32 pixel) attribute byte array\n            attrByte = nametable[0x23C0 | (vReg & 0x0C00) | ((vReg >> 4) & 0x38) | ((vReg >> 2) & 0x07)];\n\n            paletteNum = this.calcPaletteFromAttr(X, Y, attrByte);\n\n            //We have now determined the background tile(accross nametables) to be rendered\n            //also calculated the color palette using proper attributes\n            //Now start the actual rendering process\n\n            var curY = (this.currentScanline + this.yScroll) % 8; //get the y co-ordinate of an 8x8 tile from where to start rendering\n            // var curY = (this.currentScanline % 8) + this.fineYScroll;\n\n\n            var curX = 0;\n            var pixelXlimit = 8;\n            if (tileCounter == 0) { //now drawing the left most tile so check for pixel offset\n                if (pixelXOffset > 0) { //we have offset so start rendering by offseting the tile bits by that amount\n                    curX = pixelXOffset;\n                }\n            }\n            if (tileCounter == tilesThisScanline - 1) { //now drawing the final tile, so only draw until the offset is normalized\n                if (pixelXOffset > 0) { //we have offset so start rendering by offseting the tile bits by that amount\n                    pixelXlimit = pixelXOffset;\n                }\n            }\n\n            //Loop through the pixels for the current tile and store in an array\n            for (curX; curX < pixelXlimit; curX++) {\n                if (tileToDraw[curY][curX] == 0) { //backdrop color\n                    pixelColor = this.paletteColors[this.palette[0]];\n                    pixelColorIndexArray.push(tileToDraw[curY][curX]);\n                    pixelColorArray.push(pixelColor);\n                }\n                else {\n                    pixelColor = this.paletteColors[this.palette[paletteNum * 4 + tileToDraw[curY][curX]]];\n                    pixelColorIndexArray.push(tileToDraw[curY][curX]);\n                    pixelColorArray.push(pixelColor);\n                }\n            }\n\n            tileCounter++;\n            curTileX++;\n            if (tileCounter >= tilesThisScanline) {\n                bgRenderingDone = true;\n            }\n        }\n\n        //Now that we have the color pixel array, update them in the screen buffer\n        //Start from left most pixel (x = 0) from current scanline\n        screenPixel = 0 + (curTileY * 8 + (this.currentScanline % 8)) * 256;\n\n        //start merging our color pixel array into screen buffer from now on\n        for (var x = screenPixel; x < (screenPixel + pixelColorArray.length); x++) {\n            this.screenBuffer[x] = pixelColorIndexArray[x - screenPixel];\n            this.nes.mainDisplay.updateBuffer(x, pixelColorArray[x - screenPixel]);\n        }\n    };\n\n    this.RenderNextScanline = function(oam, nametable, attrtable) {\n        //Pre render Scanline\n        if (this.currentScanline == 261) {\n            //clear PPUSTATUS vblank indicator\n            this.ppuStatusBits = this.ppuStatusBits & 0x7F;\n            //clear sprite hit\n            this.ppuStatusBits = this.ppuStatusBits & 0xBF;\n            this.sprite0Hit = false;\n            //clear sprite overflow\n            this.ppuStatusBits = this.ppuStatusBits & 0xDF;\n            this.spriteOverflow = false;\n            this.NMIOccured = false;\n\n            this.currentScanline = 0;\n            this.vBlankStarted = false;\n\n            return 261;\n        }\n        //Visible Scanlines\n        else if (this.currentScanline >= 0 && this.currentScanline < 240) {\n            if (this.currentScanline == 0) {\n\n            }\n            //Calculate sprite 0 hit before rendering begins\n            if (this.renderBackground && this.renderSprite)\n                this.setSprite0Hit(oam);\n\n            if (this.renderBackground)\n                this.renderBackGrounds(nametable, attrtable);\n\n            if (this.renderSprite)\n                this.renderSprites(oam);\n        }\n        //Post render Scanline\n        else if (this.currentScanline == 240) {\n\n        }\n        //Vertical blanking lines\n        else if (this.currentScanline > 240 && this.currentScanline <= 260) {\n            if (this.currentScanline == 241) {\n                //Set vBlank\n                this.ppuStatusBits = this.ppuStatusBits & 0x7F;\n                this.ppuStatusBits = this.ppuStatusBits | 0x80;\n\n                this.vBlankStarted = true;\n                this.NMIOccured = true;\n            }\n        }\n        this.currentScanline++;\n        return this.currentScanline - 1;\n    };\n\n    this.setSprite0Hit = function(oam) {\n        var drawSprite0 = false,\n            spriteX, spriteY, tileNum, tile, tileRow, pixelColorIndex;\n        if ((oam[0] + 1) > (this.currentScanline - 8) && (oam[0] + 1) <= this.currentScanline) {\n            drawSprite0 = true;\n        }\n        if (drawSprite0) {\n            spriteX = oam[3];\n            spriteY = oam[0] + 1;\n            tileNum = oam[1];\n            //Select tile num from OAM byte 1 and index from CHRGrid already prepared\n            tile = this.nes.Mapper.getCHRGrid(this.spritePatTblAddr, tileNum);\n            tileRow = tile[this.currentScanline - spriteY];\n            for (var x = 0; x < 8; x++) {\n                pixelColorIndex = tileRow[x];\n                if (pixelColorIndex != 0) {\n                    if ((spriteX + x) != 255) {\n                        if ((this.renderBGLeftMost || this.renderSpritesLeftMost) && ((spriteX + x) >= 0 && (spriteX + x) < 8)) {\n\n                        }\n                        else {\n                            var currentBackgroundPixelColor = this.screenBuffer[spriteX + x + (this.currentScanline * 256)];\n                            //Sprite hit logic: non-transparent Sprite over non-transparent BG REGARDLESS of priority\n                            if (currentBackgroundPixelColor != 0) {\n                                //If current sprite is sprite 0 and sprite hit not already set in PPUSTATUS\n                                if (((this.ppuStatusBits & 0x40) == 0x00) && this.renderBackground) {\n                                    //set sprite 0 hit bit TODO: Other sprite hit conditions\n                                    this.ppuStatusBits = this.ppuStatusBits | 0x40;\n                                    this.sprite0Hit = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/ppu.js?");

/***/ }),

/***/ "./public/js/pulse.js":
/*!****************************!*\
  !*** ./public/js/pulse.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return pulse; });\n/*global Tone*/\nfunction pulse(nes) {\n    this.nes = nes;\n    this.Enabled = false;\n    this.doIrq = false;\n    this.channel = 0;\n    //Square wave channel VARs\n    this.volume = 0; //Square channel volume\n    this.sawEnvDisable = true; //Use Envelop or Constant volume\n    this.lenCounterDisable = false; //envelope loop / length counter halt\n    this.dutyCycle = 0; //Duty cycle of the wave\n    this.period = 0; //11 bit Period \n    this.envPeriod = 0x0F; //Envelop decay counter\n    this.periodLowBits = 0; //lower 8 bit period\n    this.periodHighBits = 0; //High 3 bit period\n    this.lenCounter = 0; //Len counter value\n    this.envVolume = 0; //Envelop value\n    this.envStartFlag = false;\n    this.dividerPeriod = 0;\n    this.dividerOriginalPeriod = 0;\n    this.decayLvlCount = 0;\n    this.envCounter = 0; //Counter to countdown to 0 from envelope period\n    this.inhibitInterrupt = true; //Inhibit the frame counter IR\n    this.sweepEnabled = false; //Enable Sweep\n    this.sweepDividerPeriod = 0; //Sweep divider Period\n    this.sweepNegate = 0;\n    this.sweepShiftCount = 0;\n    this.sweepCount = 0;\n    this.sweepReloadFlag = false;\n    this.currentSequence = 0;\n    this.outputValue = false;\n    this.sweepTargetPeriod = 0;\n    var dutyCycles = [\n        [0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 1, 1, 0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1, 0, 0, 0],\n        [1, 0, 0, 1, 1, 1, 1, 1]\n    ];\n\n    //calculate the current sequence value\n    this.calcSequence = function(duty, sequence) {\n        return dutyCycles[duty][sequence];\n    };\n\n    //Clocks the sequencer\n    this.clockSequencer = function() {\n        if (this.calcSequence(this.dutyCycle, this.currentSequence) == 1) {\n            this.outputValue = true;\n        }\n        else this.outputValue = false;\n        this.currentSequence++;\n        if (this.currentSequence == 8)\n            this.currentSequence = 0;\n    };\n\n    this.clockDecayLevelCounter = function() {\n        if (this.decayLvlCount == 0) {\n            if (this.lenCounterDisable) { //if loop flag set, reload the decay \n                this.decayLvlCount = 15;\n            }\n        }\n        else {\n            this.decayLvlCount--;\n        }\n    };\n\n    this.updateEnvelope = function() {\n        if (!this.envStartFlag) {\n            //Now clock divider\n            if (this.dividerPeriod == 0) { //Reload divider period\n                this.dividerPeriod = this.dividerOriginalPeriod;\n                //Now clock Decay level counter\n                this.clockDecayLevelCounter();\n            }\n            else {\n                this.dividerPeriod--;\n                //Now clock Decay level counter\n                this.clockDecayLevelCounter();\n            }\n        }\n        else {\n            this.envStartFlag = false; //Clear Start flag\n            this.decayLvlCount = 15; //Reload Decay level counter\n            this.dividerPeriod = this.dividerOriginalPeriod; //Reload divider period\n        }\n        // if (this.dividerOriginalPeriod > 0)\n        //     this.setVol(this.dividerOriginalPeriod - 1);\n        // else this.setVol(0);\n    };\n\n    this.updSweepAndLengthCounter = function() {\n        //Update Lenght Counter\n        if (!this.enabled) {\n            this.lenCounter = 0;\n        }\n        else if (!this.lenCounterDisable && this.lenCounter > 0) {\n            this.lenCounter--;\n        }\n        //Update Sweep\n        this.sweepTargetPeriod = 0;\n        //Divider has reached 0 do sweep now\n        if (this.sweepCount == 0) {\n            this.sweepCount = this.sweepDividerPeriod; //Relaod sweep divider count\n            this.sweepReloadFlag = false; //clear reload flag\n            var sweepChangeAmt = this.period >> this.sweepShiftCount;\n            if (this.sweepNegate == 0) { //Add sweep\n                this.sweepTargetPeriod = this.period + sweepChangeAmt;\n            }\n            else if (this.sweepNegate == 1) { //Negate sweep\n                if (this.channel == 1) {\n                    this.sweepTargetPeriod = this.period + (~sweepChangeAmt); //1's complement for pulse1 channel\n                }\n                else if (this.channel == 2) {\n                    this.sweepTargetPeriod = this.period - sweepChangeAmt; //2's complement for pulse2 channel\n                }\n            }\n            if (this.sweepEnabled) { //Adjust the sweep\n                this.period = this.sweepTargetPeriod;\n            }\n        }\n        else if (!this.sweepReloadFlag) {\n            this.sweepCount--;\n        }\n        if (this.sweepReloadFlag) {\n            this.sweepCount = this.sweepDividerPeriod; //Relaod sweep divider count\n            this.sweepReloadFlag = false; //clear reload flag\n        }\n    };\n\n    //Clock the sequencer after timer has counted down\n    this.clock = function() {\n        if (this.period <= 0) {\n            this.clockSequencer();\n            this.period = this.periodLowBits | (this.periodHighBits << 8) + 1;\n        }\n        else {\n            this.period--;\n        }\n    };\n\n    this.output = function() {\n        if ((this.outputValue) && (this.sweepTargetPeriod <= 0x7FF) && (this.period >= 0x08)) {\n            if (!this.lenCounterDisable && this.lenCounter <= 0)\n                return 0;\n            if (!this.sawEnvDisable) {\n                return this.decayLvlCount;\n            }\n            else {\n                return this.volume;\n            }\n        }\n        else return 0;\n        //     if (this.outputValue && this.enabled & this.period >= 0x08) {\n        //         return this.volume;\n        //     }\n        //     else return 0;\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/pulse.js?");

/***/ }),

/***/ "./public/js/triangle.js":
/*!*******************************!*\
  !*** ./public/js/triangle.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return triangle; });\n/*global Tone*/\nfunction triangle(nes) {\n    this.nes = nes;\n    this.Enabled = false;\n    this.lengthCounterTbl = [10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30];\n    this.volumeLkpTbl = [-40, -37, -34, -31, -28, -25, -22, -19, -16, -13, -10, -7, -4, -1, 2, 4];\n    this.doIrq = false;\n    this.channel = 0;\n\n    //Triangle wave channel VARs\n    this.controlFlag = false;\n    this.counterReload = 0;\n    this.timerLowBits = 0;\n    this.timerHighBits = 0;\n    this.lenCounterReloadFlag = false;\n    this.lenCounter = 0; //Len counter value\n    this.vol = 0; //channel volume\n\n\n    //Square 1 wave channel VARs\n    this.vol = 0; //Square 1 channel volume\n    this.sawEnvDisable = false; //Use Envelop or Constant volume\n    this.lenCounterDisable = false; //envelope loop / length counter halt\n    this.dutyCycle = 0; //Duty cycle of the wave\n    this.period = 0; //11 bit Period \n    this.envPeriod = 0x0F; //Envelop decay counter\n    this.periodLowBits = 0; //lower 8 bit period\n    this.periodHighBits = 0; //High 3 bit period\n    this.lenCounter = 0; //Len counter value\n    this.envVolume = 0; //Envelop value\n    this.frequency = 0; //Calculated frequency from period\n    this.envStartFlag = false;\n    this.dividerPeriod = 0;\n    this.dividerOriginalPeriod = 0;\n    this.decayLvlCount = 0;\n    this.envCounter = 0; //Counter to countdown to 0 from envelope period\n    this.inhibitInterrupt = true; //Inhibit the frame counter IR\n    this.playing = false;\n    this.sweepEnabled = false; //Enable Sweep\n    this.sweepDividerPeriod = 0; //Sweep divider Period\n    this.sweepNegate = 0;\n    this.sweepShiftCount = 0;\n    this.sweepCount = 0;\n    //Tony JS vars\n    // this.triangleOsc = new Tone.OmniOscillator(0, \"triangle\").toMaster().start();\n    // this.triangleOsc.fadeOut = 0.07;\n    // this.triangleOsc.width.value = 0.5;\n\n    this.calcDuty = function(duty) {\n        switch (duty) {\n            case 0:\n                return 0.125;\n            case 1:\n                return 0.25;\n            case 2:\n                return 0.5;\n            case 3:\n                return 0.75;\n        }\n    };\n\n    //If envelope is enabled set the current env value or else set the constant volume passed in\n    this.setVol = function(volume) {\n        if (this.decayLvlCount > 0xF || volume > 0xF) {\n            alert(\"volume higher than 0xF!!! Env Volume: \" + this.decayLvlCount + ' Constant volume: ' + volume);\n        }\n        if (!this.sawEnvDisable) {\n            this.vol = this.decayLvlCount;\n        }\n        else {\n            this.vol = volume;\n        }\n        this.triangleOsc.volume.value = this.volumeLkpTbl[this.vol];\n    };\n\n    this.clockDecayLevelCounter = function() {\n        if (this.decayLvlCount == 0) {\n            if (this.lenCounterDisable) { //if loop flag set, reload the decay \n                this.decayLvlCount = 15;\n            }\n        }\n        else {\n            this.decayLvlCount--;\n        }\n    };\n    // this.updateEnvelope = function() {\n    //     if (!this.envStartFlag) {\n    //         //Now clock divider\n    //         if (this.dividerPeriod == 0) { //Reload divider period\n    //             this.dividerPeriod = this.dividerOriginalPeriod;\n    //             //Now clock Decay level counter\n    //             this.clockDecayLevelCounter();\n    //         }\n    //         else {\n    //             this.dividerPeriod--;\n    //             //Now clock Decay level counter\n    //             this.clockDecayLevelCounter();\n    //         }\n    //     }\n    //     else {\n    //         this.envStartFlag = false; //Clear Start flag\n    //         this.decayLvlCount = 15; //Reload Decay level counter\n    //         this.dividerPeriod = this.dividerOriginalPeriod; //Reload divider period\n    //     }\n    //     this.setVol(this.dividerOriginalPeriod - 1);\n    // };\n\n    //return sound freq in Hz\n    this.calcFrequency = function(period) {\n        return this.nes.cpuFreq / (16 * (period + 1));\n    };\n\n    this.updSweepAndLengthCounter = function() {\n        //Update Lenght Counter\n        if (!this.enabled) {\n            this.lenCounter = 0;\n            //Silence channel\n            this.pulseOsc.mute = true;\n        }\n        else if (!this.lenCounterDisable && this.lenCounter > 0) {\n            this.lenCounter--;\n            //Silence Channel\n            if (this.lenCounter == 0) {\n                this.pulseOsc.mute = true;\n            }\n            else {\n                this.pulseOsc.mute = false;\n            }\n        }\n\n        //Update Sweep\n        //Muting\n        if (this.period < 0x08) {\n            this.pulseOsc.mute = true;\n        }\n        else {\n            this.pulseOsc.mute = false;\n        }\n        var sweepTargetPeriod = 0;\n        //Divider has reached 0 do sweep now\n        if (this.sweepCount == 0) {\n            this.sweepCount = this.sweepDividerPeriod; //Relaod sweep divider count\n            this.sweepReloadFlag = false; //clear reload flag\n            var sweepChangeAmt = this.period >> this.sweepShiftCount;\n            if (this.sweepNegate == 0) { //Add sweep\n                sweepTargetPeriod = this.period + sweepChangeAmt;\n            }\n            else if (this.sweepNegate == 1) { //Negate sweep\n                if (this.channel == 1) {\n                    sweepTargetPeriod = this.period + (~sweepChangeAmt); //1's complement for pulse1 channel\n                }\n                else if (this.channel == 2) {\n                    sweepTargetPeriod = this.period - sweepChangeAmt; //2's complement for pulse2 channel\n                }\n            }\n            if (this.sweepEnabled) { //Adjust the sweep\n                this.period = sweepTargetPeriod;\n                this.frequency = this.calcFrequency(this.period);\n                this.pulseOsc.frequency.value = this.frequency;\n            }\n        }\n        else if (!this.sweepReloadFlag) {\n            this.sweepCount--;\n        }\n        if (this.sweepReloadFlag) {\n            this.sweepCount = this.sweepDividerPeriod; //Relaod sweep divider count\n            this.sweepReloadFlag = false; //clear reload flag\n        }\n\n        //Muting\n        if (sweepTargetPeriod > 0x7FF) {\n            this.pulseOsc.mute = true;\n        }\n        else {\n            this.pulseOsc.mute = false;\n        }\n    };\n\n    this.updateLinearCounter = function() {\n        if (this.lenCounterReloadFlag) {\n\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/triangle.js?");

/***/ })

/******/ });
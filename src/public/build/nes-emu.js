!function(t){var n={};function e(a){if(n[a])return n[a].exports;var i=n[a]={i:a,l:!1,exports:{}};return t[a].call(i.exports,i,i.exports,e),i.l=!0,i.exports}e.m=t,e.c=n,e.d=function(t,n,a){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:a})},e.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s="./public/js/nes.js")}({"./node_modules/ringbufferjs/index.js":
/*!********************************************!*\
  !*** ./node_modules/ringbufferjs/index.js ***!
  \********************************************/
/*! no static exports found */function(module,exports){eval("/**\n * Expose `RingBuffer`.\n */\nmodule.exports = RingBuffer;\n\n/**\n * Initializes a new empty `RingBuffer` with the given `capacity`, when no\n * value is provided uses the default capacity (50).\n *\n * If provided, `evictedCb` gets run with any evicted elements.\n *\n * @param {capacity}\n * @param [evictedCb]\n * @return {RingBuffer}\n * @api public\n */\nfunction RingBuffer(capacity, evictedCb) {\n  this._elements = new Array(capacity || 50);\n  this._first = 0;\n  this._last = 0;\n  this._size = 0;\n  this._evictedCb = evictedCb;\n}\n\n/**\n * Returns the capacity of the ring buffer.\n *\n * @return {Number}\n * @api public\n */\nRingBuffer.prototype.capacity = function() {\n  return this._elements.length;\n};\n\n/**\n * Returns whether the ring buffer is empty or not.\n *\n * @return {Boolean}\n * @api public\n */\nRingBuffer.prototype.isEmpty = function() {\n  return this.size() === 0;\n};\n\n/**\n * Returns whether the ring buffer is full or not.\n *\n * @return {Boolean}\n * @api public\n */\nRingBuffer.prototype.isFull = function() {\n  return this.size() === this.capacity();\n};\n\n/**\n * Peeks at the top element of the queue.\n *\n * @return {Object}\n * @throws {Error} when the ring buffer is empty.\n * @api public\n */\nRingBuffer.prototype.peek = function() {\n  if (this.isEmpty()) throw new Error('RingBuffer is empty');\n\n  return this._elements[this._first];\n};\n\n/**\n * Peeks at multiple elements in the queue.\n *\n * @return {Array}\n * @throws {Error} when there are not enough elements in the buffer.\n * @api public\n */\nRingBuffer.prototype.peekN = function(count) {\n  if (count > this._size) throw new Error('Not enough elements in RingBuffer');\n\n  var end = Math.min(this._first + count, this.capacity());\n  var firstHalf = this._elements.slice(this._first, end);\n  if (end < this.capacity()) {\n    return firstHalf;\n  }\n  var secondHalf = this._elements.slice(0, count - firstHalf.length);\n  return firstHalf.concat(secondHalf);\n};\n\n/**\n * Dequeues the top element of the queue.\n *\n * @return {Object}\n * @throws {Error} when the ring buffer is empty.\n * @api public\n */\nRingBuffer.prototype.deq = function() {\n  var element = this.peek();\n\n  this._size--;\n  this._first = (this._first + 1) % this.capacity();\n\n  return element;\n};\n\n/**\n * Dequeues multiple elements of the queue.\n *\n * @return {Array}\n * @throws {Error} when there are not enough elements in the buffer.\n * @api public\n */\nRingBuffer.prototype.deqN = function(count) {\n  var elements = this.peekN(count);\n\n  this._size -= count;\n  this._first = (this._first + count) % this.capacity();\n\n  return elements;\n};\n\n/**\n * Enqueues the `element` at the end of the ring buffer and returns its new size.\n *\n * @param {Object} element\n * @return {Number}\n * @api public\n */\nRingBuffer.prototype.enq = function(element) {\n  this._end = (this._first + this.size()) % this.capacity();\n  var full = this.isFull()\n  if (full && this._evictedCb) {\n    this._evictedCb(this._elements[this._end]);\n  }\n  this._elements[this._end] = element;\n\n  if (full) {\n    this._first = (this._first + 1) % this.capacity();\n  } else {\n    this._size++;\n  }\n\n  return this.size();\n};\n\n/**\n * Returns the size of the queue.\n *\n * @return {Number}\n * @api public\n */\nRingBuffer.prototype.size = function() {\n  return this._size;\n};\n\n\n//# sourceURL=webpack:///./node_modules/ringbufferjs/index.js?")},"./public/js/apu.js":
/*!**************************!*\
  !*** ./public/js/apu.js ***!
  \**************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return apu; });\n/* harmony import */ var _pulse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pulse */ "./public/js/pulse.js");\n/* harmony import */ var _triangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triangle */ "./public/js/triangle.js");\n/* harmony import */ var _noise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noise */ "./public/js/noise.js");\n/* harmony import */ var ringbufferjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ringbufferjs */ "./node_modules/ringbufferjs/index.js");\n/* harmony import */ var ringbufferjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ringbufferjs__WEBPACK_IMPORTED_MODULE_3__);\n/*global performance*/\n//cycles per second = 1786830\n\n\n\n\n\n\nfunction apu(nes) {\n    this.nes = nes;\n    this.sqe1Enabled = false;\n    this.sq2Enabled = false;\n    this.triangleEnabled = false;\n    this.noiseEnabled = false;\n    this.dmcEnabled = false;\n    this.inhibitInterrupt = false;\n    this.seqMode = 0;\n    this.step = 0;\n    this.doIrq = false;\n    this.lengthCounterTbl = [10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30];\n    this.noisePeriodTbl = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068];\n    var pulse1Buffer = [];\n    var pulse2Buffer = [];\n    this.triangleBuffer = [];\n    this.noiseBuffer = [];\n    this.bufferLength = 1024;\n    this.outputBuffer = new ringbufferjs__WEBPACK_IMPORTED_MODULE_3___default.a(this.bufferLength * 10);\n    this.pulse1 = new _pulse__WEBPACK_IMPORTED_MODULE_0__["default"]();\n    this.pulse2 = new _pulse__WEBPACK_IMPORTED_MODULE_0__["default"]();\n    this.triangle1 = new _triangle__WEBPACK_IMPORTED_MODULE_1__["default"]();\n    this.noise1 = new _noise__WEBPACK_IMPORTED_MODULE_2__["default"]();\n    this.pulse1.channel = 1;\n    this.pulse2.channel = 2;\n\n    var pulseOverSamplingCycles = 0;\n    var triangleOverSamplingCycles = 0;\n    var overSamplingCycleRate = 20;\n    var sampleCycleRate = 41;\n    var samplingCycles = 0;\n    var clockCycles = 0;\n    var frameCycles = 0;\n    this.sampleCount = 0;\n    this.sampleTimerMax = 1000.0 / 44100.0;\n    this.cyclesPerFrame = 1786830;\n    var squareTable = new Array(31);\n    var triangleTable = new Array(203);\n    this.frameIRQ = false;\n\n    var initMixesLkpTables = function() {\n        squareTable[0] = 0;\n        for (var i = 1; i < 31; i++) {\n            squareTable[i] = 95.52 / ((8128 / i) + 100);\n        }\n        triangleTable[0] = 0;\n        for (var i = 1; i < 203; i++) {\n            triangleTable[i] = 163.67 / ((24329.0 / i) + 100);\n        }\n    };\n\n    this.init = function() {\n        var AudioContext = window.AudioContext || window.webkitAudioContext;\n        this.audioCtx = new AudioContext();\n        if (!window.AudioContext) {\n            if (!window.WebkitAudioContext) {\n                console.log("Could not initialize audio!");\n                return;\n            }\n            else {\n                this.audioCtx = new window.WebkitAudioContext();\n            }\n        }\n        else {\n            this.audioCtx = new window.AudioContext();\n        }\n        this.scriptNode = this.audioCtx.createScriptProcessor(this.bufferLength, 0, 1);\n        this.scriptNode.onaudioprocess = this.onaudioprocess;\n        this.scriptNode.connect(this.audioCtx.destination);\n        initMixesLkpTables();\n    };\n\n    // 0x4015\n    this.setAPUFlags = function(value) {\n        if (value & 0x01 == 1) {\n            this.pulse1.enabled = true;\n        }\n        else {\n            this.pulse1.enabled = false;\n            this.pulse1.lenCounter = 0;\n        }\n        if (value & 0x02 == 0x02) {\n            this.pulse2.enabled = true;\n        }\n        else {\n            this.pulse2.enabled = false;\n            this.pulse2.lenCounter = 0;\n        }\n        if (value & 0x04 == 0x04) {\n            this.triangle1.enabled = true;\n        }\n        else {\n            this.triangle1.enabled = false;\n            this.triangle1.lenCounter = 0;\n        }\n        if (value & 0x08 == 0x08) {\n            this.noise1.enabled = true;\n        }\n        else {\n            this.noise1.enabled = false;\n            this.noise1.lenCounter = 0;\n        }\n        if (value & 0x10 == 0x10) {\n            this.dmcEnabled = true;\n        }\n        else {\n            this.dmcEnabled = false;\n        }\n    };\n\n    //Square channel 1 methods\n    //0x4000\n    this.setSQ1_ENV = function(value) {\n        if ((value & 0x10) == 0x10) {\n            this.pulse1.sawEnvDisable = true; //use Volume for volume\n        }\n        else {\n            this.pulse1.sawEnvDisable = false; //use internal counter for volume\n        }\n        this.pulse1.volume = value & 0x0F; //Set volume \n        if ((value & 0x20) == 0x20) {\n            this.pulse1.lenCounterDisable = true; //disable Length Counter\n        }\n        else {\n            this.pulse1.lenCounterDisable = false; //use Length Counter\n        }\n        this.pulse1.dutyCycle = value >> 6; //set duty cycle\n    };\n\n    //Set the low 8 bits of the period\n    //0x4002\n    this.setSQ1_LO = function(value) {\n        this.pulse1.periodLowBits = value;\n        this.pulse1.period = this.pulse1.period & 0x700;\n        this.pulse1.period = this.pulse1.period | this.pulse1.periodLowBits;\n        this.pulse1.timerPeriod = this.pulse1.period;\n        this.pulse1.updateTargetPeriod();\n    };\n\n    //Set the high 3 bits of the period if lengh counter is enabled, get the\n    //counter value from the look up table\n    //convert the period in to frequency\n    //0x4003\n    this.setSQ1_HI = function(value) {\n        this.pulse1.periodHighBits = value & 0x07;\n        this.pulse1.period = this.pulse1.period & 0xFF;\n        this.pulse1.period = this.pulse1.period | (this.pulse1.periodHighBits << 8) + 1;\n        this.pulse1.timerPeriod = this.pulse1.period;\n        if (this.pulse1.enabled) {\n            this.pulse1.lenCounter = this.lengthCounterTbl[value >> 3];\n        }\n        this.pulse1.dividerPeriod = this.pulse1.volume + 1;\n        this.pulse1.currentSequence = 0; //restart Phase\n        this.pulse1.envStartFlag = true;\n        this.pulse1.updateTargetPeriod();\n    };\n\n    //0x4001\n    this.setSQ1_SWEEP = function(value) {\n        if ((value >> 7) == 1) {\n            this.pulse1.sweepEnabled = true;\n        }\n        else {\n            this.pulse1.sweepEnabled = false;\n        }\n        this.pulse1.sweepDividerPeriod = ((value & 0x70) >> 4) + 1;\n        this.pulse1.sweepNegate = (value & 0x08) >> 3;\n        this.pulse1.sweepShiftCount = value & 0x07;\n        this.pulse1.sweepReloadFlag = true;\n    };\n\n    //Square Channel 2 methods\n    this.setSQ2_ENV = function(value) {\n        this.pulse2.volume = value & 0x0F; //Set volume \n        if ((value & 0x10) == 0x10) {\n            this.pulse2.sawEnvDisable = true; //use Volume for volume\n        }\n        else {\n            this.pulse2.sawEnvDisable = false; //use internal counter for volume\n        }\n        if ((value & 0x20) == 0x20) {\n            this.pulse2.lenCounterDisable = true; //disable Length Counter\n        }\n        else {\n            this.pulse2.lenCounterDisable = false; //use Length Counter\n        }\n        this.pulse2.dutyCycle = value >> 6; //set duty cycle\n    };\n\n    this.setSQ2_LO = function(value) {\n        this.pulse2.periodLowBits = value;\n        this.pulse2.period = this.pulse2.period & 0x700;\n        this.pulse2.period = this.pulse2.period | this.pulse2.periodLowBits;\n        this.pulse2.timerPeriod = this.pulse2.period;\n        this.pulse2.updateTargetPeriod();\n    };\n\n    this.setSQ2_HI = function(value) {\n        this.pulse2.periodHighBits = value & 0x07;\n        this.pulse2.period = this.pulse2.period & 0xFF;\n        this.pulse2.period = this.pulse2.period | (this.pulse2.periodHighBits << 8);\n        this.pulse2.timerPeriod = this.pulse2.period;\n        if (this.pulse2.enabled) {\n            this.pulse2.lenCounter = this.lengthCounterTbl[value >> 3];\n        }\n        this.pulse2.dividerPeriod = this.pulse2.volume + 1; //Restart envelop\n        this.pulse1.currentSequence = 0;\n        this.pulse2.envStartFlag = true;\n        this.pulse2.updateTargetPeriod();\n    };\n\n    this.setSQ2_SWEEP = function(value) {\n        if ((value >> 7) == 1) {\n            this.pulse2.sweepEnabled = true;\n        }\n        else {\n            this.pulse2.sweepEnabled = false;\n        }\n        this.pulse2.sweepDividerPeriod = ((value & 0x70) >> 4) + 1;\n        // this.pulse2.sweepCount = this.pulse2.sweepDividerPeriod;\n        this.pulse2.sweepNegate = (value & 0x08) >> 3;\n        this.pulse2.sweepShiftCount = value & 0x07;\n        this.pulse2.sweepReloadFlag = true;\n    };\n\n    this.setTRIControl = function(value) {\n        if ((value >> 7) == 1) {\n            this.triangle1.controlFlag = true;\n        }\n        else {\n            this.triangle1.controlFlag = false;\n        }\n        this.triangle1.counterReload = value & 0x7F;\n    };\n\n    this.setTRI_LO = function(value) {\n        this.triangle1.periodLowBits = value & 0xFF;\n        this.triangle1.period = this.triangle1.period & 0x700;\n        this.triangle1.period = this.triangle1.period | this.triangle1.periodLowBits;\n    };\n\n    this.setTRI_HI = function(value) {\n        this.triangle1.periodHighBits = value & 0x07;\n        this.triangle1.period = this.triangle1.period & 0xFF;\n        this.triangle1.period = this.triangle1.period | (this.triangle1.periodHighBits << 8) + 1;\n        // if (this.triangle1.enabled)\n        this.triangle1.lenCounter = this.lengthCounterTbl[value >> 3];\n        this.triangle1.linearCounterReloadFlag = true;\n    };\n\n    //0x400C\n    this.setNoise_ENV = function(value) {\n        this.noise1.volume = value & 0x0F; //Set volume \n        if ((value & 0x10) == 0x10) {\n            this.noise1.sawEnvDisable = true; //use Volume for volume\n        }\n        else {\n            this.noise1.sawEnvDisable = false; //use internal counter for volume\n        }\n        if ((value & 0x20) == 0x20) {\n            this.noise1.lenCounterDisable = true; //disable Length Counter\n        }\n        else {\n            this.noise1.lenCounterDisable = false; //use Length Counter\n        }\n    };\n\n    //0x400E \n    this.setNoise_Period = function(value) {\n        if (value & 0x80 == 0x80) {\n            this.noise1.modeFlag = true;\n        }\n        else {\n            this.noise1.modeFlag = false;\n        }\n        this.noise1.originalPeriod = this.noisePeriodTbl[value & 0x0F];\n        this.noise1.period = this.noise1.originalPeriod;\n    };\n\n    //0x400F\n    this.setNoise_LenEnv = function(value) {\n        if (this.noise1.enabled)\n            this.noise1.lenCounter = this.lengthCounterTbl[value >> 3];\n        this.noise1.dividerPeriod = this.noise1.volume + 1; //Restart envelop\n        this.noise1.decayLvlCount = 15;\n    };\n\n    this.setFrameCounter = function(value) {\n        this.seqMode = value >> 7; //Sequencer mode\n        this.step = 0;\n        frameCycles = 0;\n        if ((value & 0x40) == 0x40) {\n            this.inhibitInterrupt = true;\n            this.frameIRQ = false;\n        }\n        else {\n            this.inhibitInterrupt = false;\n        }\n        if ((value & 0x80) == 0x80) {\n            this.updateEnvelopes();\n            this.updateLenCounters();\n            this.step = 0;\n        }\n        else {\n            this.step = 0;\n        }\n    };\n\n    this.onaudioprocess = (e) => {\n        // //Thansk Ben Firshman!!!\n        var channelData = e.outputBuffer.getChannelData(0);\n        var size = channelData.length;\n        if (this.outputBuffer.size() < size) {\n            this.nes.CPU.frame();\n            if (this.outputBuffer.size() < size) {\n                this.nes.CPU.frame();\n            }\n        }\n        try {\n            var samples = this.outputBuffer.deqN(size);\n        }\n        catch (e) {\n            // onBufferUnderrun failed to fill the buffer, so handle a real buffer\n            // underrun\n            // ignore empty buffers... assume audio has just stopped\n            var bufferSize = this.outputBuffer.size();\n            // if (bufferSize > 0) {\n            //     // console.log(`Buffer underrun (needed ${size}, got ${bufferSize})`);\n            // }\n            for (var j = 0; j < bufferSize; j++) {\n                channelData[j] = 0;\n            }\n            return;\n        }\n        for (var i = 0; i < size; i++) {\n            channelData[i] = samples[i];\n        }\n    };\n\n    this.sample = function() {\n        var pulse1Output = (pulse1Buffer.reduce((a, b) => a + b, 0));\n        if (pulse1Output != 0)\n            pulse1Output = Math.floor(pulse1Output / pulse1Buffer.length);\n        // if (pulse1Output < 0) pulse1Output = 0;\n        var pulse2Output = (pulse2Buffer.reduce((a, b) => a + b, 0));\n        if (pulse2Output != 0)\n            pulse2Output = Math.floor(pulse2Output / pulse2Buffer.length);\n        // if (pulse2Output < 0) pulse2Output = 0;\n        var triangleOutput = 0;\n        triangleOutput = (this.triangleBuffer.reduce((a, b) => a + b, 0));\n        if (triangleOutput != 0)\n            triangleOutput = Math.floor(triangleOutput / this.triangleBuffer.length);\n        // if (triangleOutput < 0) triangleOutput = 0;\n        var noiseOutput = (this.noiseBuffer.reduce((a, b) => a + b, 0));\n        if (noiseOutput != 0)\n            noiseOutput = Math.floor(noiseOutput / this.noiseBuffer.length);\n        // if (noiseOutput < 0) noiseOutput = 0;\n        pulse1Buffer = [];\n        pulse2Buffer = [];\n        this.triangleBuffer = [];\n        this.noiseBuffer = [];\n        var pulseOutput = 0;\n        if (triangleOutput != 0 || noiseOutput != 0) {\n            triangleOutput = 159.79 / (1 / ((triangleOutput / 8227) + (noiseOutput / 12241)) + 100);\n            // triangleOutput = triangleTable[3 * triangleOutput + 2 * noiseOutput + 0];\n            // triangleOutput = 0.00851 * triangleOutput + 0.00494 * noiseOutput;\n        }\n        if (pulse1Output != 0 || pulse2Output != 0) {\n            pulseOutput = 95.88 / ((8128 / (pulse1Output + pulse2Output)) + 100);\n            // pulseOutput = squareTable[pulse1Output + pulse2Output];\n        }\n        // output = this.squareTable[pulse1Output + pulse2Output];\n        var output = pulseOutput + triangleOutput;\n        // if (output < 0) output = 0;\n        this.pushToBuffer(output);\n    };\n\n    this.pushToBuffer = function(data) {\n        this.outputBuffer.enq(data);\n    };\n\n    this.run = function() {\n        clockCycles++;\n        if ((clockCycles & 1) == 0) {\n            this.pulse1.clock();\n            this.pulse2.clock();\n            clockCycles = 0;\n        }\n        this.triangle1.clock();\n        this.noise1.clock();\n        pulseOverSamplingCycles++;\n        if (pulseOverSamplingCycles >= overSamplingCycleRate) {\n            pulseOverSamplingCycles -= overSamplingCycleRate;\n            pulse1Buffer.push(this.pulse1.output());\n            pulse2Buffer.push(this.pulse2.output());\n        }\n        triangleOverSamplingCycles++;\n        if (triangleOverSamplingCycles >= overSamplingCycleRate) {\n            triangleOverSamplingCycles -= overSamplingCycleRate;\n            this.triangleBuffer.push(this.triangle1.output());\n            this.noiseBuffer.push(this.noise1.output());\n        }\n        samplingCycles++;\n        if (samplingCycles >= sampleCycleRate) {\n            samplingCycles -= sampleCycleRate;\n            this.sample();\n            this.sampleCount++;\n            if (sampleCycleRate == 40)\n                sampleCycleRate = 41;\n            else if (sampleCycleRate == 41)\n                sampleCycleRate = 40;\n        }\n\n        switch (frameCycles) {\n            case 7457:\n            case 14913:\n            case 22371:\n                this.doStep();\n                break;\n            case 29828:\n                if (this.seqMode == 0) {\n                    if (!this.inhibitInterrupt) {\n                        this.setFrameIRQ();\n                    }\n                }\n                break;\n            case 29829:\n                this.do4StepSeq();\n                break;\n            case 29830:\n                if (this.seqMode == 0) {\n                    frameCycles = 0;\n                    if (!this.inhibitInterrupt) {\n                        this.setFrameIRQ();\n                    }\n                    return;\n                }\n                break;\n            case 37281:\n                this.do5StepSeq();\n                break;\n            case 37282:\n                if (this.seqMode == 1) {\n                    frameCycles = 0;\n                    return;\n                }\n                break;\n        }\n        frameCycles++;\n    };\n\n    this.doStep = function() {\n        if (this.seqMode == 0) {\n            this.do4StepSeq();\n        }\n        else {\n            this.do5StepSeq();\n        }\n    };\n\n    this.setFrameIRQ = function() {\n        this.frameIRQ = true;\n        if ((this.nes.CPU.P >> 2) & 0x01 == 0x01) { //IRQ is enabled\n            if (!(this.nes.CPU.P & 0x04)) { //IRQ is enabled\n                this.nes.CPU.IRQToRun = 3;\n            }\n        }\n    };\n\n    this.updateEnvelopes = function() {\n        this.pulse1.updateEnvelope();\n        this.pulse2.updateEnvelope();\n        this.triangle1.updateLinearCounter();\n        this.noise1.updateEnvelope();\n    };\n\n    this.updateLenCounters = function() {\n        this.pulse1.updSweepAndLengthCounter();\n        this.pulse2.updSweepAndLengthCounter();\n        this.triangle1.updateLenCounter();\n        this.noise1.updateLenCounter();\n    };\n\n    this.do4StepSeq = function() {\n        if (this.seqMode == 0) {\n            this.updateEnvelopes();\n            if (this.step % 2 === 1) {\n                this.updateLenCounters();\n            }\n            this.step++;\n            if (this.step === 4) {\n                if (!this.inhibitInterrupt) {\n                    this.setFrameIRQ();\n                }\n                this.step = 0;\n            }\n        }\n    };\n\n    this.do5StepSeq = function() {\n        if (this.seqMode == 1) {\n            this.updateEnvelopes();\n            if (this.step % 2 === 0) {\n                this.updateLenCounters();\n            }\n            this.step++;\n            if (this.step === 4) {\n                this.step = 0;\n            }\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/apu.js?')},"./public/js/cpu.js":
/*!**************************!*\
  !*** ./public/js/cpu.js ***!
  \**************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return cpu; });\n\nfunction cpu(nes) {\n\tthis.nes = nes;\n\tthis.pc; // 16-Bit Program Counter\n\tthis.sp; // 8-Bit Stack Pointer\n\tthis.accumulator; // 8-Bit Accumulator\n\tthis.X; // 8-Bit Index Register X\n\tthis.Y; // 8-Bit Index Register Y\n\tthis.P; // Processor flag \n\tthis.elapsedCPUSyncCycles = 0;\n\tthis.totalelapsedCycles = 0;\n\tthis.totalCPUCyclesThisFrame = 0;\n\tthis.loggingEnabled = false;\n\t// Bit No.       7   6   5   4   3   2   1   0\n\t//\t\t\t\t S   V       B   D   I   Z   C\t\n\n\n\t//PPU related VARS\n\tthis.renderedScanLine = -1;\n\tthis.remainingCPUCycles = 0;\n\tthis.oddFrame = false;\n\tthis.oddCycle = false;\n\tthis.frameCount = 0;\n\tthis.cpuClockRemaining = 0;\n\tthis.elapsedCycles = 0;\n\tthis.skipFrame = false;\n\t//Reset CPU and initialize all registers and flags\n\tthis.reset = function() {\n\t\tthis.sp = 0xFD; //Adjusted for comparing with Nintedulator log\n\t\tthis.accumulator = 0x00;\n\t\tthis.X = 0x00;\n\t\tthis.Y = 0x00;\n\t\tthis.P = 0b00100100;\n\t\tthis.totalCpuCyclesDbg = 0;\n\t\tthis.currentOpcode = 0x00;\n\t\tthis.elapsedCycles = 0;\n\t\tvar vector1 = this.nes.MMU.getCpuMemVal(this.nes.MMU.startAddress);\n\t\tvar vector2 = this.nes.MMU.getCpuMemVal(this.nes.MMU.startAddress + 1);\n\t\tvector2 = vector2 << 8;\n\t\tthis.pc = vector2 | vector1;\n\t\t// this.pc = 0xC000;//Nestest\n\t};\n\n\t//CPU helper functions\n\tthis.setFlag = function(flagToSet) {\n\t\tswitch (flagToSet) {\n\t\t\tcase 0:\n\t\t\t\tthis.P = this.P & 0b11111110;\n\t\t\t\tthis.P = this.P | 0b00000001;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tthis.P = this.P & 0b11111101;\n\t\t\t\tthis.P = this.P | 0b00000010;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tthis.P = this.P | 0b00000100;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tthis.P = this.P & 0b11110111;\n\t\t\t\tthis.P = this.P | 0b00001000;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tthis.P = this.P & 0b10111111;\n\t\t\t\tthis.P = this.P | 0b01000000;\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\tthis.P = this.P & 0b01111111;\n\t\t\t\tthis.P = this.P | 0b10000000;\n\t\t\t\tbreak;\n\t\t}\n\t};\n\tthis.unsetFlag = function(flagToUnset) {\n\t\tswitch (flagToUnset) {\n\t\t\tcase 0:\n\t\t\t\tthis.P = this.P & 0b11111110;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tthis.P = this.P & 0b11111101;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tthis.P = this.P & 0b11110111;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tthis.P = this.P & 0b10111111;\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\tthis.P = this.P & 0b01111111;\n\t\t\t\tbreak;\n\t\t}\n\t};\n\tthis.calcFlags = function(arg, checkOverflow, newValue) {\n\n\t\t//check if overflow flag is to be determined\n\t\tif (checkOverflow) {\n\t\t\tif (~(this.accumulator ^ arg) & (this.accumulator ^ newValue) & 0x80)\n\t\t\t\tthis.setFlag(4);\n\t\t\telse\n\t\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\telse {\n\t\t\t//check for zero flag\n\t\t\tif (arg == null)\n\t\t\t\targ = this.accumulator;\n\t\t\tif (arg == 0x00)\n\t\t\t\tthis.setFlag(1);\n\t\t\telse\n\t\t\t\tthis.unsetFlag(1);\n\t\t\t//check for negative flag\t\n\t\t\tif ((arg >> 7) == 1)\n\t\t\t\tthis.setFlag(5);\n\t\t\telse\n\t\t\t\tthis.unsetFlag(5);\n\t\t}\n\t};\n\tthis.writeCarry = function(value) {\n\t\tif (value > 0xFF) {\n\t\t\tthis.setFlag(0);\n\t\t\tvalue = value & 0xFF;\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t\treturn value;\n\t\t}\n\t};\n\tthis.wrap8bit = function(operation, operand, input) {\n\t\tvar output = operand;\n\t\tswitch (operation) {\n\t\t\tcase 'increment':\n\t\t\t\t//Simple one off wrap around \t\n\t\t\t\tif (operand == 0xFF)\n\t\t\t\t\toutput = 0x00;\n\t\t\t\telse output = operand + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'decrement':\n\t\t\t\t//Simple one off wrap around\n\t\t\t\tif (operand == 0x00)\n\t\t\t\t\toutput = 0xFF;\n\t\t\t\telse output = operand - 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'sum':\n\t\t\t\t//Wrap around from zero and go upwards \n\t\t\t\tvar temp = operand + input;\n\t\t\t\tif (temp > 0xFF) {\n\t\t\t\t\toutput = 0x00 + (temp - 0xFF - 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput = temp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'subtract':\n\t\t\t\t//Wrap around from FF and go downwards\n\t\t\t\tif (input > operand) {\n\t\t\t\t\toutput = 0xFF - (input - operand - 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput = operand - input;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn output;\n\t};\n\tthis.to2sComplement = function(val) {\n\t\tif (val == 128)\n\t\t\treturn -128;\n\t\telse if (val >= 129 && val <= 255)\n\t\t\treturn val - 256;\n\t\telse return val;\n\t};\n\tthis.toSigned8bit = function(val) {\n\t\tif (val == -128)\n\t\t\treturn 128;\n\t\telse if (val >= 0 && val <= 127)\n\t\t\treturn val;\n\t\telse return val + 256;\n\t};\n\tthis.pushToStack = function(value) {\n\t\tthis.nes.MMU.setCpuMemVal((0x100 + this.sp), (value));\n\t\tif (this.sp == 0x00)\n\t\t\tthis.sp = 0xFF;\n\t\telse\n\t\t\tthis.sp--;\n\t};\n\tthis.popFromStack = function() {\n\t\tif (this.sp == 0xFF)\n\t\t\tthis.sp = 0x00;\n\t\telse\n\t\t\tthis.sp++;\n\t\tvar value = this.nes.MMU.getCpuMemVal(0x100 + this.sp);\n\t\treturn value;\n\t};\n\tthis.calcOffset = function(param) {\n\t\tif (param > 0x7F) {\n\t\t\tparam = param ^ 0b11111111;\n\t\t\tparam++;\n\t\t\tparam = 0 - param;\n\t\t}\n\t\treturn param;\n\t};\n\tthis.compareValsAndSetNegative = function(val1, val2) {\n\t\t//Turns out compare instructions do unsigned comparison :(\n\t\tvar temp = val1 - val2;\n\t\tif (((temp >> 7) & 1) == 1)\n\t\t\tthis.setFlag(5);\n\t\telse\n\t\t\tthis.unsetFlag(5);\n\n\t\tif (val1 > val2) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (val1 == val2) {\n\t\t\tthis.unsetFlag(5);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (val1 < val2) {\n\t\t\treturn -1;\n\t\t}\n\t};\n\tvar printLog = function() {\n\t\tvar line = \"\";\n\t\tfor (var i = 0; i < log.length; i++) {\n\t\t\tline += log[i] + \" \";\n\t\t}\n\t\tconsole.log(line);\n\t};\n\t//Opcode implementaions\n\n\tvar vector1 = 0,\n\t\tvector2 = 0;\n\tthis.serveISR = function(interrupt) {\n\t\tswitch (interrupt) {\n\t\t\tcase 'NMI':\n\t\t\t\tvector1 = this.nes.MMU.getCpuMemVal(0xFFFA);\n\t\t\t\tvector2 = this.nes.MMU.getCpuMemVal(0xFFFA + 1);\n\t\t\t\tvector2 = vector2 << 8;\n\t\t\t\t//push pc to stack\n\t\t\t\tthis.pushToStack((this.pc & 0xFF00) >> 8); //push high byte\n\t\t\t\tthis.pushToStack(this.pc & 0x00FF); //push low byte\n\t\t\t\t//push processor status to stack\n\t\t\t\tthis.pushToStack(this.P);\n\t\t\t\tthis.pc = vector2 | vector1;\n\t\t\t\tthis.elapsedCycles += 7;\n\t\t\t\tbreak;\n\t\t\tcase 'BRK':\n\t\t\t\tvector1 = this.nes.MMU.getCpuMemVal(0xFFFE);\n\t\t\t\tvector2 = this.nes.MMU.getCpuMemVal(0xFFFE + 1);\n\t\t\t\tvector2 = vector2 << 8;\n\t\t\t\t//push pc to stack\n\t\t\t\tthis.pushToStack((this.pc & 0xFF00) >> 8); //push high byte\n\t\t\t\tthis.pushToStack(this.pc & 0x00FF); //push low byte\n\n\t\t\t\t//Set the Break flag \n\t\t\t\tthis.P = this.P & 0b11101111;\n\t\t\t\tthis.P = this.P | 0b00010000;\n\t\t\t\tthis.P = this.P & 0b11011111;\n\t\t\t\tthis.P = this.P | 0b00100000;\n\t\t\t\t//set unused flag\n\t\t\t\t//push processor status to stack\n\t\t\t\tthis.pushToStack(this.P);\n\t\t\t\t//Set the I flag\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tthis.P = this.P | 0b00000100;\n\t\t\t\tthis.pc = vector2 | vector1;\n\t\t\t\tbreak;\n\t\t\tcase 'IRQ':\n\t\t\t\tvector1 = this.nes.MMU.getCpuMemVal(0xFFFE);\n\t\t\t\tvector2 = this.nes.MMU.getCpuMemVal(0xFFFE + 1);\n\t\t\t\tvector2 = vector2 << 8;\n\t\t\t\t//push pc to stack\n\t\t\t\tthis.pushToStack((this.pc & 0xFF00) >> 8); //push high byte\n\t\t\t\tthis.pushToStack(this.pc & 0x00FF); //push low byte\n\t\t\t\t//set bit 5 & 4 to 10\n\t\t\t\tvar tempFlag = this.P & 0b11001111;\n\t\t\t\ttempFlag = tempFlag | 0b00100000;\n\t\t\t\t//push processor status to stack\n\t\t\t\tthis.pushToStack(tempFlag);\n\t\t\t\t// //Set the Break flag \n\t\t\t\t//Set the I flag\n\t\t\t\tthis.P = this.P & 0b11111011;\n\t\t\t\tthis.P = this.P | 0b00000100;\n\t\t\t\tthis.pc = vector2 | vector1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\t};\n\n\tthis.doNMI = false;\n\tthis.suppressNMI = false;\n\n\tthis.clockCPU = function() {\n\t\tif (this.cpuClockRemaining <= 0) {\n\t\t\tthis.currentOpcode = this.nes.MMU.getCpuMemVal(this.pc);\n\t\t\tthis.elapsedCycles = 0;\n\t\t\tthis.decodeInstruction();\n\t\t\tthis.cpuClockRemaining = this.elapsedCycles;\n\t\t}\n\t\tthis.cpuClockRemaining--;\n\t\tif (this.cpuClockRemaining <= 0) {\n\t\t\tif (!this.suppressNMI && this.doNMI) {\n\t\t\t\tthis.elapsedCycles = 0;\n\t\t\t\tthis.serveISR('NMI');\n\t\t\t\tthis.cpuClockRemaining += this.elapsedCycles;\n\t\t\t\tthis.suppressNMI = false;\n\t\t\t\tthis.doNMI = false;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.clockAPU = function() {\n\t\tthis.nes.APU.run();\n\t};\n\n\tthis.run = function() {\n\t\tthis.totalCPUCyclesThisFrame = 0;\n\t\tthis.frameCompleted = false;\n\t\tthis.renderedScanline = 0;\n\t\tif (this.nes.MMU.chrRamWritten) {\n\t\t\tthis.nes.Mapper.reRenderCHR();\n\t\t}\n\t\twhile (!this.frameCompleted) {\n\t\t\t// if ((this.P >> 2) & 0x01 == 0x01) { //IRQ is enabled\n\t\t\t// \tif (this.nes.APU.doIrq) {\n\t\t\t// \t\tthis.elapsedCycles = 0;\n\t\t\t// \t\tthis.serveISR('IRQ');\n\t\t\t// \t\tthis.cpuClockRemaining += this.elapsedCycles;\n\t\t\t// \t\tthis.nes.APU.doIrq = false;\n\t\t\t// \t}\n\t\t\t// }\n\t\t\tif (this.oddFrame) {\n\t\t\t\tif (this.nes.MMU.OAMDMAwritten) {\n\t\t\t\t\tthis.cpuClockRemaining += 514;\n\t\t\t\t\tthis.nes.MMU.OAMDMAwritten = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.nes.MMU.OAMDMAwritten) {\n\t\t\t\t\tthis.cpuClockRemaining += 513;\n\t\t\t\t\tthis.nes.MMU.OAMDMAwritten = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.clockCPU();\n\t\t\t// this.clockAPU();\n\t\t\t//TODO: Check additional cycles after frame completed\n\t\t\tthis.clockPPU();\n\t\t\tthis.clockPPU();\n\t\t\tthis.clockPPU();\n\n\t\t\t// for (var i = 0; i < 3; i++) {\n\t\t\t// \t// this.clockPPU();\n\t\t\t// \tthis.fakeClockPPU();\n\t\t\t// \tif (this.frameCompleted)\n\t\t\t// \t\tbreak;\n\t\t\t// }\n\t\t\t// for (var i = 0; i < 3; i++) {\n\t\t\t// \tthis.fakeClockPPU();\n\t\t\t// \tif (this.frameCompleted)\n\t\t\t// \t\tbreak;\n\t\t\t// }\n\n\t\t\tthis.totalCPUCyclesThisFrame++;\n\t\t}\n\t\tthis.oddFrame = !this.oddFrame;\n\t\treturn this.totalCPUCyclesThisFrame;\n\t};\n\n\tthis.scanline_complete = false;\n\t// var testClock = 0;\n\n\t//----------------------xxxx------------------------------\n\n\n\n\n\n\t//New cycle accurate behavior below TODO: New stack behavior\n\tthis.BRK = function() {\n\t\tthis.memoryRead(0, 0);\n\t\tthis.memoryWrite(2, 0, (this.pc & 0xFF00) >> 8);\n\t\tthis.memoryWrite(2, 0, this.pc & 0x00FF);\n\t\t//Set the Break flag \n\t\tthis.P = this.P & 0b11101111;\n\t\tthis.P = this.P | 0b00010000;\n\t\tthis.P = this.P & 0b11011111;\n\t\tthis.P = this.P | 0b00100000;\n\t\tthis.memoryWrite(2, 0, this.P);\n\t\t//Set the I flag\n\t\tthis.P = this.P & 0b11111011;\n\t\tthis.P = this.P | 0b00000100;\n\t\tvector1 = this.memoryRead(4, 0xFFFE);\n\t\tvector2 = this.memoryRead(4, 0xFFFE + 1);\n\t\tvector2 <<= 8;\n\t\tthis.pc = vector2 | vector1;\n\t};\n\tthis.NMI = function() {\n\t\tthis.memoryRead(4, this.PC);\n\t\tthis.memoryRead(4, this.PC);\n\t\t//push pc to stack\n\t\tthis.memoryWrite(2, 0, (this.pc & 0xFF00) >> 8);\n\t\tthis.memoryWrite(2, 0, this.pc & 0x00FF);\n\t\t//push processor status to stack\n\t\tthis.memoryWrite(2, 0, this.P);\n\t\tvector1 = this.memoryRead(4, 0xFFFA);\n\t\tvector2 = this.memoryRead(4, 0xFFFA + 1);\n\t\tvector2 <<= 8;\n\t\tthis.pc = vector2 | vector1;\n\t\tthis.IRQToRun = 0;\n\t};\n\tthis.IRQ = function() {\n\t\tthis.memoryRead(4, this.PC);\n\t\tthis.memoryRead(4, this.PC);\n\t\t//push pc to stack\n\t\tthis.memoryWrite(2, 0, (this.pc & 0xFF00) >> 8);\n\t\tthis.memoryWrite(2, 0, this.pc & 0x00FF);\n\t\t//set bit 5 & 4 to 10\n\t\tvar tempFlag = this.P & 0b11001111;\n\t\ttempFlag = tempFlag | 0b00100000;\n\t\tthis.memoryWrite(2, 0, tempFlag);\n\t\t//Set the I flag\n\t\tthis.P = this.P & 0b11111011;\n\t\tthis.P = this.P | 0b00000100;\n\t\tvector1 = this.memoryRead(4, 0xFFFE);\n\t\tvector2 = this.memoryRead(4, 0xFFFE + 1);\n\t\tvector2 <<= 8;\n\t\tthis.pc = vector2 | vector1;\n\t\tthis.IRQToRun = 0;\n\t};\n\n\tthis.RTI = function() {\n\t\tthis.memoryRead(4, this.pc);\n\t\tthis.memoryRead(1, 0);\n\t\tvar temp = this.memoryRead(2, 0);\n\t\tif ((temp & 1) === 1)\n\t\t\tthis.setFlag(0);\n\t\telse this.unsetFlag(0);\n\n\t\tif ((temp & 0b00000010) === 0b00000010)\n\t\t\tthis.setFlag(1);\n\t\telse this.unsetFlag(1);\n\n\t\tif ((temp & 0b00000100) == 0b00000100)\n\t\t\tthis.setFlag(2);\n\t\telse this.unsetFlag(2);\n\n\t\tif ((temp & 0b00001000) == 0b00001000)\n\t\t\tthis.setFlag(3);\n\t\telse this.unsetFlag(3);\n\n\t\tif ((temp & 0b01000000) == 0b01000000)\n\t\t\tthis.setFlag(4);\n\t\telse this.unsetFlag(4);\n\n\t\tif ((temp & 0b10000000) == 0b10000000)\n\t\t\tthis.setFlag(5);\n\t\telse this.unsetFlag(5);\n\n\t\tvar lowByte = this.memoryRead(2, 0);\n\t\tvar highByte = this.memoryRead(2, 0);\n\t\tthis.pc = (highByte << 8) | lowByte;\n\t};\n\tthis.RTS = function() {\n\t\tthis.memoryRead(4, this.pc);\n\t\tthis.memoryRead(1, 0);\n\t\tvar lowByte = this.memoryRead(2, 0);\n\t\tvar highByte = this.memoryRead(2, 0);\n\t\tthis.pc = ((highByte << 8) | lowByte);\n\t\tthis.memoryWrite(0, 0, 0);\n\t};\n\n\n\tthis.TXS = function() {\n\t\tthis.sp = this.X;\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.TSX = function() {\n\t\tthis.X = this.sp;\n\t\tthis.calcFlags(this.X, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.PHA = function() {\n\t\tthis.memoryRead(1, 0);\n\t\tthis.memoryWrite(2, 0, this.accumulator);\n\t};\n\tthis.PHP = function() {\n\t\tthis.memoryRead(1, 0);\n\t\tvar temp = this.P;\n\t\ttemp = temp & 0b11101111;\n\t\ttemp = temp | 0b00110000;\n\t\tthis.memoryWrite(2, 0, temp);\n\t};\n\tthis.PLA = function() {\n\t\tthis.memoryRead(1, 0);\n\t\tthis.memoryWrite(1, 0, 0);\n\t\tthis.accumulator = this.memoryRead(2, 0);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.PLP = function() {\n\t\tthis.memoryRead(1, 0);\n\t\tthis.memoryWrite(1, 0, 0);\n\t\tvar temp = this.memoryRead(2);\n\t\tif ((temp & 0b00000001) === 1)\n\t\t\tthis.setFlag(0);\n\t\telse this.unsetFlag(0);\n\n\t\tif ((temp & 0b00000010) == 0b00000010)\n\t\t\tthis.setFlag(1);\n\t\telse this.unsetFlag(1);\n\n\t\tif ((temp & 0b00000100) == 0b00000100)\n\t\t\tthis.setFlag(2);\n\t\telse this.unsetFlag(2);\n\n\t\tif ((temp & 0b00001000) == 0b00001000)\n\t\t\tthis.setFlag(3);\n\t\telse this.unsetFlag(3);\n\n\t\tif ((temp & 0b01000000) == 0b01000000)\n\t\t\tthis.setFlag(4);\n\t\telse this.unsetFlag(4);\n\n\t\tif ((temp & 0b10000000) == 0b10000000)\n\t\t\tthis.setFlag(5);\n\t\telse this.unsetFlag(5);\n\t};\n\n\tthis.TAX = function() {\n\t\tthis.X = this.accumulator;\n\t\tthis.calcFlags(this.X, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.TXA = function() {\n\t\tthis.accumulator = this.X;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.DEX = function() {\n\t\tthis.X = this.wrap8bit('decrement', this.X, null);\n\t\tthis.calcFlags(this.X, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.INX = function() {\n\t\tthis.X = this.wrap8bit('increment', this.X, null);\n\t\tthis.calcFlags(this.X, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.TAY = function() {\n\t\tthis.Y = this.accumulator;\n\t\tthis.calcFlags(this.Y, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.TYA = function() {\n\t\tthis.accumulator = this.Y;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.DEY = function() {\n\t\tthis.Y = this.wrap8bit('decrement', this.Y, null);\n\t\tthis.calcFlags(this.Y, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.INY = function() {\n\t\tthis.Y = this.wrap8bit('increment', this.Y, null);\n\t\tthis.calcFlags(this.Y, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\n\tthis.CLC = function() {\n\t\tthis.unsetFlag(0);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.SEC = function() {\n\t\tthis.setFlag(0);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.CLI = function() {\n\t\tthis.unsetFlag(2);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.SEI = function() {\n\t\tthis.setFlag(2);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.CLV = function() {\n\t\tthis.unsetFlag(4);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.CLD = function() {\n\t\tthis.unsetFlag(3);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.SED = function() {\n\t\tthis.setFlag(3);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\n\t//FIXME\n\tthis.JSR_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\t//Transfer next instruction - 1 point to stack\n\t\tthis.memoryWrite(2, 0, (this.pc - 1) >> 8);\n\t\tthis.memoryWrite(2, 0, (this.pc - 1) & 0x00FF);\n\t\tthis.memoryRead(1, 0);\n\t\tthis.pc = param;\n\t};\n\n\tthis.JMP_A = function() {\n\t\tvar temp = 0;\n\t\ttemp |= this.memoryRead(0, 0) & 0x00FF;\n\t\ttemp |= this.memoryRead(0, 0) << 8;\n\t\tthis.pc = temp;\n\t};\n\tthis.JMP_I = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar lowerByte, higherByte;\n\t\tif (param1 == 0xFF) {\n\t\t\tlowerByte = param;\n\t\t\thigherByte = param2 | 0x00;\n\t\t}\n\t\telse {\n\t\t\tlowerByte = param;\n\t\t\thigherByte = param2 | (param1 + 1);\n\t\t}\n\t\tthis.pc = (this.memoryRead(4, higherByte) << 8) | this.memoryRead(4, lowerByte);\n\t};\n\n\tthis.BPL = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif ((this.P >> 7) == 0) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\tthis.BMI = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif ((this.P >> 7) == 1) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\tthis.BVC = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif (((this.P >> 6) & 0x01) == 0) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\tthis.BVS = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif (((this.P >> 6) & 0x01) == 1) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\tthis.BCC = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif ((this.P & 0x01) == 0) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\tthis.BCS = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif ((this.P & 0x01) == 1) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\tthis.BNE = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif (((this.P >> 1) & 0x01) == 0) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\tthis.BEQ = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar offset = this.calcOffset(param);\n\t\tif (((this.P >> 1) & 0x01) == 1) {\n\t\t\tif ((this.pc >> 8) != ((this.pc + offset) >> 8))\n\t\t\t\tthis.memoryRead(4, this.pc);\n\t\t\tthis.pc += offset;\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\n\tthis.LDA_I = function() {\n\t\tthis.accumulator = this.memoryRead(0, 0);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LDA_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\t// this.accumulator = this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[param];\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LDA_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[param];\n\t\t// this.accumulator = this.memoryRead(4, param);\n\t\tthis.accumulator += this.X;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]; //this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LDA_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LDA_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar tempEffAddr = param2 | temp;\n\t\tif (tempEffAddr > 0xFFFF)\n\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\tthis.accumulator = this.memoryRead(4, tempEffAddr);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\ttempEffAddr = param + this.X;\n\t\t\tif (tempEffAddr > 0xFFFF)\n\t\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\t\tthis.accumulator = this.memoryRead(4, tempEffAddr);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LDA_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar tempEffAddr = param2 | temp;\n\t\tif (tempEffAddr > 0xFFFF)\n\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\tthis.accumulator = this.memoryRead(4, tempEffAddr);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\ttempEffAddr = param + this.Y;\n\t\t\tif (tempEffAddr > 0xFFFF)\n\t\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\t\tthis.accumulator = this.memoryRead(4, tempEffAddr);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LDA_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.accumulator = this.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.memoryRead(4, index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LDA_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tthis.accumulator = this.memoryRead(4, index2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tthis.accumulator = this.memoryRead(4, (index2 | index1) + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.LDX_I = function() {\n\t\tthis.X = this.memoryRead(0, 0);\n\t\tthis.calcFlags(this.X, false, null);\n\t};\n\tthis.LDX_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.X = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.calcFlags(this.X, false, null);\n\t};\n\tthis.LDX_Z_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.X = this.nes.MMU.cpuMem[param] + this.Y; //this.memoryRead(4, param) + this.Y;\n\t\tthis.clockUnits();\n\t\tthis.X = this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.Y)]; // this.memoryRead(4, this.wrap8bit('sum', param, this.Y));\n\t\tthis.calcFlags(this.X, false, null);\n\t};\n\tthis.LDX_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.X = this.memoryRead(4, param);\n\t\tthis.calcFlags(this.X, false, null);\n\t};\n\tthis.LDX_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.X = this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.X = this.memoryRead(4, param + this.Y);\n\t\t}\n\t\tthis.calcFlags(this.X, false, null);\n\t};\n\n\tthis.LDY_I = function() {\n\t\tthis.Y = this.memoryRead(0, 0);\n\t\tthis.calcFlags(this.Y, false, null);\n\t};\n\tthis.LDY_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.Y = this.memoryRead(4, param);\n\t\tthis.Y = this.nes.MMU.cpuMem[param];\n\t\tthis.calcFlags(this.Y, false, null);\n\t};\n\tthis.LDY_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.Y = this.nes.MMU.cpuMem[param] + this.X; //this.memoryRead(4, param) + this.X;\n\t\tthis.clockUnits();\n\t\tthis.Y = this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]; //this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(this.Y, false, null);\n\t};\n\tthis.LDY_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0)\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.Y = this.memoryRead(4, param);\n\t\tthis.calcFlags(this.Y, false, null);\n\t};\n\tthis.LDY_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tthis.Y = this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.Y = this.memoryRead(4, param + this.X);\n\t\t}\n\t\tthis.calcFlags(this.Y, false, null);\n\t};\n\n\tthis.STA_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryWrite(3, param, this.accumulator);\n\t\tthis.nes.MMU.cpuMem[param] = this.accumulator;\n\t};\n\tthis.STA_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param) + this.X;\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)] = this.accumulator;\n\t\t// this.memoryWrite(3, this.wrap8bit('sum', param, this.X), this.accumulator);\n\t};\n\tthis.STA_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.memoryWrite(3, param, this.accumulator);\n\t};\n\tthis.STA_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar tempEffAddr = param2 | temp;\n\t\tif (tempEffAddr > 0xFFFF)\n\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\tthis.memoryRead(4, tempEffAddr);\n\t\tvar param = param2 | param1;\n\t\ttempEffAddr = param + this.X;\n\t\tif (tempEffAddr > 0xFFFF)\n\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\tthis.memoryWrite(3, tempEffAddr, this.accumulator);\n\t};\n\tthis.STA_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar tempEffAddr = param2 | temp;\n\t\tif (tempEffAddr > 0xFFFF)\n\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\tthis.memoryRead(4, tempEffAddr);\n\t\tvar param = param2 | param1;\n\t\ttempEffAddr = param + this.Y;\n\t\tif (tempEffAddr > 0xFFFF)\n\t\t\ttempEffAddr = tempEffAddr - (0xFFFF + 1);\n\t\tthis.memoryWrite(3, tempEffAddr, this.accumulator);\n\t};\n\tthis.STA_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.memoryWrite(3, index2 | index1, this.accumulator);\n\t};\n\tthis.STA_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tthis.memoryRead(4, index2 | temp);\n\t\tthis.memoryWrite(3, (index2 | index1) + this.Y, this.accumulator);\n\t};\n\n\tthis.STX_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = this.X;\n\t\t// this.memoryWrite(3, param, this.X);\n\t};\n\tthis.STX_Z_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param) + this.Y;\n\t\tthis.clockUnits();\n\t\t// this.memoryWrite(3, this.wrap8bit('sum', param, this.Y), this.X);\n\t\tthis.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.Y)] = this.X;\n\t};\n\tthis.STX_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.memoryWrite(3, param, this.X);\n\t};\n\n\tthis.STY_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryWrite(3, param, this.Y);\n\t\tthis.nes.MMU.cpuMem[param] = this.Y;\n\t};\n\tthis.STY_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param) + this.X;\n\t\t// this.memoryWrite(3, this.wrap8bit('sum', param, this.X), this.Y);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)] = this.Y;\n\t};\n\tthis.STY_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.memoryWrite(3, param, this.Y);\n\t};\n\n\tthis.AND_I = function() {\n\t\tthis.accumulator &= this.memoryRead(0, 0);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.AND_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.accumulator &= this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.AND_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar temp = this.accumulator;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.accumulator += this.X;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = temp & this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]; //this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.AND_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator &= this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.AND_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator &= this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.accumulator = tempAcc & this.memoryRead(4, param + this.X);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.AND_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator &= this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.accumulator = tempAcc & this.memoryRead(4, param + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.AND_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator = this.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 <<= 8;\n\t\tthis.accumulator = tempAcc & this.memoryRead(4, index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.AND_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator &= this.memoryRead(4, index2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tthis.accumulator = tempAcc & this.memoryRead(4, (index2 | index1) + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.EOR_I = function() {\n\t\tthis.accumulator ^= this.memoryRead(0, 0);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.EOR_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.accumulator ^= this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.EOR_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar temp = this.accumulator;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.accumulator += this.X;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = temp ^ this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]; //this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.EOR_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator ^= this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.EOR_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator ^= this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.accumulator = tempAcc ^ this.memoryRead(4, param + this.X);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.EOR_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator ^= this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.accumulator = tempAcc ^ this.memoryRead(4, param + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.EOR_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator = this.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 <<= 8;\n\t\tthis.accumulator = tempAcc ^ this.memoryRead(4, index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.EOR_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator ^= this.memoryRead(4, index2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tthis.accumulator = tempAcc ^ this.memoryRead(4, (index2 | index1) + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.ORA_I = function() {\n\t\tthis.accumulator |= this.memoryRead(0, 0);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ORA_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tthis.accumulator |= this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ORA_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar temp = this.accumulator;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.accumulator += this.X;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = temp | this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]; //this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ORA_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator |= this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ORA_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator |= this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.accumulator = tempAcc | this.memoryRead(4, param + this.X);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ORA_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator |= this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.accumulator = tempAcc | this.memoryRead(4, param + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ORA_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator = this.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 <<= 8;\n\t\tthis.accumulator = tempAcc | this.memoryRead(4, index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ORA_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator |= this.memoryRead(4, index2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tthis.accumulator = tempAcc | this.memoryRead(4, (index2 | index1) + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.ADC_I = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar arg = param;\n\t\tvar temp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ADC_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar arg = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tvar temp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ADC_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.accumulator += this.X;\n\t\tthis.clockUnits();\n\t\tvar arg = this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]; //this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar temp = this.to2sComplement(tempAcc) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse this.unsetFlag(4);\n\t\tthis.accumulator = this.writeCarry(tempAcc + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ADC_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.memoryRead(4, param);\n\t\tvar temp = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse this.unsetFlag(4);\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ADC_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar arg = this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\targ = this.memoryRead(4, param + this.X);\n\t\t}\n\t\tvar tempResult = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (tempResult < -128 || tempResult > 127) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse this.unsetFlag(4);\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ADC_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 <<= 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar arg = this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\targ = this.memoryRead(4, param + this.Y);\n\t\t}\n\t\tvar tempResult = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (tempResult < -128 || tempResult > 127) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse this.unsetFlag(4);\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ADC_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator = this.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar arg = this.memoryRead(4, index2 | index1);\n\t\tvar temp = this.to2sComplement(tempAcc) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (temp < -128 || temp > 127) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse this.unsetFlag(4);\n\t\tthis.accumulator = this.writeCarry(tempAcc + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ADC_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tvar arg = this.memoryRead(4, index2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\targ = this.memoryRead(4, (index2 | index1) + this.Y);\n\t\t}\n\t\tvar tempResult = this.to2sComplement(this.accumulator) + this.to2sComplement(arg) + (this.P & 0x01);\n\t\tif (tempResult < -128 || tempResult > 127) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse this.unsetFlag(4);\n\t\tthis.accumulator = this.writeCarry(this.accumulator + arg + (this.P & 0x01));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.SBC_I = function() {\n\t\tvar arg = this.memoryRead(0, 0);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SBC_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar arg = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SBC_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.clockUnits();\n\t\tthis.accumulator = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.accumulator += this.X;\n\t\tthis.clockUnits();\n\t\tvar arg = this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]; //this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar temp = tempAcc - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((tempAcc ^ temp) & 0x80) !== 0 &&\n\t\t\t((tempAcc ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SBC_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar arg = this.memoryRead(4, param);\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SBC_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar arg = this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\targ = this.memoryRead(4, param + this.X);\n\t\t}\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SBC_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar arg = this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\targ = this.memoryRead(4, param + this.Y);\n\t\t}\n\t\ttemp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SBC_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.accumulator = this.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar arg = this.memoryRead(4, index2 | index1);\n\t\tvar temp = tempAcc - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((tempAcc ^ temp) & 0x80) !== 0 &&\n\t\t\t((tempAcc ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SBC_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tvar arg = this.memoryRead(4, index2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\targ = this.memoryRead(4, (index2 | index1) + this.Y);\n\t\t}\n\t\ttemp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.CMP_I = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, param);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result === 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CMP_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.cpuMem[param]); //this.memoryRead(4, param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CMP_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.nes.MMU.cpuMem[this.wrap8bit('sum', param, this.X)]); //this.memoryRead(4, this.wrap8bit('sum', param, this.X)));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CMP_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.memoryRead(4, param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CMP_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.memoryRead(4, param2 | temp));\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tresult = this.compareValsAndSetNegative(this.accumulator, this.memoryRead(4, param + this.X));\n\t\t}\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CMP_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.Y;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.memoryRead(4, param2 | temp));\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.memoryRead(4, param + this.Y));\n\t\t}\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CMP_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar tempAcc = this.accumulator;\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar result = this.compareValsAndSetNegative(tempAcc, this.memoryRead(4, index2 | index1));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CMP_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, this.memoryRead(4, index2 | temp));\n\t\tif (temp > 0xFF) {\n\t\t\tresult = this.compareValsAndSetNegative(this.accumulator, this.memoryRead(4, (index2 | index1) + this.Y));\n\t\t}\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\n\tthis.CPX_I = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar result = this.compareValsAndSetNegative(this.X, param);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CPX_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar result = this.compareValsAndSetNegative(this.X, this.nes.MMU.cpuMem[param]); //this.memoryRead(4, param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CPX_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.X, this.memoryRead(4, param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\n\tthis.CPY_I = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar result = this.compareValsAndSetNegative(this.Y, param);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CPY_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar result = this.compareValsAndSetNegative(this.Y, this.nes.MMU.cpuMem[param]); //this.memoryRead(4, param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.CPY_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar result = this.compareValsAndSetNegative(this.Y, this.memoryRead(4, param));\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\n\tthis.BIT_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar temp = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tvar result = this.accumulator & temp;\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\telse\n\t\t\tthis.unsetFlag(1);\n\n\t\tif ((0b10000000 & temp) == 128) {\n\t\t\tthis.setFlag(5);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(5);\n\t\t}\n\t\tif ((0b01000000 & temp) == 64) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t};\n\tthis.BIT_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = this.memoryRead(4, param);\n\t\tvar result = this.accumulator & temp;\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\telse\n\t\t\tthis.unsetFlag(1);\n\n\t\tif ((0b10000000 & temp) == 128) {\n\t\t\tthis.setFlag(5);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(5);\n\t\t}\n\t\tif ((0b01000000 & temp) == 64) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t};\n\n\tthis.NOP = function() {\n\t\tthis.memoryRead(4, 0);\n\t};\n\n\tthis.ASL_AC = function() {\n\t\tif ((this.accumulator >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.accumulator <<= 1;\n\t\tthis.accumulator &= 0xFF;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.ASL_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ASL_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[tempAddr]; //this.memoryRead(4, tempAddr);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val;\n\t\t// this.memoryWrite(3, tempAddr, val);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val;\n\t\t// this.memoryWrite(3, tempAddr, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ASL_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ASL_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\n\tthis.LSR_AC = function() {\n\t\tif ((this.accumulator & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.accumulator >>= 1;\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.LSR_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tval &= 0xFF;\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val;\n\t\t//this.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.LSR_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[tempAddr]; //this.memoryRead(4, tempAddr);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tval >>= 1;\n\t\tval &= 0xFF;\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val;\n\t\t// this.memoryWrite(3, tempAddr, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.LSR_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval >>= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.LSR_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval >>= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\n\tthis.ROL_AC = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tif ((this.accumulator >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.accumulator <<= 1;\n\t\tthis.accumulator &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tthis.accumulator |= 0b00000001;\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.ROL_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[param]; // this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tvar currCarry = this.P & 0x01;\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ROL_Z_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[tempAddr]; //this.memoryRead(4, tempAddr);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; // this.memoryWrite(3, tempAddr, val);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ROL_A = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ROL_A_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\n\tthis.ROR_AC = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tif ((this.accumulator & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.accumulator >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tthis.accumulator |= 0b10000000;\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.ROR_Z = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ROR_Z_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[tempAddr]; //this.memoryRead(4, tempAddr);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ROR_A = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.ROR_A_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\n\tthis.INC_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.INC_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[tempAddr]; //this.memoryRead(4, tempAddr);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.INC_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.INC_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\n\tthis.DEC_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[param]; //this.memoryRead(4, param);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[param] = val; //this.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.DEC_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.clockUnits();\n\t\t// this.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tthis.clockUnits();\n\t\tvar val = this.nes.MMU.cpuMem[tempAddr]; //this.memoryRead(4, tempAddr);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.clockUnits();\n\t\tthis.nes.MMU.cpuMem[tempAddr] = val; //this.memoryWrite(3, tempAddr, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.DEC_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\tthis.DEC_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.calcFlags(val, false, null);\n\t};\n\n\t//unofficial opcodes (optional for most games)\n\tthis.DOP_Z = function() {\n\t\tthis.memoryRead(0, 0);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.DOP_Z_X = function() {\n\t\tthis.memoryRead(0, 0);\n\t\tthis.memoryRead(4, this.pc);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.DOP_I = function() {\n\t\tthis.memoryRead(0, 0);\n\t};\n\n\tthis.TOP_A = function() {\n\t\tthis.memoryRead(0, 0);\n\t\tthis.memoryRead(0, 0);\n\t\tthis.memoryRead(4, this.pc);\n\t};\n\tthis.TOP_A_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(0, 0);\n\t\tvar temp = param + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tif (temp > 0xFF) {\n\t\t\tthis.memoryRead(4, this.pc);\n\t\t}\n\t};\n\n\tthis.LAX_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.accumulator = this.X = this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LAX_Z_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.accumulator = this.memoryRead(4, param);\n\t\tthis.accumulator += this.Y;\n\t\tthis.accumulator = this.X = this.memoryRead(4, this.wrap8bit('sum', param, this.Y));\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LAX_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tthis.accumulator = this.X = this.memoryRead(4, param);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LAX_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.accumulator = this.X = this.memoryRead(4, param2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tvar param = param2 | param1;\n\t\t\tthis.accumulator = this.X = this.memoryRead(4, param + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LAX_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.accumulator = this.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.accumulator = this.X = this.memoryRead(4, index2 | index1);\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.LAX_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tvar temp = index1 + this.Y;\n\t\tthis.accumulator = this.X = this.memoryRead(4, index2 | temp);\n\t\tif (temp > 0xFF) {\n\t\t\tthis.accumulator = this.X = this.memoryRead(4, (index2 | index1) + this.Y);\n\t\t}\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.SAX_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryWrite(3, param, this.accumulator & this.X);\n\t};\n\tthis.SAX_Z_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.Y;\n\t\tthis.memoryWrite(3, this.wrap8bit('sum', param, this.Y), (this.accumulator & this.X));\n\t};\n\tthis.SAX_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tthis.memoryWrite(3, index2 | index1, this.accumulator & this.X);\n\t};\n\tthis.SAX_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tthis.memoryWrite(3, param2 | param1, this.accumulator & this.X);\n\t};\n\n\tthis.DCP_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, val);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.DCP_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tvar val = this.memoryRead(4, tempAddr);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, val);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.DCP_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, val);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.DCP_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, val);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.DCP_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, val);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.DCP_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, val);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\tthis.DCP_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, index2 | (this.Y + index1));\n\t\tval = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tval = this.wrap8bit('decrement', val, null);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tvar result = this.compareValsAndSetNegative(this.accumulator, val);\n\t\tif (result > 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t\tif (result == 0) {\n\t\t\tthis.setFlag(0);\n\t\t\tthis.setFlag(1);\n\t\t}\n\t\tif (result < 0) {\n\t\t\tthis.unsetFlag(0);\n\t\t\tthis.unsetFlag(1);\n\t\t}\n\t};\n\n\tthis.ISB_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ISB_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tvar val = this.memoryRead(4, tempAddr);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ISB_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ISB_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tvar arg = val;\n\t\ttemp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ISB_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tvar arg = val;\n\t\ttemp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ISB_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.ISB_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, index2 | (this.Y + index1));\n\t\tval = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tval = this.wrap8bit('increment', val, null);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator - arg - (1 - (this.P & 0x01));\n\t\tif (\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0 &&\n\t\t\t((this.accumulator ^ arg) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp < 0 ? 0 : 1) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 0xff;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.SLO_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator |= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SLO_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tvar val = this.memoryRead(4, tempAddr);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tthis.accumulator |= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SLO_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator |= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SLO_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.accumulator |= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SLO_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tthis.accumulator |= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SLO_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator |= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SLO_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, index2 | (this.Y + index1));\n\t\tval = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tthis.accumulator |= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.SRE_Z = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator ^= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SRE_Z_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tvar val = this.memoryRead(4, tempAddr);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tthis.accumulator ^= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SRE_A = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator ^= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SRE_A_X = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.accumulator ^= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SRE_A_Y = function() {\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tthis.accumulator ^= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SRE_I_X = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator ^= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.SRE_I_Y = function() {\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, index2 | (this.Y + index1));\n\t\tval = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tthis.accumulator ^= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.RLA_Z = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator &= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RLA_Z_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tvar val = this.memoryRead(4, tempAddr);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tthis.accumulator &= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RLA_A = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator &= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RLA_A_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tthis.accumulator &= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RLA_A_Y = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tthis.accumulator &= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RLA_I_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tthis.accumulator &= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RLA_I_Y = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, index2 | (this.Y + index1));\n\t\tval = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val >> 7) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval <<= 1;\n\t\tval &= 0xFF;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b00000001;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tthis.accumulator &= val;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\tthis.RRA_Z = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RRA_Z_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param);\n\t\tvar tempAddr = this.wrap8bit('sum', param, this.X);\n\t\tvar val = this.memoryRead(4, tempAddr);\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, tempAddr, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RRA_A = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RRA_A_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.X;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.X);\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.X, val);\n\t\tvar arg = val;\n\t\ttemp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RRA_A_Y = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param1 = this.memoryRead(0, 0);\n\t\tvar param2 = this.memoryRead(0, 0);\n\t\tparam2 = param2 << 8;\n\t\tvar param = param2 | param1;\n\t\tvar temp = param1 + this.Y;\n\t\tthis.memoryRead(4, temp);\n\t\tvar val = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tvar arg = val;\n\t\ttemp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RRA_I_X = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tthis.memoryRead(4, param) + this.X;\n\t\tvar index1 = this.memoryRead(4, this.wrap8bit('sum', param, this.X));\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param + this.X, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, param);\n\t\tthis.memoryWrite(3, param, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\tthis.RRA_I_Y = function() {\n\t\tvar currCarry = this.P & 0x01;\n\t\tvar param = this.memoryRead(0, 0);\n\t\tvar index1 = this.memoryRead(4, param);\n\t\tvar index2 = this.memoryRead(4, this.wrap8bit('sum', param, 1));\n\t\tindex2 = index2 << 8;\n\t\tparam = index2 | index1;\n\t\tvar val = this.memoryRead(4, index2 | (this.Y + index1));\n\t\tval = this.memoryRead(4, param + this.Y);\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tif ((val & 0x01) == 1)\n\t\t\tthis.setFlag(0);\n\t\telse\n\t\t\tthis.unsetFlag(0);\n\t\tval >>= 1;\n\t\tif (currCarry == 1) {\n\t\t\tval |= 0b10000000;\n\t\t}\n\t\tthis.memoryWrite(3, param + this.Y, val);\n\t\tvar arg = val;\n\t\tvar temp = this.accumulator + arg + (this.P & 0x01);\n\t\tif (\n\t\t\t((this.accumulator ^ arg) & 0x80) === 0 &&\n\t\t\t((this.accumulator ^ temp) & 0x80) !== 0\n\t\t) {\n\t\t\tthis.setFlag(4);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(4);\n\t\t}\n\t\tif (temp > 255 ? 1 : 0) {\n\t\t\tthis.setFlag(0);\n\t\t}\n\t\telse {\n\t\t\tthis.unsetFlag(0);\n\t\t}\n\t\tthis.accumulator = temp & 255;\n\t\tthis.calcFlags(null, false, null);\n\t};\n\n\n\tvar log = [];\n\n\tthis.executeInstruction = function(opCode) {\n\t\tswitch (opCode) {\n\t\t\t//LDA Instuctions\n\t\t\tcase 0xA9:\n\t\t\t\tthis.LDA_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xA5:\n\t\t\t\tthis.LDA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB5:\n\t\t\t\tthis.LDA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xAD:\n\t\t\t\tthis.LDA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBD:\n\t\t\t\tthis.LDA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xB9:\n\t\t\t\tthis.LDA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xA1:\n\t\t\t\tthis.LDA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xB1:\n\t\t\t\tthis.LDA_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//STA Instructions\n\t\t\tcase 0x85:\n\t\t\t\tthis.STA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x95:\n\t\t\t\tthis.STA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x8D:\n\t\t\t\tthis.STA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x9D:\n\t\t\t\tthis.STA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x99:\n\t\t\t\tthis.STA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x81:\n\t\t\t\tthis.STA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x91:\n\t\t\t\tthis.STA_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//ADC Instructions\n\t\t\tcase 0x69:\n\t\t\t\tthis.ADC_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x65:\n\t\t\t\tthis.ADC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x75:\n\t\t\t\tthis.ADC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x6D:\n\t\t\t\tthis.ADC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x7D:\n\t\t\t\tthis.ADC_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x79:\n\t\t\t\tthis.ADC_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x61:\n\t\t\t\tthis.ADC_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x71:\n\t\t\t\tthis.ADC_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//AND Instructions\n\t\t\tcase 0x29:\n\t\t\t\tthis.AND_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x25:\n\t\t\t\tthis.AND_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x35:\n\t\t\t\tthis.AND_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x2D:\n\t\t\t\tthis.AND_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x3D:\n\t\t\t\tthis.AND_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x39:\n\t\t\t\tthis.AND_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x21:\n\t\t\t\tthis.AND_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x31:\n\t\t\t\tthis.AND_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//ASL Instructions\n\t\t\tcase 0x0A:\n\t\t\t\tthis.ASL_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tthis.ASL_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x16:\n\t\t\t\tthis.ASL_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0E:\n\t\t\t\tthis.ASL_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1E:\n\t\t\t\tthis.ASL_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//BIT Instructions\n\t\t\tcase 0x24:\n\t\t\t\tthis.BIT_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x2C:\n\t\t\t\tthis.BIT_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//Branch Instructions\n\t\t\tcase 0x10:\n\t\t\t\tthis.BPL();\n\t\t\t\tbreak;\n\t\t\tcase 0x30:\n\t\t\t\tthis.BMI();\n\t\t\t\tbreak;\n\t\t\tcase 0x50:\n\t\t\t\tthis.BVC();\n\t\t\t\tbreak;\n\t\t\tcase 0x70:\n\t\t\t\tthis.BVS();\n\t\t\t\tbreak;\n\t\t\tcase 0x90:\n\t\t\t\tthis.BCC();\n\t\t\t\tbreak;\n\t\t\tcase 0xB0:\n\t\t\t\tthis.BCS();\n\t\t\t\tbreak;\n\t\t\tcase 0xD0:\n\t\t\t\tthis.BNE();\n\t\t\t\tbreak;\n\t\t\tcase 0xF0:\n\t\t\t\tthis.BEQ();\n\t\t\t\tbreak;\n\n\t\t\t\t//BRK Instructions\n\t\t\tcase 0x00:\n\t\t\t\tthis.BRK();\n\t\t\t\tbreak;\n\n\t\t\t\t//CMP Instructions\n\t\t\tcase 0xC9:\n\t\t\t\tthis.CMP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC5:\n\t\t\t\tthis.CMP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xD5:\n\t\t\t\tthis.CMP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xCD:\n\t\t\t\tthis.CMP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xDD:\n\t\t\t\tthis.CMP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xD9:\n\t\t\t\tthis.CMP_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xC1:\n\t\t\t\tthis.CMP_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xD1:\n\t\t\t\tthis.CMP_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//CPX Instructions\n\t\t\tcase 0xE0:\n\t\t\t\tthis.CPX_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xE4:\n\t\t\t\tthis.CPX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xEC:\n\t\t\t\tthis.CPX_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//CPY Instructions\n\t\t\tcase 0xC0:\n\t\t\t\tthis.CPY_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC4:\n\t\t\t\tthis.CPY_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xCC:\n\t\t\t\tthis.CPY_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//DEC Instructions\n\t\t\tcase 0xC6:\n\t\t\t\tthis.DEC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xD6:\n\t\t\t\tthis.DEC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xCE:\n\t\t\t\tthis.DEC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xDE:\n\t\t\t\tthis.DEC_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//EOR Instructions\n\t\t\tcase 0x49:\n\t\t\t\tthis.EOR_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x45:\n\t\t\t\tthis.EOR_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x55:\n\t\t\t\tthis.EOR_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x4D:\n\t\t\t\tthis.EOR_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x5D:\n\t\t\t\tthis.EOR_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x59:\n\t\t\t\tthis.EOR_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x41:\n\t\t\t\tthis.EOR_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x51:\n\t\t\t\tthis.EOR_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//Flag Instructions\n\t\t\tcase 0x18:\n\t\t\t\tthis.CLC();\n\t\t\t\tbreak;\n\t\t\tcase 0x38:\n\t\t\t\tthis.SEC();\n\t\t\t\tbreak;\n\t\t\tcase 0x58:\n\t\t\t\tthis.CLI();\n\t\t\t\tbreak;\n\t\t\tcase 0x78:\n\t\t\t\tthis.SEI();\n\t\t\t\tbreak;\n\t\t\tcase 0xB8:\n\t\t\t\tthis.CLV();\n\t\t\t\tbreak;\n\t\t\tcase 0xD8:\n\t\t\t\tthis.CLD();\n\t\t\t\tbreak;\n\t\t\tcase 0xF8:\n\t\t\t\tthis.SED();\n\t\t\t\tbreak;\n\n\t\t\t\t//INC Instructions\n\t\t\tcase 0xE6:\n\t\t\t\tthis.INC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xF6:\n\t\t\t\tthis.INC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xEE:\n\t\t\t\tthis.INC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xFE:\n\t\t\t\tthis.INC_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//JMP Instructions\n\t\t\tcase 0x4C:\n\t\t\t\tthis.JMP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x6C:\n\t\t\t\tthis.JMP_I();\n\t\t\t\tbreak;\n\n\t\t\t\t//JSR Instructions\n\t\t\tcase 0x20:\n\t\t\t\tthis.JSR_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//LDX Instructions\n\t\t\tcase 0xA2:\n\t\t\t\tthis.LDX_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xA6:\n\t\t\t\tthis.LDX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB6:\n\t\t\t\tthis.LDX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xAE:\n\t\t\t\tthis.LDX_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBE:\n\t\t\t\tthis.LDX_A_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//LDY Instructions\n\t\t\tcase 0xA0:\n\t\t\t\tthis.LDY_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xA4:\n\t\t\t\tthis.LDY_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB4:\n\t\t\t\tthis.LDY_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xAC:\n\t\t\t\tthis.LDY_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBC:\n\t\t\t\tthis.LDY_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//LSR Instructions\n\t\t\tcase 0x4A:\n\t\t\t\tthis.LSR_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\n\t\t\t\tthis.LSR_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x56:\n\t\t\t\tthis.LSR_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x4E:\n\t\t\t\tthis.LSR_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x5E:\n\t\t\t\tthis.LSR_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//NOP\n\t\t\tcase 0xEA:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\n\t\t\t\t//ORA Instructions\n\t\t\tcase 0x09:\n\t\t\t\tthis.ORA_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tthis.ORA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x15:\n\t\t\t\tthis.ORA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0D:\n\t\t\t\tthis.ORA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1D:\n\t\t\t\tthis.ORA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x19:\n\t\t\t\tthis.ORA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tthis.ORA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x11:\n\t\t\t\tthis.ORA_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//Register Instructions\n\t\t\tcase 0xAA:\n\t\t\t\tthis.TAX();\n\t\t\t\tbreak;\n\t\t\tcase 0x8A:\n\t\t\t\tthis.TXA();\n\t\t\t\tbreak;\n\t\t\tcase 0xCA:\n\t\t\t\tthis.DEX();\n\t\t\t\tbreak;\n\t\t\tcase 0xE8:\n\t\t\t\tthis.INX();\n\t\t\t\tbreak;\n\t\t\tcase 0xA8:\n\t\t\t\tthis.TAY();\n\t\t\t\tbreak;\n\t\t\tcase 0x98:\n\t\t\t\tthis.TYA();\n\t\t\t\tbreak;\n\t\t\tcase 0x88:\n\t\t\t\tthis.DEY();\n\t\t\t\tbreak;\n\t\t\tcase 0xC8:\n\t\t\t\tthis.INY();\n\t\t\t\tbreak;\n\n\t\t\t\t//ROL Instructions\n\t\t\tcase 0x2A:\n\t\t\t\tthis.ROL_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x26:\n\t\t\t\tthis.ROL_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x36:\n\t\t\t\tthis.ROL_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x2E:\n\t\t\t\tthis.ROL_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x3E:\n\t\t\t\tthis.ROL_A_X();\n\t\t\t\tbreak;\n\n\n\t\t\t\t//ROR Instructions\n\t\t\tcase 0x6A:\n\t\t\t\tthis.ROR_AC();\n\t\t\t\tbreak;\n\t\t\tcase 0x66:\n\t\t\t\tthis.ROR_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x76:\n\t\t\t\tthis.ROR_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x6E:\n\t\t\t\tthis.ROR_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x7E:\n\t\t\t\tthis.ROR_A_X();\n\t\t\t\tbreak;\n\n\t\t\t\t//RTI Instructions\n\t\t\tcase 0x40:\n\t\t\t\tthis.RTI();\n\t\t\t\tbreak;\n\n\t\t\t\t//RTS Instructions\n\t\t\tcase 0x60:\n\t\t\t\tthis.RTS();\n\t\t\t\tbreak;\n\n\t\t\t\t//SBC Instructions\n\t\t\tcase 0xE9:\n\t\t\t\tthis.SBC_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xE5:\n\t\t\t\tthis.SBC_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xF5:\n\t\t\t\tthis.SBC_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xED:\n\t\t\t\tthis.SBC_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xFD:\n\t\t\t\tthis.SBC_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xF9:\n\t\t\t\tthis.SBC_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xE1:\n\t\t\t\tthis.SBC_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xF1:\n\t\t\t\tthis.SBC_I_Y();\n\t\t\t\tbreak;\n\n\t\t\t\t//Stack Instructions\n\t\t\tcase 0x9A:\n\t\t\t\tthis.TXS();\n\t\t\t\tbreak;\n\t\t\tcase 0xBA:\n\t\t\t\tthis.TSX();\n\t\t\t\tbreak;\n\t\t\tcase 0x48:\n\t\t\t\tthis.PHA();\n\t\t\t\tbreak;\n\t\t\tcase 0x68:\n\t\t\t\tthis.PLA();\n\t\t\t\tbreak;\n\t\t\tcase 0x08:\n\t\t\t\tthis.PHP();\n\t\t\t\tbreak;\n\t\t\tcase 0x28:\n\t\t\t\tthis.PLP();\n\t\t\t\tbreak;\n\n\t\t\t\t//STX Instructions\n\t\t\tcase 0x86:\n\t\t\t\tthis.STX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x96:\n\t\t\t\tthis.STX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x8E:\n\t\t\t\tthis.STX_A();\n\t\t\t\tbreak;\n\n\n\t\t\t\t//STY Instructions\n\t\t\tcase 0x84:\n\t\t\t\tthis.STY_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x94:\n\t\t\t\tthis.STY_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x8C:\n\t\t\t\tthis.STY_A();\n\t\t\t\tbreak;\n\n\t\t\t\t//Unofficial opcodes\n\t\t\t\t//http://www.oxyron.de/html/opcodes02.html\n\t\t\tcase 0x04:\n\t\t\t\tthis.DOP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x14:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x34:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x44:\n\t\t\t\tthis.DOP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x54:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x64:\n\t\t\t\tthis.DOP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x74:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x80:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x82:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0x89:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC2:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xD4:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xE2:\n\t\t\t\tthis.DOP_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xF4:\n\t\t\t\tthis.DOP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0C:\n\t\t\t\tthis.TOP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x3C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x5C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x7C:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xDC:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xFC:\n\t\t\t\tthis.TOP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x1A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x3A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x5A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x7A:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0xDA:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0xFA:\n\t\t\t\tthis.NOP();\n\t\t\t\tbreak;\n\t\t\tcase 0x0A7:\n\t\t\t\tthis.LAX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xB7:\n\t\t\t\tthis.LAX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xAF:\n\t\t\t\tthis.LAX_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xBF:\n\t\t\t\tthis.LAX_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xA3:\n\t\t\t\tthis.LAX_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xB3:\n\t\t\t\tthis.LAX_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x87:\n\t\t\t\tthis.SAX_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x97:\n\t\t\t\tthis.SAX_Z_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x83:\n\t\t\t\tthis.SAX_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x8F:\n\t\t\t\tthis.SAX_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xEB:\n\t\t\t\tthis.SBC_I();\n\t\t\t\tbreak;\n\t\t\tcase 0xC7:\n\t\t\t\tthis.DCP_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xD7:\n\t\t\t\tthis.DCP_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xCF:\n\t\t\t\tthis.DCP_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xDF:\n\t\t\t\tthis.DCP_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xDB:\n\t\t\t\tthis.DCP_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xC3:\n\t\t\t\tthis.DCP_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xD3:\n\t\t\t\tthis.DCP_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xE7:\n\t\t\t\tthis.ISB_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0xF7:\n\t\t\t\tthis.ISB_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xEF:\n\t\t\t\tthis.ISB_A();\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tthis.ISB_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xFB:\n\t\t\t\tthis.ISB_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0xE3:\n\t\t\t\tthis.ISB_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0xF3:\n\t\t\t\tthis.ISB_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x07:\n\t\t\t\tthis.SLO_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x17:\n\t\t\t\tthis.SLO_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x0F:\n\t\t\t\tthis.SLO_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x1F:\n\t\t\t\tthis.SLO_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x1B:\n\t\t\t\tthis.SLO_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tthis.SLO_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x13:\n\t\t\t\tthis.SLO_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x27:\n\t\t\t\tthis.RLA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x37:\n\t\t\t\tthis.RLA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x2F:\n\t\t\t\tthis.RLA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x3F:\n\t\t\t\tthis.RLA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x3B:\n\t\t\t\tthis.RLA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x23:\n\t\t\t\tthis.RLA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x33:\n\t\t\t\tthis.RLA_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x47:\n\t\t\t\tthis.SRE_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x57:\n\t\t\t\tthis.SRE_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x4F:\n\t\t\t\tthis.SRE_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x5F:\n\t\t\t\tthis.SRE_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x5B:\n\t\t\t\tthis.SRE_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x43:\n\t\t\t\tthis.SRE_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x53:\n\t\t\t\tthis.SRE_I_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x67:\n\t\t\t\tthis.RRA_Z();\n\t\t\t\tbreak;\n\t\t\tcase 0x77:\n\t\t\t\tthis.RRA_Z_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x6F:\n\t\t\t\tthis.RRA_A();\n\t\t\t\tbreak;\n\t\t\tcase 0x7F:\n\t\t\t\tthis.RRA_A_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x7B:\n\t\t\t\tthis.RRA_A_Y();\n\t\t\t\tbreak;\n\t\t\tcase 0x63:\n\t\t\t\tthis.RRA_I_X();\n\t\t\t\tbreak;\n\t\t\tcase 0x73:\n\t\t\t\tthis.RRA_I_Y();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// console.log(\"Unknown opcode: \" + this.currentOpcode.toString('16'));\n\t\t\t\t// this.errorFlag = true;\n\t\t\t\tconsole.log('Unknown opcode' + \" \" + opCode.toString(16).toUpperCase());\n\t\t\t\talert('Unknown opcode' + \" \" + opCode.toString(16).toUpperCase());\n\t\t\t\tthis.pc++;\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tthis.clockPPU = function() {\n\t\tif (this.nes.PPU.clock()) {\n\t\t\tif (this.renderedScanline == 260) {\n\t\t\t\tthis.frameCompleted = true;\n\t\t\t\t// this.nes.MMU.setOAMADDR(0);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.ppuClock = 0;\n\tthis.fakeClockPPU = function() {\n\t\tthis.ppuClock++;\n\t\tif (this.ppuClock == 341) {\n\t\t\tthis.ppuClock = 0;\n\t\t\tthis.renderedScanline++;\n\t\t\tif (this.renderedScanLine == 262)\n\t\t\t\tthis.renderedScanLine = 0;\n\t\t\tif (this.renderedScanline == 241) {\n\t\t\t\tif (this.nes.PPU.nmi_output) {\n\t\t\t\t\tthis.IRQToRun = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.renderedScanline == 260) {\n\t\t\t\tthis.frameCompleted = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.clockUnits = function() {\n\t\tthis.clockAPU();\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tthis.clockPPU();\n\t\t}\n\t\tthis.oddCycle = !this.oddCycle;\n\t};\n\n\t//memory read types--\x3e 0: OpCode/Operand fetch, 1: dummy read, 2: pop stack, 3: increment pc\n\tthis.memoryRead = function(type, location) {\n\t\tvar retVal = 0;\n\t\tthis.clockUnits();\n\t\tswitch (type) {\n\t\t\tcase 0:\n\t\t\t\tretVal = this.nes.MMU.getCpuMemVal(this.pc);\n\t\t\t\t// log.push((\"00\" + retVal.toString(16).toUpperCase()).slice(-2));\n\t\t\t\tthis.pc++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tretVal = this.popFromStack();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.pc++;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tretVal = this.nes.MMU.getCpuMemVal(location);\n\t\t\t\tbreak;\n\t\t}\n\t\t// this.clockUnits();\n\t\treturn retVal;\n\t};\n\t//memory read types--\x3e 0: increment pc\n\tthis.memoryWrite = function(type, location, value) {\n\t\tthis.clockUnits();\n\t\tswitch (type) {\n\t\t\tcase 0:\n\t\t\t\tthis.pc++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.pushToStack(value);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.nes.MMU.setCpuMemVal(location, value);\n\t\t\t\tbreak;\n\t\t}\n\t\t// this.clockUnits();\n\t};\n\tthis.IRQToRun = 0;\n\tthis.runIRQ = function() {\n\t\tswitch (this.IRQToRun) {\n\t\t\tcase 1: //NMI\n\t\t\t\tthis.NMI();\n\t\t\t\tbreak;\n\t\t\tcase 2: //Immediate NMI\n\t\t\t\tthis.IRQToRun--;\n\t\t\t\tbreak;\n\t\t\tcase 3: //IRQ\n\t\t\t\tthis.IRQ();\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tthis.pushStatusToLog = function() {\n\t\tlog.push(\"A:\" + (\"00\" + this.accumulator.toString(16).toUpperCase()).slice(-2));\n\t\tlog.push(\"X:\" + (\"00\" + this.X.toString(16).toUpperCase()).slice(-2));\n\t\tlog.push(\"Y:\" + (\"00\" + this.Y.toString(16).toUpperCase()).slice(-2));\n\t\tlog.push(\"P:\" + (\"00\" + this.P.toString(16).toUpperCase()).slice(-2));\n\t\tlog.push(\"SP:\" + (\"00\" + this.sp.toString(16).toUpperCase()).slice(-2));\n\t};\n\tthis.execCPU = function() {\n\t\t// log = [];\n\t\t// log.push((\"0000\" + this.pc.toString(16).toUpperCase()).slice(-4));\n\t\tvar opCode = this.memoryRead(0, 0);\n\t\t// this.pushStatusToLog();\n\t\tthis.executeInstruction(opCode);\n\t\t// printLog();\n\t\tif (this.IRQToRun) this.runIRQ();\n\t};\n\n\tthis.cyclesToHalt = 0;\n\tthis.frame = function() {\n\t\tthis.frameCompleted = false;\n\t\tthis.renderedScanline = 0;\n\t\twhile (!this.frameCompleted) {\n\t\t\tthis.execCPU();\n\t\t}\n\t\tthis.oddFrame = !this.oddFrame;\n\t\t// this.skipFrame = !this.skipFrame;\n\t};\n}\n\n\n//# sourceURL=webpack:///./public/js/cpu.js?")},"./public/js/display.js":
/*!******************************!*\
  !*** ./public/js/display.js ***!
  \******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return display; });\n\nfunction display(canvas, nes) {\n    this.nes = nes;\n    this.offscreenBuffer = [];\n    var renderTarget = 0; //\'1 for WebGL or 0 for Canvas\'\n    if (renderTarget == 0) {\n        this.ctx = canvas.getContext(\'2d\');\n        this.canvasImageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);\n        this.data = this.canvasImageData.data;\n        this.buf = new ArrayBuffer(this.canvasImageData.data.length);\n        this.buf8 = new Uint8ClampedArray(this.buf);\n        this.bufData = new Uint32Array(this.buf);\n    }\n\n    //WebGL vars\n    if (renderTarget == 1) {\n        this.gl = canvas.getContext("webgl");\n        if (!this.gl) {\n            console.log("No gl for you!");\n        }\n        else {\n            console.log("We\'ve got GL!");\n        }\n        var level = 0;\n        var internalFormat = this.gl.RGBA;\n        var width = 256;\n        var height = 240;\n        var border = 0;\n        var format = this.gl.RGBA;\n        var imageType = this.gl.UNSIGNED_BYTE;\n        var count = 6;\n        var size = 2;\n        var type = this.gl.FLOAT;\n        var normalize = false;\n        var stride = 0;\n        var offset = 0;\n    }\n\n\n    function createShader(gl, type, source) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n        if (success) {\n            console.log("Successfully compiled shader");\n            return shader;\n        }\n        console.log(gl.getShaderInfoLog(shader));\n        gl.deleteShader(shader);\n    }\n\n    function createProgram(gl, vertexShader, fragmentShader) {\n        var program = gl.createProgram();\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n        if (success) {\n            console.log("Successfully created program");\n            return program;\n        }\n        console.log(gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n    }\n\n    //Update the data for the cavases\n    this.updateBuffer = function(screenPixel, pixelColor) {\n        this.offscreenBuffer[screenPixel] = pixelColor;\n    };\n\n    //Update the cavases themselves\n    this.updateCanvas = function() {\n        if (renderTarget == 0) {\n            // for (var i = 0; i < this.bufData.length; i++) {\n            //     this.bufData[i] = 0xFF000000 | (this.offscreenBuffer[i][2] << 16) | (this.offscreenBuffer[i][1] << 8) | this.offscreenBuffer[i][0];\n            // }\n            // var offScreenBuffer = this.nes.PPU.getOffScreenBuffer();\n            for (var i = 0; i < this.bufData.length; i++) {\n                // this.bufData[i] = this.offscreenBuffer[i];\n                this.bufData[i] = this.nes.PPU.getOffScreenBuffer()[i];\n            }\n            this.canvasImageData.data.set(this.buf8);\n            this.ctx.putImageData(this.canvasImageData, 0, 0);\n        }\n        else if (renderTarget == 1) {\n            for (var i = 240 - 1, k = 0; i >= 0, k < 240; i--, k++) {\n                for (var j = 0; j < 256; j++) {\n                    var m = (i * 256 + j) * 4;\n                    var n = k * 256 + j;\n                    this.pixelBuffer[m] = this.offscreenBuffer[n][0];\n                    this.pixelBuffer[m + 1] = this.offscreenBuffer[n][1];\n                    this.pixelBuffer[m + 2] = this.offscreenBuffer[n][2];\n                    this.pixelBuffer[m + 3] = 0xFF;\n                }\n            }\n            this.gl.texSubImage2D(this.gl.TEXTURE_2D, level, 0, 0, width, height, format, imageType, this.pixelBuffer);\n            var primitiveType = this.gl.TRIANGLES;\n            this.gl.drawArrays(primitiveType, offset, count);\n        }\n    };\n\n    //Reset the cavases\n    this.screenReset = function() {\n        if (renderTarget == 0) {\n            this.ctx.fillStyle = \'black\';\n            this.ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    };\n\n    //Initilize the screen buffers for various canvases\n    this.initScreenBuffer = function() {\n        for (var i = 0; i < canvas.width * canvas.height; i++) {\n            // this.offscreenBuffer.push([0, 0, 0, 0xFF]);\n            this.offscreenBuffer.push([0xFF000000]);\n        }\n        if (renderTarget == 0) {\n            for (var i = 0; i < canvas.width * canvas.height; i++) {\n                var j = i * 4;\n                this.data[j + 3] = 0xFF;\n                this.data[j + 2] = 0x00;\n                this.data[j + 1] = 0x00;\n                this.data[j] = 0x00;\n            }\n            this.ctx.putImageData(this.canvasImageData, 0, 0);\n        }\n        else if (renderTarget == 1) {\n            this.pixelBuffer = new Uint8Array(256 * 240 * 4);\n            var vertexShaderSource = "attribute vec4 a_position; attribute vec2 a_texCoord; varying vec2 v_texCoord; void main() { gl_Position = a_position; v_texCoord = a_texCoord; }";\n            var fragmentShaderSource = "precision mediump float; uniform vec4 u_color; uniform sampler2D u_image; varying vec2 v_texCoord; void main() { gl_FragColor = texture2D(u_image, v_texCoord); }";\n            var vertexShader = createShader(this.gl, this.gl.VERTEX_SHADER, vertexShaderSource);\n            var fragmentShader = createShader(this.gl, this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n            var program = createProgram(this.gl, vertexShader, fragmentShader);\n\n            var positionAttributeLocation = this.gl.getAttribLocation(program, "a_position");\n            var positionBuffer = this.gl.createBuffer();\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n\n            var positions = [-1, -1, -1, 1,\n                1, -1, -1, 1,\n                1, 1,\n                1, -1\n            ];\n\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n            this.gl.viewport(0, 0, canvas.width, canvas.height);\n            this.gl.clearColor(0, 0, 0, 0);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n            this.gl.useProgram(program);\n            this.gl.enableVertexAttribArray(positionAttributeLocation);\n\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n            this.gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n            var primitiveType = this.gl.TRIANGLES;\n            var texCoordLocation = this.gl.getAttribLocation(program, "a_texCoord");\n            var texCoordBuffer = this.gl.createBuffer();\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texCoordBuffer);\n\n            var texPositions = [\n                0.0, 0.0,\n                0.0, 1.0,\n                1.0, 0.0,\n                0.0, 1.0,\n                1.0, 1.0,\n                1.0, 0.0\n            ];\n\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texPositions), this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(texCoordLocation);\n            this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n\n            var texture = this.gl.createTexture();\n            this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\n\n            for (var i = 0; i < 256 * 240; i++) {\n                var j = i * 4;\n                this.pixelBuffer[j] = this.offscreenBuffer[i][0];\n                this.pixelBuffer[j + 1] = this.offscreenBuffer[i][1];\n                this.pixelBuffer[j + 2] = this.offscreenBuffer[i][2];\n                this.pixelBuffer[j + 3] = 0xFF;\n            }\n            this.gl.texImage2D(this.gl.TEXTURE_2D, level, internalFormat, width, height, border, format, imageType, this.pixelBuffer);\n            this.gl.drawArrays(primitiveType, offset, count);\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/display.js?')},"./public/js/iNES.js":
/*!***************************!*\
  !*** ./public/js/iNES.js ***!
  \***************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return iNES; });\n\nfunction iNES(nes) {\n    this.nes = nes;\n    this.headers = []; //hold 16 byte iNES headers\n    this.prgRomUnits;\n    this.chrRomUnits = 1;\n    this.prgRamUnits = 1;\n    this.mirroring;\n    this.batBackedPrg = false;\n    this.trainer = false;\n    this.ignoreMirrorin = false;\n    this.mapperLowBits;\n    this.mapperHighBits;\n    this.vsUnisystem = false;\n    this.nes20format = false;\n    this.tvSystem = 'NTSC';\n    this.cyclesPerScanLine = 341;\n\n    this.parseHeaders = function() {\n        if (this.headers[0] == 0x4E)\n            if (this.headers[1] == 0x45)\n                if (this.headers[2] == 0x53)\n                    if (this.headers[3] == 0x1A)\n                        console.log(\"proper iNES header found\");\n\n        this.prgRomUnits = this.headers[4];\n        this.chrRomUnits = this.headers[5];\n        this.flag6 = this.headers[6];\n        this.flag7 = this.headers[7];\n        if (this.headers[8] != 0)\n            this.prgRamUnits = this.headers[8];\n        this.flag9 = this.headers[9];\n        this.flag10 = this.headers[10];\n\n        //flag 6 bit map\n        // 76543210\n        // ||||||||\n        // |||||||+- Mirroring: 0: horizontal (vertical arrangement) (CIRAM A10 = PPU A11)\n        // |||||||              1: vertical (horizontal arrangement) (CIRAM A10 = PPU A10)\n        // ||||||+-- 1: Cartridge contains battery-backed PRG RAM ($6000-7FFF) or other persistent memory\n        // |||||+--- 1: 512-byte trainer at $7000-$71FF (stored before PRG data)\n        // ||||+---- 1: Ignore mirroring control or above mirroring bit; instead provide four-screen VRAM\n        // ++++----- Lower nybble of mapper number\n        if ((this.flag6 & 0x01) == 1) {\n            this.mirroring = 0;\n        }\n        else\n            this.mirroring = 1;\n\n        if (((this.flag6 >> 1) & 0x01) == 1) {\n            this.batBackedPrg = true;\n        }\n\n        if (((this.flag6 >> 2) & 0x01) == 1) {\n            this.trainer = true;\n        }\n\n        if (((this.flag6 >> 3) & 0x01) == 1) {\n            this.ignoreMirroring = true;\n        }\n\n        this.mapperLowBits = this.flag6 >> 4;\n\n        //Flag 7 bit map\n        // 76543210\n        // ||||||||\n        // |||||||+- VS Unisystem\n        // ||||||+-- PlayChoice-10 (8KB of Hint Screen data stored after CHR data)\n        // ||||++--- If equal to 2, flags 8-15 are in NES 2.0 format\n        // ++++----- Upper nybble of mapper number\n\n        if ((this.flag7 & 0x01) == 1) {\n            this.vsUnisystem = true;\n        }\n\n        if (((this.flag7 >> 1) & 0x01) == 1) {\n            this.playChoice10 = true;\n        }\n\n        if (((this.flag7 >> 2) & 0x03) == 2) {\n            this.nes20format = true;\n        }\n\n        this.mapperHighBits = this.flag7 >> 4;\n        this.mapperNum = (this.mapperHighBits << 4) | this.mapperLowBits;\n        //Flag 9 bit map\n        // 76543210\n        // ||||||||\n        // |||||||+- TV system (0: NTSC; 1: PAL)\n        // +++++++-- Reserved, set to zero\n        if ((this.flag9 & 0x01) == 1) {\n            this.tvSystem = 'PAL';\n        }\n        else\n            this.tvSystem = 'NTSC';\n\n    };\n\n    this.setFlags = function() {\n\n    };\n\n    this.parseRom = function(romBytes) {\n        for (var i = 0; i < 16; i++) {\n            this.headers.push(romBytes[i]);\n        }\n        this.parseHeaders();\n        this.nes.Mapper.loadRom(romBytes);\n        this.setFlags();\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/iNES.js?")},"./public/js/mapper.js":
/*!*****************************!*\
  !*** ./public/js/mapper.js ***!
  \*****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mapper; });\n\nfunction mapper(nes) {\n    this.nes = nes;\n    this.chrGrids = [];\n    var prgRomBanks = [];\n    var chrRomBanks = [];\n    this.PRGRam = new Uint8Array(8192);\n    this.currentPRGBank = 0;\n    this.currentCHRBank = 0;\n    this.chrRam = false;\n    // this.chrWindowSize = 8192;\n    var MMC1WriteCount = 0,\n        MMC1LoadReg = 0x0C,\n        MMC1ControlReg = 0,\n        MMC14KBBank0 = 0,\n        MMC14KBBank1 = 0,\n        MMC1PRGWindow = 1,\n        MMC1PRGFixedBank = 0xC000,\n        MMC1CHRWindow = 8,\n        MMC1PRGRAMEnabled = false,\n        tempMMC14KBBank0 = 0,\n        tempMMC14KBBank1 = 0;\n        \n\n    this.loadRom = function(romBytes) {\n        this.currentMapperNum = this.nes.ines.mapperNum;\n        this.initMem();\n\n        //Load PRG & CHR Rom banks\n        this.loadPRGBanks(romBytes);\n        this.loadCHRBanks(romBytes);\n\n        switch (this.currentMapperNum) {\n            //NROM\n            case 0:\n                //assign banks to cpu & ppu\n                break;\n                //UNROM\n            case 2:\n                break;\n        }\n    };\n\n    //Initialize memory\n    this.initMem = function() {\n        // 2kb Internal RAM\n        for (var i = 0; i < 0x2000; i++) {\n            this.nes.MMU.cpuMem[i] = 0xFF;\n        }\n\n        // All others set to 0.\n        for (var i = 0x2000; i < 0x8000; i++) {\n            this.nes.MMU.cpuMem[i] = 0;\n        }\n    };\n\n    this.initCHRRam = function() {\n        var temp = new Uint8Array(8192);\n        for (var i = 0; i < 8192; i++) {\n            temp[i] = 0;\n        }\n        chrRomBanks.push(temp);\n    };\n\n    this.initPRGRam = function() {\n        for (var i = 0; i < 8192; i++) {\n            this.PRGRam[i] = 0;\n        }\n    };\n\n    this.loadPRGBanks = function(romBytes) {\n        var prgBank;\n        prgRomBanks = [];\n        for (var i = 0; i < this.nes.ines.prgRomUnits; i++) {\n            prgBank = new Uint8Array(16384);\n            for (var j = 0; j < 16384; j++) {\n                prgBank[j] = romBytes[i * 16384 + 16 + j];\n            }\n            prgRomBanks[i] = prgBank;\n        }\n        //if prg rom is only 16k, copy to next bank also\n        if (this.nes.ines.prgRomUnits == 1) {\n            prgRomBanks[1] = prgBank;\n        }\n    };\n\n    this.loadCHRBanks = function(romBytes) {\n        var chrBank;\n        chrRomBanks = [];\n        for (var i = 0; i < this.nes.ines.chrRomUnits; i++) {\n            chrBank = new Uint8Array(8192);\n            for (var j = 0; j < 8192; j++) {\n                chrBank[j] = romBytes[i * 8192 + 16 + j + this.nes.ines.prgRomUnits * 16384];\n            }\n            chrRomBanks[i] = chrBank;\n        }\n        //TODO refactor CHR ram loading\n        if (this.nes.ines.chrRomUnits == 0) {\n            this.initCHRRam();\n            this.chrRam = true;\n        }\n        this.initPRGRam();\n    };\n\n    //return PRG rom data \n    this.getPRGRom = function(location) {\n        switch (this.currentMapperNum) {\n            case 0: //NROM\n                if (location < 0xC000) {\n                    return prgRomBanks[0][location - 0x8000];\n                }\n                else { //if (location >= 0xC000 && location <= 0xFFFF) {\n                    return prgRomBanks[1][location - 0xC000];\n                }\n                // break;\n            case 1: //MMC1\n                if (MMC1PRGWindow == 2) {\n                    if (location < 0xC000) {\n                        return prgRomBanks[this.currentPRGBank][location - 0x8000];\n                    }\n                    else { //if (location >= 0xC000 && location <= 0xFFFF) {\n                        return prgRomBanks[this.currentPRGBank + 1][location - 0xC000];\n                    }\n                }\n                else {\n                    if (location < 0xC000) {\n                        if (MMC1PRGFixedBank == 0x8000) {\n                            return prgRomBanks[0][location - 0x8000];\n                        }\n                        else {\n                            return prgRomBanks[this.currentPRGBank][location - 0x8000];\n                        }\n                    }\n                    else { //if (location >= 0xC000 && location <= 0xFFFF) {\n                        if (MMC1PRGFixedBank == 0xC000) {\n                            return prgRomBanks[prgRomBanks.length - 1][location - 0xC000];\n                        }\n                        else {\n                            return prgRomBanks[this.currentPRGBank][location - 0xC000];\n                        }\n                    }\n                }\n            case 2: //UnROM\n                if (location < 0xC000) {\n                    return prgRomBanks[this.currentPRGBank][location - 0x8000];\n                }\n                else { //if (location >= 0xC000 && location <= 0xFFFF) {\n                    return prgRomBanks[prgRomBanks.length - 1][location - 0xC000];\n                }\n                // break;\n            case 3: //CNROM\n                if (location < 0xC000) {\n                    return prgRomBanks[0][location - 0x8000];\n                }\n                else { //if (location >= 0xC000 && location <= 0xFFFF) {\n                    return prgRomBanks[1][location - 0xC000];\n                }\n                // break;\n        }\n    };\n\n    //return CHR rom data\n    this.getCHRRom = function(location) {\n        switch (this.currentMapperNum) {\n            case 1: //MMC1\n                if (this.chrRam) {\n                    return chrRomBanks[this.currentCHRBank][location];\n                }\n                if (MMC1CHRWindow == 8) {\n                    return chrRomBanks[this.currentCHRBank][location];\n                }\n                else if (MMC1CHRWindow == 4) {\n                    if (location < 0x1000) {\n                        if ((MMC14KBBank0 & 1) == 0) {\n                            return chrRomBanks[tempMMC14KBBank0][location];\n                        }\n                        else {\n                            return chrRomBanks[tempMMC14KBBank0][location + 0x1000];\n                        }\n                    }\n                    else {\n                        if ((MMC14KBBank1 & 1) == 0) {\n                            return chrRomBanks[tempMMC14KBBank1][location - 0x1000];\n                        }\n                        else {\n                            return chrRomBanks[tempMMC14KBBank1][location];\n                        }\n                    }\n                }\n                break;\n            case 0: //NROM\n            case 2: //UnROM\n            case 3: //CNROM\n                return chrRomBanks[this.currentCHRBank][location];\n        }\n    };\n\n    this.getPRGRAM = function(location) {\n        if (MMC1PRGRAMEnabled) {\n            return this.PRGRam[location - 0x6000];\n        }\n    };\n\n    this.setCHRRom = function(location, value) {\n        switch (this.currentMapperNum) {\n            case 0: //NROM\n            case 1: //MMC1\n            case 2: //UnROM\n            case 3: //CNROM\n                chrRomBanks[this.currentCHRBank][location] = value;\n                break;\n        }\n    };\n\n    this.setBank = function(value, location) {\n        switch (this.currentMapperNum) {\n            case 1: //MMC1\n                if (value >= 0x80 && value <= 0xFF) {\n                    MMC1LoadReg = 0;\n                    MMC1WriteCount = 0;\n                }\n                else {\n                    MMC1WriteCount++;\n                    MMC1LoadReg >>= 1;\n                    value &= 1;\n                    value <<= 4;\n                    MMC1LoadReg |= value;\n                }\n                if (MMC1WriteCount == 5) {\n                    if (location >= 0x8000 && location <= 0x9FFF) {\n                        MMC1ControlReg = MMC1LoadReg;\n                        this.MMC1UpdateMapperValues(MMC1ControlReg);\n                    }\n                    else if (location >= 0xA000 && location <= 0xBFFF) {\n                        if (MMC1CHRWindow == 8) {\n                            this.setCHRBank((MMC1LoadReg & 0x1E) / 2);\n                        }\n                        else {\n                            MMC14KBBank0 = MMC1LoadReg & 0x1F;\n                            tempMMC14KBBank0 = Math.floor(MMC14KBBank0 / 2);\n                        }\n                    }\n                    else if (location >= 0xC000 && location <= 0xDFFF) {\n                        if (MMC1CHRWindow == 4) {\n                            MMC14KBBank1 = MMC1LoadReg & 0x1F;\n                            tempMMC14KBBank1 = Math.floor(MMC14KBBank1 / 2);\n                        }\n                    }\n                    else if (location >= 0xE000 && location <= 0xFFFF) {\n                        if (MMC1PRGWindow == 2) {\n                            this.setPRGBank(MMC1LoadReg & 0x0E);\n                        }\n                        else {\n                            this.setPRGBank(MMC1LoadReg & 0x0F);\n                        }\n                        if (MMC1LoadReg >> 4) {\n                            MMC1PRGRAMEnabled = false;\n                        }\n                        else {\n                            MMC1PRGRAMEnabled = true;\n                        }\n                    }\n                    MMC1WriteCount = 0;\n                    MMC1LoadReg = 0;\n                }\n                break;\n            case 2: //UnROM\n                this.setPRGBank(value);\n                break;\n            case 3: //CNROM\n                this.setCHRBank(value & 0x03);\n                break;\n        }\n    };\n\n    //set the bank selected by rom\n    this.setPRGBank = function(bank) {\n        this.currentPRGBank = bank;\n    };\n\n    //set the bank selected by rom\n    this.setCHRBank = function(bank) {\n        this.currentCHRBank = bank;\n    };\n\n    this.setPRGRAM = function(location, value) {\n        if (MMC1PRGRAMEnabled) {\n            this.PRGRam[location - 0x6000] = value;\n        }\n    };\n\n    this.MMC1UpdateMapperValues = function(value) {\n        var temp = value & 0x03;\n        switch (temp) { //TODO: 1 screen mirrorring\n            case 0:\n                this.nes.MMU.nameTableMirroring = 2;\n                break;\n            case 1:\n                this.nes.MMU.nameTableMirroring = 2;\n                break;\n            case 2:\n                this.nes.MMU.nameTableMirroring = 0;\n                break;\n            case 3:\n                this.nes.MMU.nameTableMirroring = 1;\n                break;\n        }\n        temp = (value & 0x0C) >> 2;\n        switch (temp) {\n            case 0:\n            case 1:\n                MMC1PRGWindow = 2;\n                break;\n            case 2:\n                MMC1PRGWindow = 1;\n                MMC1PRGFixedBank = 0x8000;\n                break;\n            case 3:\n                MMC1PRGWindow = 1;\n                MMC1PRGFixedBank = 0xC000;\n                break;\n        }\n        temp = value >> 4;\n        if (temp == 0) {\n            MMC1CHRWindow = 8;\n        }\n        else {\n            MMC1CHRWindow = 4;\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/mapper.js?')},"./public/js/mmu.js":
/*!**************************!*\
  !*** ./public/js/mmu.js ***!
  \**************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mmu; });\n//Memory Management Unit to synchronize memory access between CPU and PPU\n\nfunction mmu(nes) {\n    this.nes = nes;\n    this.cpuMem = new Uint8Array(65536);\n    this.ppuMem = new Uint8Array(16384);\n    this.nameTableMirroring = 0;\n    this.startAddress = 0xFFFC;\n    this.ppuRegWriteFlag = false;\n    this.ppuRegObj = {\n        PPUCTRL: 0x00,\n        PPUMASK: 0x00,\n        PPUSTATUS: 0x00,\n        OAMADDR: 0x00,\n        OAMDATA: 0x00,\n        PPUSCROLL: 0x00,\n        PPUADDR: 0x00,\n        PPUDATA: 0x00,\n        OAMDMA: 0x00\n    };\n    this.enableNMIGen = false;\n    var controllerStrobed = false;\n    this.controllerLatched = false;\n    this.latchCounter = 0;\n    this.lsbLastWritePPU = 0;\n    this.PPUOAM = [];\n    this.CHRGrid = [];\n    this.BGRCHRGrid = [];\n    this.spriteGrid = [];\n    this.spriteTiles = [];\n    this.OAM = new Uint8Array(64 * 4); //[];\n    this.secOAM = [];\n    this.chrRamWritten = false;\n    var ppuOpenBus = 0;\n    //button states\n    this.startBtnState = 0;\n    this.selectBtnState = 0;\n    this.upBtnState = 0;\n    this.downBtnState = 0;\n    this.aBtnState = 0;\n    this.bBtnState = 0;\n    this.leftBtnState = 0;\n    this.rightBtnState = 0;\n\n    this.OAMInit = function() {\n        for (var i = 0; i < 64; i++) {\n            this.OAM[i] = 0xFF;\n            this.OAM[i + 1] = 0x00;\n            this.OAM[i + 2] = 0x00;\n            this.OAM[i + 3] = 0xFF;\n        }\n    };\n\n    this.secOAMInit = function() {\n        (this.secOAM = []).length = 32;\n        this.secOAM.fill(0x100);\n    };\n\n    this.getCpuMemVal = function(location) {\n        location = location & 0xFFFF;\n        var temp;\n        //RAM\n        if (location >= 0 && location < 0x800) {\n            return this.cpuMem[location];\n        }\n        else if (location >= 0x8000 && location <= 0xFFFF) {\n            return this.nes.Mapper.getPRGRom(location);\n        }\n        //RAM mirrors\n        if (location >= 0x800 && location <= 0x1FFF) {\n            temp = location % 0x800;\n            return this.cpuMem[temp];\n        }\n        else if (location >= 0x2000 && location <= 0x2007) {\n            return this.getPPUReg(location);\n        }\n        else if (location >= 0x2008 && location <= 0x3FFF) {\n            temp = location - 0x2000;\n            temp = temp % 8;\n            return this.getPPUReg(0x2000 + temp);\n        }\n        else if (location == 0x4016) {\n            var btnStates = 0;\n            if (controllerStrobed) {\n                //While strobed Return button A status here \n                return 0;\n            }\n            if (this.controllerLatched) {\n                switch (this.latchCounter) {\n                    //button A\n                    case 0:\n                        btnStates = this.aBtnState;\n                        break;\n                        //button B\n                    case 1:\n                        btnStates = this.bBtnState;\n                        break;\n                        //button Select\n                    case 2:\n                        btnStates = this.selectBtnState;\n                        break;\n                        //button Start\n                    case 3:\n                        btnStates = this.startBtnState;\n                        break;\n                        //button Up\n                    case 4:\n                        btnStates = this.upBtnState;\n                        break;\n                        //button Down\n                    case 5:\n                        btnStates = this.downBtnState;\n                        break;\n                        //button Left\n                    case 6:\n                        btnStates = this.leftBtnState;\n                        break;\n                        //button Right\n                    case 7:\n                        btnStates = this.rightBtnState;\n                        break;\n                }\n                this.latchCounter++;\n                if (this.latchCounter >= 8) {\n                    this.latchCounter = 0;\n                    this.controllerLatched = false;\n                }\n                return btnStates | 0x40;\n            }\n            else if (!this.controllerLatched) {\n                return 0x40 | 1;\n            }\n        }\n        else if (location == 0x4017) {\n            return 0;\n        }\n        else if (location >= 0x4000 && location <= 0x4013) {\n            return this.getAPUReg(location);\n        }\n        else if (location == 0x4015) {\n            return this.getAPUReg(location);\n        }\n        else if (location >= 0x6000 && location <= 0x7FFF) {\n            return this.nes.Mapper.getPRGRAM(location);\n        }\n        else {\n            // alert(\'incorrect location to get from!\');\n            return this.cpuMem[location];\n        }\n\n    };\n\n    this.setCpuMemVal = function(location, value) {\n        var temp;\n        //RAM \n        if (location >= 0 && location < 0x800) {\n            temp = this.cpuMem[location];\n            this.cpuMem[location] = value;\n            return temp;\n        }\n\n        //RAM mirrors\n        if (location >= 0x800 && location <= 0x1FFF) {\n            temp = location % 0x800;\n            var temp2 = this.cpuMem[temp];\n            this.cpuMem[temp] = value;\n            return temp2;\n        }\n        else if (location >= 0x8000 && location <= 0xFFFF) {\n            this.nes.Mapper.setBank(value, location);\n            return 0;\n        }\n        else if ((location >= 0x2000 && location <= 0x2007) || (location == 0x4014)) {\n            return this.setPPUReg(location, value);\n        }\n        else if (location >= 0x2008 && location <= 0x3FFF) {\n            temp = location - 0x2008;\n            temp = temp % 8;\n            return this.setPPUReg((0x2000 + temp), value);\n        }\n        else if (location >= 0x4000 && location <= 0x4015) {\n            return this.setAPUReg(location, value);\n        }\n        else if (location == 0x4016) {\n            if (value == 1) {\n                controllerStrobed = true;\n                this.controllerLatched = false;\n            }\n            else if ((value == 0) && controllerStrobed) {\n                controllerStrobed = false;\n                this.controllerLatched = true;\n            }\n            return 0;\n        }\n        else if (location == 0x4017) {\n            return this.setAPUReg(location, value);\n        }\n        //PRG RAM\n        else if (location >= 0x6000 && location <= 0x7FFF) {\n            this.nes.Mapper.setPRGRAM(location, value);\n        }\n        else {\n            this.cpuMem[location] = value;\n            // alert("incorrect location to put data in!");\n        }\n    };\n\n    this.getPpuMemVal = function(location) {\n        if (location >= 0 && location < 0x2000) {\n            return this.nes.Mapper.getCHRRom(location);\n        }\n        else if (location >= 0x3F00 && location <= 0x3F1F) {\n            this.nes.PPU.PPUDATAReadBuffer = this.ppuMem[location - 0x1000];\n            location = location - 0x3F00;\n            if (this.nes.PPU.renderGreyscale)\n                return this.getPPUPalette(location) & 0x30;\n            else return this.getPPUPalette(location);\n        }\n        else if (location >= 0x3F20 && location <= 0x3FFF) {\n            this.nes.PPU.PPUDATAReadBuffer = this.ppuMem[location - 0x1000];\n            location = location % 0x20;\n            if (this.nes.PPU.renderGreyscale)\n                return this.getPPUPalette(location) & 0x30;\n            else return this.getPPUPalette(location);\n        }\n        return this.ppuMem[location];\n    };\n\n    this.setPpuMemVal = function(location, value) {\n        if (location >= 0 && location < 0x2000) {\n            this.ppuMem[location] = value;\n            this.nes.Mapper.setCHRRom(location, value);\n            this.chrRamWritten = true;\n            return;\n        }\n        else if (this.nameTableMirroring == 0) { //Vertical mirroring \n            if (location < 0x2400) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x800] = value;\n            }\n            else if (location < 0x2800) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x800] = value;\n            }\n            else if (location < 0x2C00) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x800] = value;\n            }\n            else if (location < 0x3000) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x800] = value;\n            }\n        }\n        else if (this.nameTableMirroring == 1) { //horizontal mirroring\n            if (location < 0x2400) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x400] = value;\n            }\n            else if (location < 0x2C00) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location + 0x400] = value;\n            }\n            else if (location < 0x2800) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x400] = value;\n            }\n            else if (location < 0x3000) {\n                this.ppuMem[location] = value;\n                this.ppuMem[location - 0x400] = value;\n            }\n        }\n        else if (this.nameTableMirroring == 2) {\n            location = location % 0x2000;\n            this.ppuMem[location + 0x2000] = value;\n            this.ppuMem[location + 0x2400] = value;\n            this.ppuMem[location + 0x2800] = value;\n            this.ppuMem[location + 0x2C00] = value;\n        }\n        else if (this.nameTableMirroring == 3) {\n            location = location % 0x2000;\n            this.ppuMem[location + 0x2000] = value;\n            this.ppuMem[location + 0x2400] = value;\n            this.ppuMem[location + 0x2800] = value;\n            this.ppuMem[location + 0x2C00] = value;\n        }\n        if (location >= 0x3000 && location <= 0x3EFF) {\n            location = location - 0x1000;\n        }\n        if (location >= 0x3F00 && location <= 0x3F1F) {\n            location = location - 0x3F00;\n            this.setPPUPalette(location, value);\n            return;\n        }\n        else if (location >= 0x3F20 && location <= 0x3FFF) {\n            location = location % 0x20;\n            this.setPPUPalette(location, value);\n            return;\n        }\n        else\n            this.ppuMem[location] = value;\n    };\n\n\n\n    this.setPPUPalette = function(location, value) {\n        this.nes.PPU.setPalette(location, value);\n    };\n\n    this.getPPUPalette = function(location) {\n        return this.nes.PPU.getPalette(location);\n    };\n\n    this.getPPUReg = function(location) {\n        switch (location) {\n            case 0x2000:\n                return ppuOpenBus;\n            case 0x2001:\n                return ppuOpenBus;\n                //PPUSTATUS\n            case 0x2002:\n                var temp = this.nes.PPU.getPPUSTATUS() & 0xF0;\n                temp = temp | (this.lsbLastWritePPU & 0x0F);\n                ppuOpenBus = ppuOpenBus & 0x1F;\n                ppuOpenBus = temp & 0xE0;\n                return temp;\n            case 0x2003:\n                return ppuOpenBus;\n                //OAMDATA\n            case 0x2004:\n                var currentCycle = this.nes.PPU.getCurrentCycle();\n                var currentScanline = this.nes.PPU.getCurrentScanline();\n                // if (currentScanline >= 240 && currentScanline < 261) {\n                //     ppuOpenBus =  this.OAM[this.nes.PPU.OAMADDR];\n                // }\n                // else if (currentCycle <= 256) {\n                //     // return this.nes.PPU.getOAMReadBuffer();\n                //     ppuOpenBus = 0x00;\n                // }\n                if (this.nes.PPU.rendering()) {\n                    if (currentScanline >= 0 && currentScanline <= 239) {\n                        if (currentCycle >= 257 && currentCycle <= 320) {\n                            ppuOpenBus = this.nes.PPU.getOAMReadBuffer();\n                        }\n                        else if (currentCycle >= 1 && currentCycle <= 64) {\n                            ppuOpenBus = 0xFF;\n                        }\n                    }\n                }\n                else {\n                    ppuOpenBus = this.OAM[this.nes.PPU.OAMADDR];\n                }\n                return ppuOpenBus;\n            case 0x2005:\n                return ppuOpenBus;\n            case 0x2006:\n                return ppuOpenBus;\n                //PPUDATA\n            case 0x2007:\n                ppuOpenBus = this.nes.PPU.getPPUDATA(location);\n                return ppuOpenBus;\n        }\n    };\n\n    this.setPPUReg = function(location, value) {\n        this.ppuRegWriteFlag = true;\n        this.lsbLastWritePPU = value;\n        ppuOpenBus = value;\n        switch (location) {\n            //PPUCTRL\n            case 0x2000:\n                this.nes.PPU.setPPUCTRL(value);\n                return 0x2000;\n                //PPUMASK    \n            case 0x2001:\n                this.nes.PPU.setPPUMASK(value);\n                return 0x2001;\n            case 0x2002:\n                break;\n                //OAMADDR\n            case 0x2003:\n                this.nes.PPU.OAMADDR = value;\n                return 0x2003;\n                //OAMDATA\n            case 0x2004:\n                var currentScanline = this.nes.PPU.getCurrentScanline();\n                if ((currentScanline == 261 || (currentScanline >= 0 && currentScanline < 240)) && this.nes.PPU.rendering()) {\n                    this.nes.PPU.OAMADDR++;\n                }\n                else {\n                    this.OAM[this.nes.PPU.OAMADDR] = value;\n                    this.nes.PPU.OAMADDR++;\n                }\n                return 0x2004;\n                //PPUSCROLL\n            case 0x2005:\n                this.nes.PPU.setPPUSCROLL(value);\n                return 0x2005;\n                //PPUADDR\n            case 0x2006:\n                this.nes.PPU.setPPUADDR(value);\n                return 0x2006;\n                //PPUDATA\n            case 0x2007:\n                this.nes.PPU.setPPUDATA(value);\n                return 0x2007;\n            case 0x4014:\n                this.ppuRegObj.OAMDMA = value;\n                this.setOAMDMA(this.ppuRegObj.OAMDMA);\n                return 0x4014;\n        }\n    };\n\n    this.getAPUReg = function(location) {\n        var temp = 0b00000000;\n        switch (location) {\n            case 0x4015:\n                if (this.nes.APU.frameIRQ) {\n                    this.nes.APU.frameIRQ = false;\n                    temp = temp | 0b01000000;\n                }\n                if (this.nes.APU.pulse1.lenCounter > 0) {\n                    temp = temp | 0b00000001;\n                }\n                if (this.nes.APU.pulse2.lenCounter > 0) {\n                    temp = temp | 0b00000010;\n                }\n                if (this.nes.APU.triangle1.lenCounter > 0) {\n                    temp = temp | 0b00000100;\n                }\n                if (this.nes.APU.noise1.lenCounter > 0) {\n                    temp = temp | 0b00001000;\n                }\n        }\n        return temp;\n    };\n\n    this.setAPUReg = function(location, value) {\n        switch (location) {\n            case 0x4000: //SQ1_ENV\n                this.nes.APU.setSQ1_ENV(value);\n                break;\n            case 0x4001:\n                this.nes.APU.setSQ1_SWEEP(value); //SQ1_SWEEP\n                break;\n            case 0x4002: //SQ1_LO\n                this.nes.APU.setSQ1_LO(value);\n                break;\n            case 0x4003: //SQ1_HI\n                this.nes.APU.setSQ1_HI(value);\n                break;\n            case 0x4004: //SQ2_ENV\n                this.nes.APU.setSQ2_ENV(value);\n                break;\n            case 0x4005:\n                this.nes.APU.setSQ2_SWEEP(value);\n                break;\n            case 0x4006:\n                this.nes.APU.setSQ2_LO(value);\n                break;\n            case 0x4007:\n                this.nes.APU.setSQ2_HI(value);\n                break;\n            case 0x4008:\n                this.nes.APU.setTRIControl(value);\n                break;\n            case 0x400A:\n                this.nes.APU.setTRI_LO(value);\n                break;\n            case 0x400B:\n                this.nes.APU.setTRI_HI(value);\n                break;\n            case 0x400C:\n                this.nes.APU.setNoise_ENV(value);\n                break;\n            case 0x400E:\n                this.nes.APU.setNoise_Period(value);\n                break;\n            case 0x400F:\n                this.nes.APU.setNoise_LenEnv(value);\n                break;\n            case 0x4015: //APUFLAGS\n                this.nes.APU.setAPUFlags(value);\n                break;\n            case 0x4017:\n                this.nes.APU.setFrameCounter(value);\n                break;\n        }\n        return 0;\n    };\n\n    this.getPPURegObj = function() {\n        return this.ppuRegObj;\n    };\n\n    this.getOAM = function() {\n        return this.OAM;\n    };\n\n    this.getNameTable = function() {\n        return this.ppuMem;\n    };\n\n    this.getAttrTable = function() {\n        return this.ppuMem;\n    };\n\n    this.setOAMDATA = function(value) {\n\n    };\n\n    this.setOAMADDR = function(value) {};\n\n    //OAM DMA copying\n    this.startOAMDMACopy = function() {\n        for (var i = 0; i < 256; i++) {\n            this.OAM[this.nes.PPU.OAMADDR + i] = this.cpuMem[(this.OAMDMA * 0x100) + i];\n        }\n    };\n\n    this.setOAMDMA = function(OAMDMA) {\n        var cyclesToHalt = 0;\n        if (this.nes.CPU.oddCycle) {\n            cyclesToHalt = 514;\n        }\n        else {\n            cyclesToHalt = 513;\n        }\n        this.OAMDMA = OAMDMA;\n        this.startOAMDMACopy();\n        for (var i = 0; i < cyclesToHalt; i++) {\n            this.nes.CPU.memoryRead(1, 0);\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/mmu.js?')},"./public/js/nes.js":
/*!**************************!*\
  !*** ./public/js/nes.js ***!
  \**************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nes; });\n/* harmony import */ var _iNES__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iNES */ "./public/js/iNES.js");\n/* harmony import */ var _mapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapper */ "./public/js/mapper.js");\n/* harmony import */ var _ppu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ppu */ "./public/js/ppu.js");\n/* harmony import */ var _cpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cpu */ "./public/js/cpu.js");\n/* harmony import */ var _mmu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mmu */ "./public/js/mmu.js");\n/* harmony import */ var _apu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./apu */ "./public/js/apu.js");\n/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./display */ "./public/js/display.js");\n/*global $ cancelAnimationFrame NES performance*/\n\n\n\n\n\n\n\n\n\nfunction nes() {\n    this.isRunning = false;\n    this.requestId;\n    this.cpuFreq = 1789773;\n    var frameCount = 0;\n    var frameCount2 = 0;\n    var t1 = 0;\n    var t2 = 0;\n    var skipFrame = false;\n    var skippedFrames = 0;\n    this.cyclesPerSecond;\n    this.mainDisplay = new _display__WEBPACK_IMPORTED_MODULE_6__["default"](document.getElementById(\'nesCanvas\'), this);\n    this.ines = new _iNES__WEBPACK_IMPORTED_MODULE_0__["default"](this);\n    this.Mapper = new _mapper__WEBPACK_IMPORTED_MODULE_1__["default"](this);\n    this.PPU = new _ppu__WEBPACK_IMPORTED_MODULE_2__["default"](this);\n    this.MMU = new _mmu__WEBPACK_IMPORTED_MODULE_4__["default"](this);\n    this.CPU = new _cpu__WEBPACK_IMPORTED_MODULE_3__["default"](this);\n    this.APU = new _apu__WEBPACK_IMPORTED_MODULE_5__["default"](this);\n    this.initGame = function(romContent) {\n        this.opcodes = new Uint8Array(romContent);\n        this.APU.init();\n        this.MMU.OAMInit();\n        this.PPU.secOAMInit();\n        this.PPU.initScreenBuffer();\n        this.PPU.initSpriteOpUnits();\n        this.ines.parseRom(this.opcodes);\n        this.MMU.nameTableMirroring = this.ines.mirroring;\n        this.CPU.reset();\n        this.mainDisplay.screenReset();\n        frameCount = 0;\n        this.cyclesPerSecond = 0;\n        this.isRunning = true;\n    };\n\n    this.renderScreen = function() {\n        // this.mainDisplay.updateCanvas();\n    };\n\n    this.renderFrame = function() {\n        this.CPU.frame();\n        // if (skipFrame)\n        // skipFrame = !skipFrame;\n        // frameCount++;\n        // frameCount2++;\n        // if (frameCount == 2) {\n        //     t2 = Date.now();\n        //     frameCount = 0;\n        //     if (t2 - t1 > (16.7 * 2)) {\n        //         skipFrame = true;\n        //         // skippedFrames++;\n        //         // console.log("skipped frmae");\n                \n        //     }\n        //     t1 = Date.now();\n        // }\n        // if (frameCount2 == 60) {\n        //     console.log("skippedFrames = " + skippedFrames);\n        //     skippedFrames = 0;\n        //     frameCount2 = 0;\n        // }\n        // this.mainDisplay.updateCanvas();\n        // this.renderScreen();\n        // requestAnimationFrame(this.renderFrame);\n    };\n\n    this.readOpcodeFile = function(e) {\n        var file = e.target.files[0];\n        if (!file) {\n            return;\n        }\n        var reader = new FileReader();\n        reader.onload = this.initGame(this.result);\n        reader.readAsArrayBuffer(file);\n    };\n\n    this.reset = function() {\n        this.mainDisplay = null;\n        this.PPU = null;\n        this.MMU = null;\n        this.CPU = null;\n        this.APU = null;\n    };\n}\n\nif (window !== undefined)\n    window.NES = nes;\n\n\n//# sourceURL=webpack:///./public/js/nes.js?')},"./public/js/noise.js":
/*!****************************!*\
  !*** ./public/js/noise.js ***!
  \****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return noise; });\n\nfunction noise() {\n    this.dividerPeriod = 0;\n    this.volume = 0;\n    this.envStartFlag = false;\n    this.decayLvlCount = 0;\n    this.sawEnvDisable = true;\n    this.lenCounterDisable = false;\n    this.modeFlag = false;\n    this.period = 0;\n    this.register = 1;\n    this.originalPeriod = 0;\n\n    this.clockDecayLevelCounter = function() {\n        if (this.decayLvlCount == 0) {\n            if (this.lenCounterDisable) { //if loop flag set, reload the decay \n                this.decayLvlCount = 15;\n            }\n        }\n        else {\n            this.decayLvlCount--;\n        }\n    };\n\n    this.updateEnvelope = function() {\n        if (!this.envStartFlag) {\n            //Now clock divider\n            if (this.dividerPeriod == 0) { //Reload divider period\n                this.dividerPeriod = this.volume + 1;\n                //Now clock Decay level counter\n                this.clockDecayLevelCounter();\n            }\n            else {\n                this.dividerPeriod--;\n                //Now clock Decay level counter\n                this.clockDecayLevelCounter();\n            }\n        }\n        else {\n            this.envStartFlag = false; //Clear Start flag\n            this.decayLvlCount = 15; //Reload Decay level counter\n            this.dividerPeriod = this.volume + 1; //Reload divider period\n        }\n    };\n\n    this.clock = function() {\n        if (this.period <= 0) {\n            this.shiftRegister();\n            this.period = this.originalPeriod;\n        }\n        else {\n            this.period--;\n        }\n    };\n\n    this.updateLenCounter = function() {\n        if (!this.enabled) {\n            this.lenCounter = 0;\n        }\n        else if (!this.controlFlag && this.lenCounter > 0) {\n            this.lenCounter--;\n        }\n    };\n\n    this.output = function() {\n        if (((this.register & 0x01) == 0x01) || this.lenCounter <= 0) {\n            return 0;\n        }\n        if (!this.sawEnvDisable) {\n            return this.decayLvlCount;\n        }\n        else {\n            return this.volume;\n        }\n    };\n\n    this.shiftRegister = function() {\n        var feedback = 0;\n        if (this.modeFlag) {\n            feedback = (this.register & 0x01) ^ ((this.register & 0x40) >> 6);\n        }\n        else {\n            feedback = (this.register & 0x01) ^ ((this.register & 0x02) >> 1);\n        }\n        this.register = this.register >> 1;\n        if (feedback == 1) {\n            this.register = this.register | 0x8000;\n        }\n    };\n\n}\n\n\n//# sourceURL=webpack:///./public/js/noise.js?')},"./public/js/ppu.js":
/*!**************************!*\
  !*** ./public/js/ppu.js ***!
  \**************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ppu; });\n\nfunction ppu(nes) {\n    this.nes = nes;\n    //Render VARS\n    var currentScanline = 261; //start from pre-render line\n    var currentCycle = 0;\n    var currentScanlineBufferIndex = 0;\n    var skipFrame = false;\n    var offScreenBuffer = new Uint32Array(256 * 240);\n    this.nmi_occurred = false;\n    this.CHRGrid = [];\n    this.BGRCHRGrid = [];\n    // this.render = this.renderPixelFast;\n    var palette = new Uint8Array(64);\n    var basePalette = 0;\n    var paletteColorsRendered; // = new Uint32Array();\n    // this.paletteColors = [0x7C7C7C,\n    //     0x0000FC,\n    //     0x0000BC,\n    //     0x4428BC,\n    //     0x940084,\n    //     0xA80020,\n    //     0xA81000,\n    //     0x881400,\n    //     0x503000,\n    //     0x007800,\n    //     0x006800,\n    //     0x005800,\n    //     0x004058,\n    //     0x000000,\n    //     0x000000,\n    //     0x000000,\n    //     0xBCBCBC,\n    //     0x0078F8,\n    //     0x0058F8,\n    //     0x6844FC,\n    //     0xD800CC,\n    //     0xE40058,\n    //     0xF83800,\n    //     0xE45C10,\n    //     0xAC7C00,\n    //     0x00B800,\n    //     0x00A800,\n    //     0x00A844,\n    //     0x008888,\n    //     0x000000,\n    //     0x000000,\n    //     0x000000,\n    //     0xF8F8F8,\n    //     0x3CBCFC,\n    //     0x6888FC,\n    //     0x9878F8,\n    //     0xF878F8,\n    //     0xF85898,\n    //     0xF87858,\n    //     0xFCA044,\n    //     0xF8B800,\n    //     0xB8F818,\n    //     0x58D854,\n    //     0x58F898,\n    //     0x00E8D8,\n    //     0x787878,\n    //     0x000000,\n    //     0x000000,\n    //     0xFCFCFC,\n    //     0xA4E4FC,\n    //     0xB8B8F8,\n    //     0xD8B8F8,\n    //     0xF8B8F8,\n    //     0xF8A4C0,\n    //     0xF0D0B0,\n    //     0xFCE0A8,\n    //     0xF8D878,\n    //     0xD8F878,\n    //     0xB8F8B8,\n    //     0xB8F8D8,\n    //     0x00FCFC,\n    //     0xF8D8F8,\n    //     0x000000,\n    //     0x000000\n    // ];\n    this.paletteColors = [\n        [0x7C, 0x7C, 0x7C],\n        [0x00, 0x00, 0xFC],\n        [0x00, 0x00, 0xBC],\n        [0x44, 0x28, 0xBC],\n        [0x94, 0x00, 0x84],\n        [0xA8, 0x00, 0x20],\n        [0xA8, 0x10, 0x00],\n        [0x88, 0x14, 0x00],\n        [0x50, 0x30, 0x00],\n        [0x00, 0x78, 0x00],\n        [0x00, 0x68, 0x00],\n        [0x00, 0x58, 0x00],\n        [0x00, 0x40, 0x58],\n        [0x00, 0x00, 0x00],\n        [0x00, 0x00, 0x00],\n        [0x00, 0x00, 0x00],\n        [0xBC, 0xBC, 0xBC],\n        [0x00, 0x78, 0xF8],\n        [0x00, 0x58, 0xF8],\n        [0x68, 0x44, 0xFC],\n        [0xD8, 0x00, 0xCC],\n        [0xE4, 0x00, 0x58],\n        [0xF8, 0x38, 0x00],\n        [0xE4, 0x5C, 0x10],\n        [0xAC, 0x7C, 0x00],\n        [0x00, 0xB8, 0x00],\n        [0x00, 0xA8, 0x00],\n        [0x00, 0xA8, 0x44],\n        [0x00, 0x88, 0x88],\n        [0x00, 0x00, 0x00],\n        [0x00, 0x00, 0x00],\n        [0x00, 0x00, 0x00],\n        [0xF8, 0xF8, 0xF8],\n        [0x3C, 0xBC, 0xFC],\n        [0x68, 0x88, 0xFC],\n        [0x98, 0x78, 0xF8],\n        [0xF8, 0x78, 0xF8],\n        [0xF8, 0x58, 0x98],\n        [0xF8, 0x78, 0x58],\n        [0xFC, 0xA0, 0x44],\n        [0xF8, 0xB8, 0x00],\n        [0xB8, 0xF8, 0x18],\n        [0x58, 0xD8, 0x54],\n        [0x58, 0xF8, 0x98],\n        [0x00, 0xE8, 0xD8],\n        [0x78, 0x78, 0x78],\n        [0x00, 0x00, 0x00],\n        [0x00, 0x00, 0x00],\n        [0xFC, 0xFC, 0xFC],\n        [0xA4, 0xE4, 0xFC],\n        [0xB8, 0xB8, 0xF8],\n        [0xD8, 0xB8, 0xF8],\n        [0xF8, 0xB8, 0xF8],\n        [0xF8, 0xA4, 0xC0],\n        [0xF0, 0xD0, 0xB0],\n        [0xFC, 0xE0, 0xA8],\n        [0xF8, 0xD8, 0x78],\n        [0xD8, 0xF8, 0x78],\n        [0xB8, 0xF8, 0xB8],\n        [0xB8, 0xF8, 0xD8],\n        [0x00, 0xFC, 0xFC],\n        [0xF8, 0xD8, 0xF8],\n        [0x00, 0x00, 0x00],\n        [0x00, 0x00, 0x00]\n    ];\n\n    var bitReversalLookUp = [\n        0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,\n        0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,\n        0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,\n        0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,\n        0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,\n        0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,\n        0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,\n        0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,\n        0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,\n        0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,\n        0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,\n        0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,\n        0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,\n        0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,\n        0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,\n        0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF\n    ];\n\n    //PPUCTRL vars\n    this.baseNameTblAddr = 0x2000;\n    this.vRamAddrInc = 1;\n    this.spritePatTblAddr = 0;\n    this.backgroundPatTblAddr = 0;\n    var spriteSize = 8;\n    this.ppuMasterSlave = \'readBackdrop\';\n    this.nmi_output = false;\n    var nmi_output_prev = false;\n\n    //PPUMASK vars\n    this.renderGreyscale = false;\n    var renderBGLeftMost = false;\n    var renderSpritesLeftMost = false;\n    var renderBackground = 0;\n    var renderSprite = 0;\n    this.renderEmphRed = false;\n    this.renderEmphGreen = false;\n    this.renderEmphBlue = false;\n\n    //PPUSTATUS vars\n    this.ppuStatusBits = 0b00000000;\n    this.spriteOverflow = false;\n    //this.spriteHit = false;\n    this.vBlankStarted = false;\n    this.sprite0Hit = false;\n\n    //PPUSCROLL vars\n    this.xScroll = 0;\n    this.yScroll = 0;\n    this.coarseXScroll = 0;\n    this.coarseYScroll = 0;\n    this.fineXScroll = 0;\n    this.fineYScroll = 0;\n    this.OAM = [];\n\n    //OAMADDR \n    this.OAMADDR = 0x00;\n\n    //OAMDATA\n    this.OAMDATA = 0x00;\n\n    //OAMDMA\n    this.OAMDMA = 0x00;\n\n    this.spriteGrid = [];\n    this.backGroundGrid = [];\n    var secOAM = [];\n\n    //Update PPUCTRL status\n    this.setPPUCTRL = function(PPUCTRL) {\n        var temp;\n        temp = PPUCTRL & 0x03;\n        this.baseNameTblAddr = temp;\n        temp = (PPUCTRL >> 2) & 0x01;\n        if (temp == 0)\n            this.vRamAddrInc = 1;\n        else\n            this.vRamAddrInc = 32;\n        temp = (PPUCTRL >> 3) & 0x01;\n        if (temp == 0)\n            this.spritePatTblAddr = 0;\n        else\n            this.spritePatTblAddr = 1;\n        temp = (PPUCTRL >> 4) & 0x01;\n        if (temp == 0)\n            this.backgroundPatTblAddr = 0;\n        else\n            this.backgroundPatTblAddr = 1;\n        temp = (PPUCTRL >> 5) & 0x01;\n        if (temp == 0)\n            spriteSize = 8;\n        else\n            spriteSize = 16;\n        temp = (PPUCTRL >> 6) & 0x01;\n        if (temp == 0)\n            this.ppuMasterSlave = \'readBackdrop\';\n        else\n            this.ppuMasterSlave = \'outputColor\';\n        temp = (PPUCTRL >> 7) & 0x01;\n        if (temp == 0) {\n            this.nmi_output = false;\n            nmi_output_prev = false;\n        }\n        else {\n            this.nmi_output = true;\n            if ((this.ppuStatusBits & 0x80) == 0x80 && !nmi_output_prev) {\n                this.nes.CPU.doNMI = true;\n                this.nes.CPU.IRQToRun = 2;\n            }\n            nmi_output_prev = true;\n        }\n\n\n        /*New cycle accurate logic*/\n        //Nametable select\n        this.t &= ~(0x0C00);\n        this.t |= (PPUCTRL & 0x03) << 10;\n    };\n\n    //Update PPUMASK status\n    this.setPPUMASK = function(PPUMASK) {\n        //DEbug \n        // var a = currentCycle;\n        // var b = currentScanline;\n        var temp;\n        temp = PPUMASK & 0x01;\n        if (temp == 0)\n            this.renderGreyscale = false;\n        else\n            this.renderGreyscale = true;\n        temp = (PPUMASK >> 1) & 0x01;\n        if (temp == 0) {\n            renderBGLeftMost = false;\n            this.render = this.renderPixel;\n        }\n        else {\n            renderBGLeftMost = true;\n            this.render = this.renderPixelFast;\n        }\n        temp = (PPUMASK >> 2) & 0x01;\n        if (temp == 0) {\n            renderSpritesLeftMost = false;\n            this.render = this.renderPixel;\n        }\n        else {\n            renderSpritesLeftMost = true;\n            this.render = this.renderPixelFast;\n        }\n        temp = (PPUMASK >> 3) & 0x01;\n        if (temp == 0)\n            renderBackground = 0;\n        else\n            renderBackground = 1;\n        temp = (PPUMASK >> 4) & 0x01;\n        if (temp == 0)\n            renderSprite = 0;\n        else\n            renderSprite = 1;\n        temp = (PPUMASK >> 5) & 0x01;\n        if (temp == 0)\n            this.renderEmphRed = false;\n        else\n            this.renderEmphRed = true;\n        temp = (PPUMASK >> 6) & 0x01;\n        if (temp == 0)\n            this.renderEmphGreen = false;\n        else\n            this.renderEmphGreen = true;\n        temp = (PPUMASK >> 7) & 0x01;\n        if (temp == 0)\n            this.renderEmphBlue = false;\n        else\n            this.renderEmphBlue = true;\n    };\n\n\n    //Update OAMADDR\n    this.setOAMADDR = function(OAMADDR) {\n        this.OAMADDR = OAMADDR;\n    };\n\n    //Update PPUADDR\n    this.setPPUADDR = function(PPUADDR) {\n        this.PPUADDR = PPUADDR;\n    };\n\n    //Load PPU Palette values\n    this.setPalette = function(index, value) {\n        if (index == 0x10) {\n            palette[0x00] = value;\n            basePalette = value;\n        }\n        else if (index == 0x00) {\n            palette[0x10] = value;\n            basePalette = value;\n        }\n        palette[index] = value;\n    };\n\n    this.getPalette = function(index) {\n        return palette[index];\n    };\n\n    this.initPalette = function() {\n        paletteColorsRendered = new Uint32Array(this.paletteColors.length);\n        for (var i = 0; i < paletteColorsRendered.length; i++) {\n            paletteColorsRendered[i] = 0xFF000000;\n        }\n        for (var i = 0; i < this.paletteColors.length; i++) {\n            paletteColorsRendered[i] = 0xFF000000 | this.paletteColors[i][2] << 16 | this.paletteColors[i][1] << 8 | this.paletteColors[i][0];\n        }\n    };\n\n    this.getOffScreenBuffer = function() {\n        return offScreenBuffer;\n    };\n\n    this.initScreenBuffer = function() {\n        this.render = this.renderPixelFast;\n        this.initPalette();\n        for (var i = 0; i < 64; i++) {\n            palette[i] = 0;\n        }\n\n        this.nes.mainDisplay.initScreenBuffer();\n        for (var i = 0; i < 256; i++) {\n            sprLkpTbl[i] = 0;\n        }\n        for (var i = 0; i < 256 * 240; i++) {\n            offScreenBuffer[i] = 0xFF000000;\n        }\n    };\n    var sprLkpTbl = new Uint8Array(256);\n\n    this.secOAMInit = function() {\n        (secOAM = []).length = 32;\n        secOAM.fill(0x100);\n    };\n\n    /*\n    t & v \n    yyy NN YYYYY XXXXX\n    ||| || ||||| +++++-- coarse X scroll\n    ||| || +++++-------- coarse Y scroll\n    ||| ++-------------- nametable select\n    +++----------------- fine Y scroll\n    */\n    //OAM registers\n    var n = 0;\n    var m = 0;\n    var secOAMIndex = 0;\n    var allSpritesFound = false; //if all 8 sprites have been found\n    var allSpritesEvaluated = false; //if all 64 sprites in OAM have been evaluated\n    this.oamEvalComplete = false;\n    var spriteInRange = false;\n    var oamReadBuffer = 0;\n    //Scroll registers\n    var v = 0;\n    this.t = 0;\n    this.x = 0;\n    this.w = 0;\n    var y = 0;\n    var nt_byte = 0;\n    var at_byte = 0;\n    var bgL = 0x0000;\n    var bgH = 0x0000;\n    var bgShiftL = 0;\n    var bgShiftH = 0;\n    var atShiftL = 0;\n    var atShiftH = 0;\n    var atH = 0x0000;\n    var atL = 0x0000;\n    this.at_bits = 0;\n    this.at_latch = 0;\n    this.PPUDATAReadBuffer = 0;\n    var bgPixel = 0;\n    var tempBgHBit = 0,\n        tempBgLBit = 0,\n        tempAtHBit = 0,\n        tempAtLBit = 0,\n        shiftAmt = 0,\n        bgHShiftAmt = 0,\n        bgLShiftAmt = 0;\n    var spritePixel = 0,\n        spritePixelColor = 0,\n        tempSpriteH = 0,\n        tempSpriteL = 0,\n        tempSpritePriority = 0;\n    var outputPixel = 0;\n    var spriteOpUnits = []; //Sprite output unit combined of two 8-bit shift registers\n    //One attribute latch and 1 X-position counter\n    this.initSpriteOpUnits = function() {\n        for (var i = 0; i < 8; i++) {\n            spriteOpUnits.push(new Array(0, 0, 0, 0, 0)); //X, ShiftCount, low bitmap, high bitmap, attr \n            // this.spriteOpUnits.push({ bitmapLow: 0, bitmapHigh: 0, attr: 0, X: 0xFF, isActive: false, shiftCount: 0 });\n        }\n    };\n\n    var currentSpriteOpUnit = 0;\n\n    this.getCurrentScanline = function() {\n        return currentScanline;\n    };\n\n    this.getCurrentCycle = function() {\n        return currentCycle;\n    };\n    this.getOAMReadBuffer = function() {\n        return oamReadBuffer;\n    };\n    var ppuStatusReadCycle = -1;\n    var suppressNMI = false;\n    this.getPPUSTATUS = function() {\n        var prevStatus = this.ppuStatusBits;\n        //clear PPUSTATUS vblank indicators\n        this.ppuStatusBits = this.ppuStatusBits & 0x7F;\n        if (currentScanline == 241) {\n            ppuStatusReadCycle = currentCycle;\n            //simultaneous read to vbl as its set, so suppress NMI\n            switch (currentCycle) {\n                case 1: //0 \n                    prevStatus &= 0x7F;\n                    this.nes.CPU.IRQToRun = 0;\n                    suppressNMI = true;\n                    break;\n                case 2: //2\n                    this.nes.CPU.IRQToRun = 0;\n                    suppressNMI = true;\n                    break;\n                case 3: //2:\n                    this.nes.CPU.IRQToRun = 0;\n                    suppressNMI = true;\n                    break;\n                default:\n                    suppressNMI = false;\n            }\n        }\n        else {\n            ppuStatusReadCycle = -1;\n            // this.w = 0;\n        }\n        this.w = 0;\n        return prevStatus;\n    };\n\n    this.getPPUDATA = function(location) {\n        var returnValue = 0;\n        if (currentScanline >= 240 && currentScanline <= 260) {\n            returnValue = this.getReadBuffer(v);\n            if (!vIncremented)\n                v += this.vRamAddrInc;\n        }\n        else if (currentScanline == 261 | (currentScanline >= 0 && currentScanline < 240)) {\n            returnValue = this.getReadBuffer(v);\n            if (renderBackground || renderSprite) {\n                this.updateXScroll();\n                this.updateYScroll();\n            }\n            else {\n                if (!vIncremented)\n                    v += this.vRamAddrInc;\n            }\n        }\n        return returnValue;\n    };\n\n    this.setPPUDATA = function(value) {\n        if (currentScanline >= 240 && currentScanline <= 260) {\n            this.nes.MMU.setPpuMemVal(v, value);\n            if (!vIncremented)\n                v += this.vRamAddrInc;\n        }\n        else if (currentScanline == 261 | (currentScanline >= 0 && currentScanline < 240)) {\n            this.nes.MMU.setPpuMemVal(v, value);\n            if (renderBackground || renderSprite) {\n                this.updateXScroll();\n                this.updateYScroll();\n            }\n            else {\n                if (!vIncremented)\n                    v += this.vRamAddrInc;\n            }\n        }\n    };\n\n    this.getReadBuffer = function(location) {\n        var returnValue = this.PPUDATAReadBuffer;\n        if (location >= 0x0000 && location <= 0x3EFF) {\n            this.PPUDATAReadBuffer = this.nes.MMU.getPpuMemVal(location);\n        }\n        else {\n            returnValue = this.nes.MMU.getPpuMemVal(location);\n        }\n        return returnValue;\n    };\n\n    this.setPPUSCROLL = function(PPUSCROLL) {\n        if (this.w == 0) {\n            this.t &= ~(0x1F);\n            this.t |= PPUSCROLL >> 3;\n            this.x = PPUSCROLL & 0x07;\n            shiftAmt = 0b1000000000000000 >> this.x;\n            bgLShiftAmt = 15 - this.x;\n            bgHShiftAmt = 14 - this.x;\n            this.w = 1;\n        }\n        else if (this.w == 1) {\n            this.t &= ~(0x73E0);\n            this.t |= (PPUSCROLL & 0x07) << 12;\n            this.t |= (PPUSCROLL & 0xF8) << 2;\n            this.w = 0;\n        }\n    };\n\n    this.setPPUADDR = function(PPUADDR) {\n        if (this.w == 0) {\n            this.t &= ~(0x7F00);\n            this.t |= (PPUADDR & 0x3F) << 8;\n            this.w = 1;\n        }\n        else if (this.w == 1) {\n            this.t &= ~(0xFF);\n            this.t |= PPUADDR;\n            v = this.t;\n            this.w = 0;\n        }\n    };\n\n    var oddFrameCycleSkipped = 0;\n    var sprite0Evaluated = false;\n    var checkSprite0Hit = false;\n\n    this.clock = function() {\n        // if (!skipFrame) {\n            if (vIncremented)\n                vIncremented = false;\n            //visible scanline\n            if (currentScanline < 240) {\n                if (currentCycle == 0) {\n                    if (oddFrameCycleSkipped) {\n                        nt_byte = this.nes.MMU.ppuMem[0x2000 | (v & 0x0FFF)]; //this.getNameTableByte();\n                        oddFrameCycleSkipped = 0;\n                    }\n                    currentSpriteOpUnit = 0;\n                    // this.renderPixel();\n                    this.render();\n                }\n                else if (currentCycle < 256) {\n                    this.memoryFetch();\n                    // this.renderPixel();\n                    this.render();\n                    if (currentCycle > 64) {\n                        if (renderBackground || renderSprite) {\n                            //Even cycles\n                            if ((currentCycle & 1) == 0) {\n                                if (!allSpritesFound && !allSpritesEvaluated) {\n                                    secOAM[secOAMIndex] = oamReadBuffer;\n                                    if (spriteInRange) {\n                                        if (n == 0) {\n                                            sprite0Evaluated = true;\n                                        }\n                                        secOAMIndex++;\n                                        if (secOAMIndex == 32) {\n                                            allSpritesFound = true;\n                                        }\n                                        m++;\n                                        if (m == 4) {\n                                            m = 0;\n                                            n++;\n                                            if (n >= 64) {\n                                                allSpritesEvaluated = true;\n                                                n = 0;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        n++;\n                                        if (n >= 64) {\n                                            allSpritesEvaluated = true;\n                                            n = 0;\n                                        }\n                                    }\n                                }\n                            }\n                            //Odd cycles\n                            else {\n                                if (!allSpritesFound && !allSpritesEvaluated) {\n                                    if (m == 0) {\n                                        oamReadBuffer = this.nes.MMU.OAM[this.OAMADDR + 4 * n];\n                                        spriteInRange = (oamReadBuffer > (currentScanline - spriteSize)) && (oamReadBuffer <= currentScanline);\n                                        if (spriteInRange) {\n                                            if (n == 0) {\n                                                sprite0Evaluated = true;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        if (spriteInRange) {\n                                            oamReadBuffer = this.nes.MMU.OAM[4 * n + m];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if (currentCycle == 1) {\n                        (secOAM = []).length = 32;\n                        secOAM.fill(0x100);\n                        allSpritesFound = false;\n                        allSpritesEvaluated = false;\n                        sprite0Evaluated = false;\n                        secOAMIndex = 0;\n                        n = 0, m = 0;\n                    }\n                }\n                else if (currentCycle == 256) {\n                    //sprite 0 hit flag for pixel 254\n                    if (sprite0Drawn && currentCycle == sprite0HitTargetCycle) {\n                        this.ppuStatusBits = this.ppuStatusBits & 0b10111111;\n                        this.ppuStatusBits = this.ppuStatusBits | 0b01000000;\n                    }\n                    this.memoryFetch();\n                    this.updateYScroll(); //FIXME\n\n                    if (renderBackground || renderSprite) {\n                        //Even cycles\n                        if (!allSpritesFound && !allSpritesEvaluated) {\n                            secOAM[secOAMIndex] = oamReadBuffer;\n                            if (spriteInRange) {\n                                if (n == 0) {\n                                    sprite0Evaluated = true;\n                                }\n                                secOAMIndex++;\n                                if (secOAMIndex == 32) {\n                                    allSpritesFound = true;\n                                }\n                                m++;\n                                if (m == 4) {\n                                    m = 0;\n                                    n++;\n                                    if (n >= 64) {\n                                        allSpritesEvaluated = true;\n                                        n = 0;\n                                    }\n                                }\n                            }\n                            else {\n                                n++;\n                                if (n >= 64) {\n                                    allSpritesEvaluated = true;\n                                    n = 0;\n                                }\n                            }\n                        }\n                    }\n                }\n                //fetch sprite tile data for next scanline\n                else if (currentCycle <= 320) {\n                    if (currentCycle == 257) {\n                        this.reloadShiftRegisters();\n                        this.copyHScroll();\n                        checkSprite0Hit = sprite0Evaluated;\n                    }\n                    this.fetchSprites();\n                    if (renderBackground || renderSprite)\n                        this.OAMADDR = 0;\n                }\n                //2 tile data for next scanline\n                else if (currentCycle <= 336) {\n                    this.memoryFetch();\n                    oamReadBuffer = secOAM[0];\n                }\n                //2 usused nametable byte fetch\n                else if (currentCycle == 338 || currentCycle == 340) {\n                    nt_byte = this.nes.MMU.ppuMem[0x2000 | (v & 0x0FFF)]; //this.getNameTableByte();\n                    oamReadBuffer = secOAM[0];\n                }\n                else if (currentCycle == 339)\n                    oamReadBuffer = secOAM[0];\n            }\n            //post-render scanline\n            // else if (currentScanline == 240) {\n            //     //PPU idles\n            //     \n            // }\n            //VBlank Scanlines\n            else if (currentScanline == 241) {\n                if (currentCycle == 1) {\n                    //Set V-Blank\n                    this.ppuStatusBits = this.ppuStatusBits & 0x7F;\n                    // if (ppuStatusReadCycle !== 0)\n                    if (ppuStatusReadCycle !== 1)\n                        this.ppuStatusBits = this.ppuStatusBits | 0x80;\n                    this.nmi_occurred = true;\n                    ppuStatusReadCycle = -1;\n                }\n                else if (currentCycle == 3) {\n                    if (this.nmi_output && !suppressNMI) {\n                        this.nes.CPU.doNMI = true;\n                        this.nes.CPU.IRQToRun = 1;\n                    }\n                    suppressNMI = false;\n                }\n            }\n            //pre-render scanline\n            else if (currentScanline == 261) {\n                if (currentCycle == 0 && this.nes.CPU.skipFrame) {\n                    skipFrame = true;\n                    currentCycle++;\n                    return false;\n                }\n                //reload vertical scroll bits\n                else if (currentCycle >= 1 && currentCycle <= 256) {\n                    if (currentCycle == 1) {\n                        //clear PPUSTATUS vblank indicator\n                        this.ppuStatusBits = this.ppuStatusBits & 0x7F;\n                        this.nmi_occurred = false;\n                        //clear sprite hit\n                        this.ppuStatusBits = this.ppuStatusBits & 0xBF;\n                        // this.sprite0Hit = false;\n                        sprite0Drawn = false;\n                        //clear sprite overflow\n                        this.ppuStatusBits = this.ppuStatusBits & 0xDF;\n                    }\n                    this.memoryFetch();\n                    if (currentCycle == 256)\n                        this.updateYScroll();\n                }\n                else if (currentCycle <= 320) {\n                    if (currentCycle == 257) {\n                        this.copyHScroll();\n                    }\n                    this.fetchSprites();\n                    if (renderBackground || renderSprite)\n                        this.OAMADDR = 0;\n\n                    if (currentCycle >= 280 && currentCycle <= 304) {\n                        this.copyVScroll();\n                    }\n                }\n                //2 tile data for next scanline\n                else if (currentCycle <= 336) {\n                    this.memoryFetch();\n                }\n                else if (currentCycle == 339 && this.nes.CPU.oddFrame && renderBackground) {\n                    currentCycle = 0;\n                    this.nes.CPU.renderedScanline = currentScanline;\n                    currentScanline = 0;\n                    currentScanlineBufferIndex = 0;\n                    oddFrameCycleSkipped = 1;\n                    return true;\n                }\n                else if (currentCycle == 338 || currentCycle == 340)\n                    nt_byte = this.nes.MMU.ppuMem[0x2000 | (v & 0x0FFF)]; //this.getNameTableByte();\n            }\n            currentCycle++;\n            if (currentCycle == 341) {\n                currentCycle = 0;\n                this.nes.CPU.renderedScanline = currentScanline;\n                if (currentScanline == 260) {\n                    this.nes.mainDisplay.updateCanvas();\n                }\n                currentScanline++;\n                if (currentScanline == 262) {\n                    currentScanline = 0;\n                    currentScanlineBufferIndex = 0;\n                }\n                return true;\n            }\n            return false;\n        // }\n        // else {\n        //     this.fakeClock();\n        // }\n    };\n\n    this.fakeClock = function() {\n        // if (currentScanline < 240) {\n        //     if (currentCycle > 0 && currentCycle < 256) {\n        //         if (currentCycle % 8 == 0) {\n        //             this.updateXScroll();\n        //         }\n        //         if (currentCycle == 256) {\n        //             this.updateXScroll();\n        //             this.updateYScroll();\n        //         }\n        //         if (currentCycle == 257) {\n        //             this.copyHScroll();\n        //         }\n        //         if (currentCycle >= 321 && currentCycle <= 336) {\n        //             if (currentCycle % 8 == 0) {\n        //                 this.updateXScroll();\n        //             }\n        //         }\n        //     }\n        // }\n        // if (sprite0DrawnPrev && (currentScanline == sprite0HitTargetScanline) && (currentCycle == sprite0HitTargetCycle)) {\n        //     this.ppuStatusBits = this.ppuStatusBits & 0b10111111;\n        //     this.ppuStatusBits = this.ppuStatusBits | 0b01000000;\n        //     sprite0DrawnPrev = false;\n        // }\n        if (currentScanline == 241) {\n            if (currentCycle == 1) {\n                this.ppuStatusBits = this.ppuStatusBits & 0xBF; //sprite 0 clear\n                this.ppuStatusBits = this.ppuStatusBits & 0x7F; //vblank clear\n                if (ppuStatusReadCycle !== 1)\n                    this.ppuStatusBits = this.ppuStatusBits | 0x80;\n                this.nmi_occurred = true;\n                ppuStatusReadCycle = -1;\n            }\n            else if (currentCycle == 3) {\n                if (this.nmi_output && !suppressNMI) {\n                    this.nes.CPU.doNMI = true;\n                    this.nes.CPU.IRQToRun = 1;\n                }\n                suppressNMI = false;\n            }\n        }\n        else if (currentScanline == 261) {\n            if (currentCycle >= 1 && currentCycle <= 256) {\n                if (currentCycle == 1) {\n                    this.ppuStatusBits = this.ppuStatusBits & 0x7F;\n                    this.nmi_occurred = false;\n                    this.ppuStatusBits = this.ppuStatusBits & 0xBF;\n                    sprite0Drawn = false;\n                }\n                // if (currentCycle % 8 == 0) {\n                //     this.updateXScroll();\n                // }\n                // if (currentCycle == 256) {\n                //     this.updateYScroll();\n                // }\n            }\n            // else if (currentCycle == 257) {\n            //     this.copyHScroll();\n            // }\n            // else if (currentCycle >= 280 && currentCycle <= 304) {\n            //     this.copyVScroll();\n            // }\n            // else if (currentCycle >= 321 && currentCycle <= 336) {\n            //     if (currentCycle % 8 == 0) {\n            //         this.updateXScroll();\n            //     }\n            // }\n            else if (currentCycle == 339 && this.nes.CPU.oddFrame && renderBackground) {\n                currentCycle = 0;\n                this.nes.CPU.renderedScanline = currentScanline;\n                currentScanline = 0;\n                currentScanlineBufferIndex = 0;\n                oddFrameCycleSkipped = 1;\n                return true;\n            }\n        }\n        currentCycle++;\n        if (currentCycle == 341) {\n            currentCycle = 0;\n            this.nes.CPU.renderedScanline = currentScanline;\n            if (currentScanline == 260) {\n                this.nes.mainDisplay.updateCanvas();\n                this.nes.CPU.skipFrame = false;\n                skipFrame = false;\n            }\n            currentScanline++;\n            if (currentScanline == 262) {\n                currentScanline = 0;\n                currentScanlineBufferIndex = 0;\n                currentSpriteOpUnit = 0;\n                oddFrameCycleSkipped = 0;\n            }\n            return true;\n        }\n    };\n\n    this.clearSecondaryOAM = function() {\n        if (currentCycle == 1) {\n            this.nes.MMU.secOAMInit();\n        }\n        secOAMIndex = 0;\n    };\n\n    this.fetchSprites = function() {\n        switch (currentCycle % 8) {\n            //Two garbage NameTable bytes\n            case 1:\n                oamReadBuffer = secOAM[currentSpriteOpUnit * 4];\n                break;\n            case 2:\n                oamReadBuffer = secOAM[currentSpriteOpUnit * 4 + 1];\n                break;\n            case 3:\n                //Tile attribute\n                oamReadBuffer = secOAM[currentSpriteOpUnit * 4 + 2];\n                spriteOpUnits[currentSpriteOpUnit][4] = oamReadBuffer;\n                break;\n            case 4:\n                //X pos\n                oamReadBuffer = secOAM[currentSpriteOpUnit * 4 + 3];\n                spriteOpUnits[currentSpriteOpUnit][0] = oamReadBuffer;\n                if (oamReadBuffer < 256) {\n                    for (var i = oamReadBuffer; i < oamReadBuffer + 8; i++) {\n                        if (i == 256)\n                            break;\n                        sprLkpTbl[i] = 1;\n                    }\n                }\n                break;\n            case 5:\n                break;\n            case 6:\n                this.getSpriteTileBitmapLow();\n                break;\n            case 7:\n                break;\n            case 0:\n                this.getSpriteTileBitmapHigh();\n                currentSpriteOpUnit++;\n                if (currentSpriteOpUnit > 7)\n                    currentSpriteOpUnit = 0;\n                break;\n        }\n    };\n\n    var spriteTileNum = 0;\n    var spriteEffectiveY = 0;\n    var spriteTileAddr = 0;\n    var tempSpriteOpUnitIndex = 0;\n    var tempSpritePatTblAddr = 0;\n    var verticalFlipping = false;\n    var horizontalFlipping = false;\n    this.getSpriteTileBitmapLow = function() {\n        tempSpriteOpUnitIndex = currentSpriteOpUnit * 4;\n\n        verticalFlipping = (spriteOpUnits[currentSpriteOpUnit][4] & 0x80) == 0x80;\n        horizontalFlipping = (spriteOpUnits[currentSpriteOpUnit][4] & 0x40) == 0x40;\n\n        spriteEffectiveY = currentScanline - secOAM[tempSpriteOpUnitIndex];\n\n        spriteTileNum = secOAM[tempSpriteOpUnitIndex + 1];\n        tempSpritePatTblAddr = this.spritePatTblAddr;\n        if (spriteSize === 16) {\n            spriteTileNum = secOAM[tempSpriteOpUnitIndex + 1] & 0xFE;\n            if (verticalFlipping) {\n                if (spriteEffectiveY < 8) {\n                    spriteTileNum++;\n                }\n                else {\n                    spriteEffectiveY = spriteEffectiveY - 8;\n                }\n            }\n            else {\n                if (spriteEffectiveY > 7) {\n                    spriteTileNum++;\n                    spriteEffectiveY = spriteEffectiveY - 8;\n                }\n            }\n            tempSpritePatTblAddr = secOAM[tempSpriteOpUnitIndex + 1] & 0x01;\n        }\n\n        //vertical flipping\n        if (verticalFlipping) {\n            spriteEffectiveY = Math.abs(spriteEffectiveY - 7);\n        }\n\n        spriteTileAddr = (spriteTileNum * 16) + spriteEffectiveY + 0x1000 * tempSpritePatTblAddr;\n        spriteOpUnits[currentSpriteOpUnit][2] = this.nes.Mapper.getCHRRom(spriteTileAddr);\n        //horizontal flipping\n        if (horizontalFlipping) {\n            spriteOpUnits[currentSpriteOpUnit][2] = bitReversalLookUp[spriteOpUnits[currentSpriteOpUnit][2]];\n        }\n    };\n\n    this.getSpriteTileBitmapHigh = function() {\n        spriteTileAddr += 8;\n        spriteOpUnits[currentSpriteOpUnit][3] = this.nes.Mapper.getCHRRom(spriteTileAddr);\n        if (horizontalFlipping) {\n            spriteOpUnits[currentSpriteOpUnit][3] = bitReversalLookUp[spriteOpUnits[currentSpriteOpUnit][3]];\n        }\n    };\n\n    var tileAddr = 0;\n    this.memoryFetch = function() {\n        switch (currentCycle % 8) {\n            // switch ((currentCycle - 1) & 0x07) {\n            case 0:\n                bgH <<= 8;\n                var T = (v & 0x7000) >> 12;\n                tileAddr += 8;\n                bgH = (bgH & 0xFF00) | (this.nes.Mapper.getCHRRom(tileAddr));\n                this.reloadShiftRegisters();\n                this.updateXScroll();\n                break;\n            case 2:\n                nt_byte = this.nes.MMU.ppuMem[0x2000 | (v & 0x0FFF)];\n                break;\n            case 4:\n                atH <<= 8;\n                atL <<= 8;\n                at_byte = this.nes.MMU.ppuMem[0x23C0 | (v & 0x0C00) | ((v >> 4) & 0x38) | ((v >> 2) & 0x07)];\n                if (((v & 0x3E0) >> 5) & 2)\n                    at_byte >>= 4;\n                if ((v & 0x1F) & 2)\n                    at_byte >>= 2;\n                atH = (atH & 0xFF00);\n                atL = (atL & 0xFF00);\n                if ((at_byte & 0x02) >> 1) {\n                    atH |= 0xFF;\n                }\n                if (at_byte & 0x01) {\n                    atL |= 0xFF;\n                }\n                break;\n            case 6:\n                bgL <<= 8;\n                var T = (v & 0x7000) >> 12;\n                tileAddr = (nt_byte * 16) + 0x1000 * (this.backgroundPatTblAddr) + T;\n                bgL = (bgL & 0xFF00) | (this.nes.Mapper.getCHRRom(tileAddr));\n                break;\n        }\n    };\n\n    this.getNameTableByte = function() {\n        nt_byte = this.nes.MMU.ppuMem[0x2000 | (v & 0x0FFF)];\n    };\n\n    this.getAttrTableByte = function() {\n        at_byte = this.nes.MMU.ppuMem[0x23C0 | (v & 0x0C00) | ((v >> 4) & 0x38) | ((v >> 2) & 0x07)];\n        this.at_bits = this.calcPaletteFromAttr(v & 0x1F, (v & 0x3E0) >> 5, at_byte);\n        atH = (atH & 0xFF00);\n        atL = (atL & 0xFF00);\n        if ((this.at_bits & 0x02) >> 1) {\n            atH |= 0xFF;\n        }\n        if (this.at_bits & 0x01) {\n            atL |= 0xFF;\n        }\n    };\n\n    /* PPU addresses within Pattern tables\n    DCBA98 76543210\n    ---------------\n    0HRRRR CCCCPTTT\n    |||||| |||||+++- T: Fine Y offset, the row number within a tile\n    |||||| ||||+---- P: Bit plane (0: "lower"; 1: "upper")\n    |||||| ++++----- C: Tile column\n    ||++++---------- R: Tile row\n    |+-------------- H: Half of sprite table (0: "left"; 1: "right")\n    +--------------- 0: Pattern table is at $0000-$1FFF\n    */\n\n    this.getTileBitmapLow = function() {\n        var T = (v & 0x7000) >> 12;\n        var addr = (nt_byte * 16) + 0x1000 * (this.backgroundPatTblAddr) + T;\n        bgL = (bgL & 0xFF00) | (this.nes.Mapper.getCHRRom(addr));\n    };\n\n    this.getTileBitmapHigh = function() {\n        var T = (v & 0x7000) >> 12;\n        var addr = (nt_byte * 16) + 8 + 0x1000 * (this.backgroundPatTblAddr) + T;\n        bgH = (bgH & 0xFF00) | (this.nes.Mapper.getCHRRom(addr));\n    };\n\n    //Update Coarse X bits. Ref NesDev Wiki\n    this.updateXScroll = function() {\n        if (renderBackground || renderSprite) {\n            if ((v & 0x001F) == 31) { // if coarse X == 31\n                v &= ~(0x001F); // coarse X = 0\n                v ^= 0x0400; // switch horizontal nametable\n            }\n            else {\n                v += 1; // increment coarse X    \n                vIncremented = true;\n            }\n        }\n    };\n    var vIncremented = false;\n    //Update Coarse Y bits. Ref NesDev Wiki\n    this.updateYScroll = function() {\n        if (renderBackground || renderSprite) {\n            if ((v & 0x7000) != 0x7000) { // if fine Y < 7\n                v += 0x1000; // increment fine Y\n            }\n            else {\n                v &= ~(0x7000); // fine Y = 0\n                y = (v & 0x03E0) >> 5; // let y = coarse Y\n                if (y == 29) {\n                    y = 0; // coarse Y = 0\n                    v ^= 0x0800; // switch vertical nametable\n                }\n                else if (y == 31) {\n                    y = 0; // coarse Y = 0, nametable not switched\n                }\n                else {\n                    y += 1; // increment coarse Y\n                }\n                v = (v & ~(0x03E0)) | (y << 5); // put coarse Y back into v\n            }\n        }\n    };\n\n    this.copyVScroll = function() {\n        if (renderBackground || renderSprite) {\n            v &= ~(0x7BE0);\n            v |= this.t & 0x7BE0;\n        }\n    };\n\n    this.copyHScroll = function() {\n        if (renderBackground || renderSprite) {\n            v &= ~(0x041F);\n            v |= this.t & 0x041F;\n        }\n    };\n\n    var tempSprAttr = 0;\n    var tempSpritePixel = 0;\n    var bgPixelColor = 0;\n    var sprite0Drawn = false;\n    var sprite0DrawnPrev = false;\n    var sprite0HitTargetScanline = 0;\n    var sprite0HitTargetCycle = 0;\n    this.renderPixel = function() {\n        bgPixel,\n        bgPixelColor = 0;\n        if (renderBackground == 1) {\n            if (currentCycle < 8) {\n                bgPixel = 0;\n            }\n            else {\n                tempBgHBit = (bgShiftH & shiftAmt) >> bgHShiftAmt;\n                tempBgLBit = (bgShiftL & shiftAmt) >> bgLShiftAmt;\n\n                bgPixel = tempBgHBit | tempBgLBit;\n\n                tempAtHBit = (atShiftH & shiftAmt) >> bgHShiftAmt;\n                tempAtLBit = (atShiftL & shiftAmt) >> bgLShiftAmt;\n\n                bgPixelColor = palette[(tempAtHBit | tempAtLBit) * 4 + bgPixel];\n            }\n            bgShiftH <<= 1;\n            bgShiftL <<= 1;\n            atShiftH <<= 1;\n            atShiftL <<= 1;\n        }\n\n        spritePixel = 0;\n        spritePixelColor = 0;\n\n        if (renderSprite == 1) {\n            if (currentCycle < 8) {\n                spritePixel = 0;\n            }\n            else {\n                if (sprLkpTbl[currentCycle] == 1) {\n                    //loop for all sprite pixels on current cycle output\n                    //TODO: sprite hit logic for large sprites\n                    for (var i = 7; i >= 0; i--) {\n                        if (spriteOpUnits[i][4] != 256) {\n                            var y = currentCycle - spriteOpUnits[i][0];\n                            if (y >= 0 && y < 8) {\n                                tempSpriteH = (spriteOpUnits[i][3] >> (7 - y)) & 1;\n                                tempSpriteL = (spriteOpUnits[i][2] >> (7 - y)) & 1;\n                                tempSpritePixel = (tempSpriteH << 1) | tempSpriteL;\n                                if (tempSpritePixel) {\n                                    if (i == 0 && checkSprite0Hit && (!sprite0Drawn)) {\n                                        if (currentCycle != 255) {\n                                            if (bgPixel > 0) {\n                                                sprite0Drawn = true;\n                                                sprite0DrawnPrev = true;\n                                                sprite0HitTargetCycle = currentCycle + 2;\n                                            }\n                                        }\n                                    }\n                                    spritePixel = tempSpritePixel;\n                                    tempSprAttr = spriteOpUnits[i][4];\n                                    tempSpritePriority = (tempSprAttr & 0x20) >> 5;\n                                    spritePixelColor = palette[16 + (tempSprAttr & 0x03) * 4 + spritePixel];\n                                }\n                            }\n                            // var x = spriteOpUnits[i][0];\n                            // if ((x <= currentCycle) && (currentCycle < x + 8)) {\n                            //     // if (sprXLkpTbl[i][currentCycle]) {\n                            //     var pixelShift = currentCycle - x;\n                            //     tempSpriteH = (spriteOpUnits[i][3] >> (7 - pixelShift)) & 1;\n                            //     tempSpriteL = (spriteOpUnits[i][2] >> (7 - pixelShift)) & 1;\n                            //     tempSpritePixel = (tempSpriteH << 1) | tempSpriteL;\n                            //     if (tempSpritePixel) {\n                            //         if (i == 0 && checkSprite0Hit && (!sprite0Drawn)) {\n                            //             if (currentCycle != 255) {\n                            //                 if (bgPixel > 0) {\n                            //                     sprite0Drawn = true;\n                            //                     sprite0HitTargetCycle = currentCycle + 2;\n                            //                 }\n                            //             }\n                            //         }\n                            //         spritePixel = tempSpritePixel;\n                            //         tempSprAttr = spriteOpUnits[i][4];\n                            //         tempSpritePriority = (tempSprAttr & 0x20) >> 5;\n                            //         spritePixelColor = palette[16 + (tempSprAttr & 0x03) * 4 + spritePixel];\n                            //     }\n                            // }\n                        }\n                    }\n                    sprLkpTbl[currentCycle] = 0;\n                }\n            }\n        }\n        //Priority based output\n        if (spritePixel == 0) {\n            outputPixel = bgPixelColor;\n            if (bgPixel == 0) {\n                outputPixel = basePalette; //this.palette[0];\n            }\n        }\n        else if (spritePixel > 0 && bgPixel == 0) {\n            outputPixel = spritePixelColor;\n        }\n        else if (spritePixel > 0 && bgPixel > 0) {\n            if (!tempSpritePriority) {\n                outputPixel = spritePixelColor;\n            }\n            else {\n                outputPixel = bgPixelColor;\n            }\n        }\n        if (sprite0Drawn && currentCycle == sprite0HitTargetCycle) {\n            sprite0HitTargetScanline = currentScanline;\n            this.ppuStatusBits = this.ppuStatusBits & 0b10111111;\n            this.ppuStatusBits = this.ppuStatusBits | 0b01000000;\n        }\n        if (this.renderGreyscale)\n            outputPixel &= 0x30;\n        if ((renderSprite & renderBackground) == 1) {\n            //Render to offscreen buffer\n            offScreenBuffer[currentScanlineBufferIndex] = paletteColorsRendered[outputPixel];\n        }\n        else if (renderSprite == 1) {\n            offScreenBuffer[currentScanlineBufferIndex] = paletteColorsRendered[spritePixelColor];\n        }\n        else if (renderBackground == 1) {\n            offScreenBuffer[currentScanlineBufferIndex] = paletteColorsRendered[outputPixel];\n        }\n        currentScanlineBufferIndex++;\n    };\n\n    this.getAtBit = function(byte, shiftBit) {\n        byte <<= shiftBit;\n        return (byte & 0x80) >> 7;\n    };\n\n    this.reloadShiftRegisters = function() {\n        bgShiftL = bgL;\n        bgShiftH = bgH;\n        atShiftH = atH;\n        atShiftL = atL;\n    };\n\n    this.calcPalette = function(x, y, at_byte) {\n        var pal = at_byte >> ((x & 0x01) * 2);\n        pal = pal >> ((y & 0x01) * 4);\n        return pal & 0x03;\n    };\n\n    this.rendering = function() {\n        if ((renderBackground == 1) || (renderSprite == 1))\n            return true;\n        else return false;\n    };\n\n\n\n\n    this.renderPixelFast = function() {\n        bgPixel,\n        bgPixelColor = 0;\n        if (renderBackground == 1) {\n            tempBgHBit = (bgShiftH & shiftAmt) >> bgHShiftAmt;\n            tempBgLBit = (bgShiftL & shiftAmt) >> bgLShiftAmt;\n\n            bgPixel = tempBgHBit | tempBgLBit;\n\n            tempAtHBit = (atShiftH & shiftAmt) >> bgHShiftAmt;\n            tempAtLBit = (atShiftL & shiftAmt) >> bgLShiftAmt;\n\n            bgPixelColor = palette[(tempAtHBit | tempAtLBit) * 4 + bgPixel];\n            bgShiftH <<= 1;\n            bgShiftL <<= 1;\n            atShiftH <<= 1;\n            atShiftL <<= 1;\n        }\n\n        spritePixel = 0;\n        spritePixelColor = 0;\n\n        if (renderSprite == 1) {\n            if (sprLkpTbl[currentCycle] == 1) {\n                //loop for all sprite pixels on current cycle output\n                //TODO: sprite hit logic for large sprites\n                for (var i = 7; i >= 0; i--) {\n                    if (spriteOpUnits[i][4] != 256) {\n                        var y = currentCycle - spriteOpUnits[i][0];\n                        if (y >= 0 && y < 8) {\n                            tempSpriteH = (spriteOpUnits[i][3] >> (7 - y)) & 1;\n                            tempSpriteL = (spriteOpUnits[i][2] >> (7 - y)) & 1;\n                            tempSpritePixel = (tempSpriteH << 1) | tempSpriteL;\n                            if (tempSpritePixel) {\n                                if (i == 0 && checkSprite0Hit && (!sprite0Drawn)) {\n                                    if (currentCycle != 255) {\n                                        if (bgPixel > 0) {\n                                            sprite0Drawn = true;\n                                            sprite0DrawnPrev = true;\n                                            sprite0HitTargetCycle = currentCycle + 2;\n                                        }\n                                    }\n                                }\n                                spritePixel = tempSpritePixel;\n                                tempSprAttr = spriteOpUnits[i][4];\n                                tempSpritePriority = (tempSprAttr & 0x20) >> 5;\n                                spritePixelColor = palette[16 + (tempSprAttr & 0x03) * 4 + spritePixel];\n                            }\n                        }\n                    }\n                }\n                sprLkpTbl[currentCycle] = 0;\n            }\n        }\n        //Priority based output\n        if (spritePixel == 0) {\n            outputPixel = bgPixelColor;\n            if (bgPixel == 0) {\n                outputPixel = basePalette; //this.palette[0];\n            }\n        }\n        else if (spritePixel > 0 && bgPixel == 0) {\n            outputPixel = spritePixelColor;\n        }\n        else if (spritePixel > 0 && bgPixel > 0) {\n            if (!tempSpritePriority) {\n                outputPixel = spritePixelColor;\n            }\n            else {\n                outputPixel = bgPixelColor;\n            }\n        }\n        if (sprite0Drawn && currentCycle == sprite0HitTargetCycle) {\n            sprite0HitTargetScanline = currentScanline;\n            this.ppuStatusBits = this.ppuStatusBits & 0b10111111;\n            this.ppuStatusBits = this.ppuStatusBits | 0b01000000;\n        }\n        if (this.renderGreyscale)\n            outputPixel &= 0x30;\n        if ((renderSprite & renderBackground) == 1) {\n            //Render to offscreen buffer\n            offScreenBuffer[currentScanlineBufferIndex] = paletteColorsRendered[outputPixel];\n        }\n        else if (renderSprite == 1) {\n            offScreenBuffer[currentScanlineBufferIndex] = paletteColorsRendered[spritePixelColor];\n        }\n        else if (renderBackground == 1) {\n            offScreenBuffer[currentScanlineBufferIndex] = paletteColorsRendered[outputPixel];\n        }\n        currentScanlineBufferIndex++;\n    };\n\n}\n\n\n//# sourceURL=webpack:///./public/js/ppu.js?')},"./public/js/pulse.js":
/*!****************************!*\
  !*** ./public/js/pulse.js ***!
  \****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pulse; });\n/*global*/\n\nfunction pulse() {\n    this.Enabled = false;\n    this.doIrq = false;\n    this.channel = 0;\n    //Square wave channel VARs\n    this.volume = 0; //Square channel volume\n    this.sawEnvDisable = true; //Use Envelop or Constant volume\n    this.lenCounterDisable = false; //envelope loop / length counter halt\n    this.dutyCycle = 0; //Duty cycle of the wave\n    this.period = 0; //11 bit Period \n    this.timerPeriod = 0; //timer for counting down period\n    this.envPeriod = 0x0F; //Envelop decay counter\n    this.periodLowBits = 0; //lower 8 bit period\n    this.periodHighBits = 0; //High 3 bit period\n    this.lenCounter = 0; //Len counter value\n    this.envVolume = 0; //Envelop value\n    this.envStartFlag = false;\n    this.dividerPeriod = 0;\n    this.decayLvlCount = 0;\n    this.envCounter = 0; //Counter to countdown to 0 from envelope period\n    this.inhibitInterrupt = true; //Inhibit the frame counter IR\n    this.sweepEnabled = false; //Enable Sweep\n    this.sweepDividerPeriod = 0; //Sweep divider Period\n    this.sweepNegate = 0;\n    this.sweepShiftCount = 0;\n    this.sweepCount = 0;\n    this.sweepReloadFlag = false;\n    this.currentSequence = 0;\n    var outputValue = false;\n    var sweepTargetPeriod = 0;\n    var dutyCycles = [\n        [0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 1, 1, 0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1, 0, 0, 0],\n        [1, 0, 0, 1, 1, 1, 1, 1]\n    ];\n    var sweepChangeAmt = 0;\n\n    //calculate the current sequence value\n    this.calcSequence = function(duty, sequence) {\n        return dutyCycles[duty][sequence];\n    };\n\n    //Clocks the sequencer\n    this.clockSequencer = function() {\n        if (this.calcSequence(this.dutyCycle, this.currentSequence) == 1) {\n            outputValue = true;\n        }\n        else outputValue = false;\n        this.currentSequence++;\n        if (this.currentSequence == 8)\n            this.currentSequence = 0;\n    };\n\n    this.clockDecayLevelCounter = function() {\n        if (this.decayLvlCount == 0) {\n            if (this.lenCounterDisable) { //if loop flag set, reload the decay \n                this.decayLvlCount = 15;\n            }\n        }\n        else {\n            this.decayLvlCount--;\n        }\n    };\n\n    this.updateTargetPeriod = function() {\n        sweepChangeAmt = this.period >> this.sweepShiftCount;\n        if (this.sweepNegate == 0) { //Add sweep\n            sweepTargetPeriod = this.period + sweepChangeAmt;\n        }\n        else if (this.sweepNegate == 1) { //Negate sweep\n            if (this.channel == 1) {\n                sweepTargetPeriod = this.period - sweepChangeAmt - 1;\n            }\n            else if (this.channel == 2) {\n                sweepTargetPeriod = this.period - sweepChangeAmt;\n            }\n        }\n    };\n\n    this.updateEnvelope = function() {\n        if (!this.envStartFlag) {\n            //Now clock divider\n            if (this.dividerPeriod == 0) { //Reload divider period\n                this.dividerPeriod = this.volume; // + 1;\n                //Now clock Decay level counter\n                this.clockDecayLevelCounter();\n            }\n            else {\n                this.dividerPeriod--;\n            }\n        }\n        else {\n            this.envStartFlag = false; //Clear Start flag\n            this.decayLvlCount = 15; //Reload Decay level counter\n            this.dividerPeriod = this.volume; // + 1; //Reload divider period\n        }\n    };\n\n    this.updSweepAndLengthCounter = function() {\n        //Update Lenght Counter\n        if (!this.enabled) {\n            this.lenCounter = 0;\n        }\n        else if (!this.lenCounterDisable && this.lenCounter > 0) {\n            this.lenCounter--;\n        }\n        //Update Sweep\n        //Divider has reached 0 do sweep now\n        if (this.sweepCount == 0) {\n            this.sweepCount = this.sweepDividerPeriod; //Relaod sweep divider count\n            this.sweepReloadFlag = false; //clear reload flag\n            if (this.sweepEnabled) {\n                if (sweepTargetPeriod <= 0x7FF) { //Adjust the sweep\n                    this.period = sweepTargetPeriod;\n                    this.updateTargetPeriod();\n                }\n            }\n        }\n        else if (!this.sweepReloadFlag) {\n            this.sweepCount--;\n        }\n        if (this.sweepReloadFlag) {\n            this.sweepCount = this.sweepDividerPeriod + 1; //Relaod sweep divider count\n            this.sweepReloadFlag = false; //clear reload flag\n        }\n    };\n\n    //Clock the sequencer after timer has counted down\n    this.clock = function() {\n        if (this.timerPeriod <= 0) {\n            this.clockSequencer();\n            this.timerPeriod = this.period;//this.periodLowBits | (this.periodHighBits << 8) + 1;\n        }\n        else {\n            this.timerPeriod--;\n        }\n    };\n\n    this.output = function() {\n        if (outputValue) {\n            if (!this.lenCounterDisable && this.lenCounter <= 0)\n                return 0;\n            if ((sweepTargetPeriod <= 0x7FF) && (this.period >= 0x08)) {\n                if (!this.sawEnvDisable) {\n                    return this.decayLvlCount;\n                }\n                else {\n                    return this.volume;\n                }\n            }\n            else {\n                return 0;\n            }\n        }\n        else return 0;\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/pulse.js?')},"./public/js/triangle.js":
/*!*******************************!*\
  !*** ./public/js/triangle.js ***!
  \*******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return triangle; });\n/*global Tone*/\n\nfunction triangle() {\n    this.Enabled = false;\n    this.doIrq = false;\n    this.channel = 0;\n\n    //Triangle wave channel VARs\n    this.controlFlag = false;\n    this.counterReload = 0;\n    this.periodLowBits = 0;\n    this.periodHighBits = 0;\n    this.linearCounterReloadFlag = false;\n    this.currentSequence = 0;\n    this.lenCounter = 0; //Len counter value\n    this.linearCounter = 0;\n    this.outputValue = 0;\n    this.sequenceTable = [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n    ];\n\n    //Clocks the sequencer\n    this.clockSequencer = function() {\n        // if (!this.controlFlag && (this.lenCounter > 0) && (this.linearCounter > 0)) {\n        if ((this.lenCounter > 0) && (this.linearCounter > 0)) {\n            this.outputValue = this.sequenceTable[this.currentSequence];\n            this.currentSequence++;\n            if (this.currentSequence == 32)\n                this.currentSequence = 0;\n        }\n    };\n\n    this.clock = function() {\n        if (this.period <= 0) {\n            this.clockSequencer();\n            this.period = this.periodLowBits | (this.periodHighBits << 8) + 1;\n        }\n        else {\n            this.period--;\n        }\n    };\n\n    this.updateLinearCounter = function() {\n        if (this.linearCounterReloadFlag) {\n            this.linearCounter = this.counterReload;\n        }\n        else if (this.linearCounter > 0) {\n            this.linearCounter--;\n        }\n        if (!this.controlFlag) {\n            this.linearCounterReloadFlag = false;\n        }\n    };\n\n    this.updateLenCounter = function() {\n        if (!this.controlFlag && this.lenCounter > 0) {\n            this.lenCounter--;\n        }\n    };\n\n    this.output = function() {\n        return this.outputValue;\n    };\n}\n\n\n//# sourceURL=webpack:///./public/js/triangle.js?')}});